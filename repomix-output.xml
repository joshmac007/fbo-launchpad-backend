This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    architecture-understanding.mdc
    clean-code.mdc
    code-quality.mdc
    cursor-rules-location.mdc
    debug.mdc
    directory-structure.mdc
    error-documentation.mdc
    implement.mdc
    lessons-learned.mdc
    logging-errors.mdc
    memory.mdc
    plan.mdc
    python.mdc
    react.mdc
    tailwind.mdc
docs/
  lessons-learned.md
  lessons-learned.mdc
fbo-launchpad-backend/
  .cursor/
    rules/
      error-documentation.mdc
      lessons-learned.mdc
  docs/
    architecture.md
    error-documentation.md
    frontend_integration_guide.md
    fuel_order_queue_api.md
    fuel_order_routes_api_docs.md
    lessons-learned.md
    networkDocumentation.md
    product_requirement_docs.md
    technical.md
    testing_documentation.md
    testingContext.md
  fbo_launchpad_backend.egg-info/
    dependency_links.txt
    PKG-INFO
    requires.txt
    SOURCES.txt
    top_level.txt
  migrations/
    versions/
      05eadf8716a5_implement_pbac_models_permission_role_.py
      1a764e4d3fa2_add_fuel_truck_customer_aircraft_fuel_.py
      1ba38c67c062_create_user_table.py
      87256ef2abc1_initial_migration.py
      ae3b7293103c_add_aircraft_type_column_to_aircraft_.py
      f1d4eec2dff2_add_is_active_column_back_to_users_table.py
    alembic.ini
    env.py
    README
    script.py.mako
  src/
    models/
      __init__.py
      aircraft.py
      base.py
      customer.py
      fuel_order.py
      fuel_truck.py
      permission.py
      role_permission.py
      role.py
      settings.py
      user.py
    routes/
      admin/
        __init__.py
        aircraft_admin_routes.py
        assignment_settings_routes.py
        customer_admin_routes.py
        permission_admin_routes.py
        role_admin_routes.py
        routes.py
        user_admin_routes.py
      __init__.py
      aircraft_routes.py
      auth_routes.py
      customer_routes.py
      fuel_order_routes.py
      fuel_truck_routes.py
      user_routes.py
    schemas/
      __init__.py
      admin_schemas.py
      aircraft_schemas.py
      auth_schemas.py
      customer_schemas.py
      fuel_order_schemas.py
      fuel_truck_schemas.py
      permission_schemas.py
      role_schemas.py
      user_schemas.py
    services/
      __init__.py
      aircraft_service.py
      auth_service.py
      customer_service.py
      fuel_order_service.py
      fuel_truck_service.py
      permission_service.py
      role_service.py
      user_service.py
    utils/
      __init__.py
      auth.py
      decorators.py
      rate_limiting.py
      README.md
    __init__.py
    app.py
    cli.py
    config.py
    extensions.py
  tasks/
    active_Context.md
    tasks_plan.md
  tests/
    conftest.py
    test_admin_permissions.py
    test_admin_roles.py
    test_admin_users.py
    test_auth.py
    test_fuel_order_api.py
    test_fuel_orders.py
    test_fuel_trucks.py
    test_models.py
    test_permissions.py
    test_routes.py
    test_users.py
  .gitignore
  config.py
  create_admin.py
  docker-compose.yml
  Dockerfile
  init.sql
  pytest.ini
  repomix-output.xml
  requirements.txt
  setup.py
  test-requirements.txt
fbo-launchpad-frontend-csr/
  docs/
    architecture.md
    technical.md
    ui_implementation.md
  public/
    vite.svg
  src/
    assets/
      react.svg
    components/
      admin/
        AircraftForm.jsx
        AircraftTable.jsx
        CustomerForm.jsx
        CustomerTable.jsx
        PermissionListTable.jsx
        RoleForm.jsx
        RolePermissionManager.jsx
        RoleTable.jsx
        TruckForm.jsx
        UserForm.jsx
      auth/
        Login.jsx
        Login.test.jsx
      common/
        DarkModeToggle.jsx
        Icons.tsx
        Modal.jsx
        PaginationControls.jsx
        ProtectedRoute.jsx
        StatusBadge.jsx
      dashboard/
        OrderStatusCard.jsx
        RecentReceipts.jsx
      layout/
        AdminLayout.jsx
        AdminTabBar.jsx
        MainLayout.jsx
        Navbar.jsx
      orders/
        Dashboard.jsx
        Dashboard.tsx
        FuelOrdersTable.jsx
        FuelOrdersTable.tsx
        OrderFilters.jsx
        OrderGrid.jsx
        OrderStatusCard.tsx
    context/
      DarkModeContext.jsx
    contexts/
      AuthContext.jsx
    hooks/
      useAdminRole.js
      useOrders.ts
    pages/
      admin/
        AircraftManagementPage.jsx
        AssignmentSettingsPage.jsx
        CustomerManagementPage.jsx
        PermissionListPage.jsx
        RoleManagementPage.jsx
        TruckManagementPage.jsx
        UserManagementPage.jsx
      lst/
        QueuedOrdersPage.jsx
      DashboardPage.jsx
      LoginPage.jsx
      NotFoundPage.jsx
      OrderCreatePage.jsx
      OrderDetailPage.jsx
    services/
      AircraftService.js
      apiService.js
      authService.js
      CustomerService.js
      FuelOrderService.js
      FuelTruckService.js
      PermissionService.js
      RoleService.js
      UserService.js
    styles/
      global.css
    test/
      setup.js
      utils.jsx
    types/
      orders.ts
    utils/
      formatters.js
      jwt.js
    App.jsx
    main.jsx
    vite-env.d.ts
  tasks/
    active_Context.md
    progress.md
  .env
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.cjs
  postcss.config.js
  README.md
  tailwind.config.js
  vite.config.js
  vitest.config.js
tasks/
  active_context.md
  tasks_plan.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/architecture-understanding.mdc">
---
description: 
globs: architecture.md
alwaysApply: false
---
---
description: rules to parse solution architecture from docs/architecture.md
globs: 
---
# Architecture Understanding
READ_ARCHITECTURE: |
  File: docs/architecture.md @architecture.md
  Required parsing:
  1. Load and parse complete Mermaid diagram
  2. Extract and understand:
     - Module boundaries and relationships
     - Data flow patterns
     - System interfaces
     - Component dependencies
  3. Validate any changes against architectural constraints
  4. Ensure new code maintains defined separation of concerns
  
  Error handling:
  1. If file not found: STOP and notify user
  2. If diagram parse fails: REQUEST clarification
  3. If architectural violation detected: WARN user
</file>

<file path=".cursor/rules/clean-code.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: Guidelines for writing clean, maintainable, and human-readable code. Apply these rules when writing or reviewing code to ensure consistency and quality.
globs: 
---
# Clean Code Guidelines

## Constants Over Magic Numbers
- Replace hard-coded values with named constants
- Use descriptive constant names that explain the value's purpose
- Keep constants at the top of the file or in a dedicated constants file

## Meaningful Names
- Variables, functions, and classes should reveal their purpose
- Names should explain why something exists and how it's used
- Avoid abbreviations unless they're universally understood

## Smart Comments
- Don't comment on what the code does - make the code self-documenting
- Use comments to explain why something is done a certain way
- Document APIs, complex algorithms, and non-obvious side effects

## Single Responsibility
- Each function should do exactly one thing
- Functions should be small and focused
- If a function needs a comment to explain what it does, it should be split

## DRY (Don't Repeat Yourself)
- Extract repeated code into reusable functions
- Share common logic through proper abstraction
- Maintain single sources of truth

## Clean Structure
- Keep related code together
- Organize code in a logical hierarchy
- Use consistent file and folder naming conventions

## Encapsulation
- Hide implementation details
- Expose clear interfaces
- Move nested conditionals into well-named functions

## Code Quality Maintenance
- Refactor continuously
- Fix technical debt early
- Leave code cleaner than you found it

## Testing
- Write tests before fixing bugs
- Keep tests readable and maintainable
- Test edge cases and error conditions

## Version Control
- Write clear commit messages
- Make small, focused commits
- Use meaningful branch names
</file>

<file path=".cursor/rules/code-quality.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: Code Quality Guidelines
globs: 
---
# Code Quality Guidelines

## Verify Information
Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.

## File-by-File Changes
Make changes file by file and give me a chance to spot mistakes.

## No Apologies
Never use apologies.

## No Understanding Feedback
Avoid giving feedback about understanding in comments or documentation.

## No Whitespace Suggestions
Don't suggest whitespace changes.

## No Summaries
Don't summarize changes made.

## No Inventions
Don't invent changes other than what's explicitly requested.

## No Unnecessary Confirmations
Don't ask for confirmation of information already provided in the context.

## Preserve Existing Code
Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.

## Single Chunk Edits
Provide all edits in a single chunk instead of multiple-step instructions or explanations for the same file.

## No Implementation Checks
Don't ask the user to verify implementations that are visible in the provided context.

## No Unnecessary Updates
Don't suggest updates or changes to files when there are no actual modifications needed.

## Provide Real File Links
Always provide links to the real files, not x.md.

## No Current Implementation
Don't show or discuss the current implementation unless specifically requested.
</file>

<file path=".cursor/rules/cursor-rules-location.mdc">
---
description: Creating new rules for Cursor or make documentation
globs: 
alwaysApply: false
---
---
description: Cursor Rules Location
globs: *.mdc
---
# Cursor Rules Location

Rules for placing and organizing Cursor rule files in the repository.

<rule>
name: cursor_rules_location
description: Standards for placing Cursor rule files in the correct directory
filters:
  # Match any .mdc files
  - type: file_extension
    pattern: "\\.mdc$"
  # Match files that look like Cursor rules
  - type: content
    pattern: "(?s)<rule>.*?</rule>"
  # Match file creation events
  - type: event
    pattern: "file_create"

actions:
  - type: reject
    conditions:
      - pattern: "^(?!\\.\\/\\.cursor\\/rules\\/.*\\.mdc$)"
        message: "Cursor rule files (.mdc) must be placed in the .cursor/rules directory"

  - type: suggest
    message: |
      When creating Cursor rules:

      1. Always place rule files in PROJECT_ROOT/.cursor/rules/:
         ```
         .cursor/rules/
         ├── your-rule-name.mdc
         ├── another-rule.mdc
         └── ...
         ```

      2. Follow the naming convention:
         - Use kebab-case for filenames
         - Always use .mdc extension
         - Make names descriptive of the rule's purpose

      3. Directory structure:
         ```
         PROJECT_ROOT/
         ├── .cursor/
         │   └── rules/
         │       ├── your-rule-name.mdc
         │       └── ...
         └── ...
         ```

      4. Never place rule files:
         - In the project root
         - In subdirectories outside .cursor/rules
         - In any other location

examples:
  - input: |
      # Bad: Rule file in wrong location
      rules/my-rule.mdc
      my-rule.mdc
      .rules/my-rule.mdc

      # Good: Rule file in correct location
      .cursor/rules/my-rule.mdc
    output: "Correctly placed Cursor rule file"

metadata:
  priority: high
  version: 1.0
</rule>
</file>

<file path=".cursor/rules/debug.mdc">
---
description: 
globs: 
alwaysApply: true
---
description: Include these rules while DEBUGGING.
globs: 
alwaysApply: true
---
<DEBUGGING>
Below debugging routine is for persistent errors or incomplete fixes. So use this routine only when got stuck.
<DIAGNOSE>
- Gather all error messages, logs, and behavioral symptoms
- Add relevant context from files
- Retrieve relevant project architecture, plan and current working task as specified in @memory.mdc 
</DIAGNOSE>

- Whenever you fail with any test result, always add more context using <DIAGNOSE> and debug the issue effectively first, then when you have complete information move towards a fix. 
- Explain your OBSERVATIONS and then give your REASONINGS to explain why this is EXACTLY the issue and not anything else. 
- If you aren't sure, first get more OBSERVATIONS by adding more <DIAGNOSE> context to the issue so you exactly and specifically know what's wrong. Additionally you can seek <CLARIFICATION> if required.
- Understand architecture using <ANALYZE CODE> (defined in [implement.mdc](mdc:.cursor/rules/implement.mdc) ) relevant to the issue.
- Use <STEP BY STEP REASONING> to think of all possible causes like architectural misalignment, design flaw rather than just a bug, etc.
- Look for similar patterns already solved elsewhere in the codebase in  @error-documentation.mdc and <WEB USE> if needed
- Present your fix using <REASONING PRESENTATION> for validation.
- Start modifying code to update and fix things using <SYSTEMATIC CODE PROTOCOL> and <TESTING> (both defined in [implement.mdc](mdc:.cursor/rules/implement.mdc) ).

</DEBUGGING>
</file>

<file path=".cursor/rules/directory-structure.mdc">
---
description: Directory structure, structure of project
globs: 
alwaysApply: false
---
---
description: directory structure to follow
globs: 
alwaysApply: false
---
---
description: the top-level directory structure for the project
globs: 
alwaysApply: false
---     
# Directory Structure
```mermaid
flowchart TD
    Root[Project Root]
    Root --> Docs[docs/]
    Root --> Tasks[tasks/]
    Root --> Cursor[.cursor/rules/]
    Root --> CLINE[.clinerules]
    Root --> SourceCode[src/]
    Root --> Test[test/]
    Root --> Utils[utils/]
    Root --> Config[config/]
    Root --> Data[data/]
    Root --> Other[Other Directories]
```
</file>

<file path=".cursor/rules/error-documentation.mdc">
---
description: When documenting errors
globs: 
alwaysApply: false
---
# Error Documentation

This document records the major failure points encountered in the FBO LaunchPad project and how they were resolved.

## 1. PostCSS Plugin Loading Failure
**Symptoms:**
- Build-time error in Vite: `Failed to load PostCSS config: Cannot find module '@tailwindcss/postcss'`.

**Cause:**
- Incorrect plugin key in `postcss.config.cjs` (`'@tailwindcss/postcss'` instead of `'tailwindcss'`).

**Resolution:**
1. Updated `postcss.config.cjs` to:
   ```js
   module.exports = {
     plugins: {
       'postcss-nesting': {},
       'tailwindcss': {},
       autoprefixer: {},
     }
   }
   ```
2. Installed missing dependencies:
   ```bash
   npm install -D tailwindcss postcss autoprefixer postcss-nesting
   ```

---

## 2. `process is not defined` in Vite
**Symptoms:**
- Runtime error in console: `ReferenceError: process is not defined` in `useOrders.ts`.

**Cause:**
- Frontend code was accessing `process.env` directly in a Vite project.

**Resolution:**
1. Switched to Vite-specific environment access:
   ```ts
   const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;
   ```
2. Added `src/vite-env.d.ts` for TypeScript definitions:
   ```ts
   /// <reference types="vite/client" />
   interface ImportMetaEnv {
     readonly VITE_API_BASE_URL: string;
   }
   interface ImportMeta { readonly env: ImportMetaEnv }
   ```
3. Created `.env` in the frontend root with:
   ```env
   VITE_API_BASE_URL=http://localhost:5000/api
   ```

---

## 3. Network Error Fetching Orders
**Symptoms:**
- Frontend error: `Error Loading orders: Network Error` when calling `/orders` endpoint.

**Causes & Resolutions:**
- **Backend not running:** Started Flask server:
  ```bash
  cd fbo-launchpad-backend
  flask run --port 5001
  ```
- **Port mismatch:** Updated frontend environment or backend run port to match (e.g., `5001`).
- **Authentication missing:** Ensured login flow stores JWT in `localStorage` under `token` and included in request headers.

---

## 4. Other Common Issues
- **CORS Errors:** If present, configure Flask-CORS in the backend:
  ```py
  from flask_cors import CORS
  app = Flask(__name__)
  CORS(app, resources={r"/api/*": {"origins": "*"}})
  ```
- **Invalid JSON Responses:** Ensure backend API returns valid JSON with `data` field.

---

*Document last updated: YYYY-MM-DD*
</file>

<file path=".cursor/rules/implement.mdc">
---
description: 
globs: 
alwaysApply: true
---
description: Include these rules while IMPLEMENTATION/Coding.
globs: 
alwaysApply: true
---
Before every code implementation/change ALWAYS do 2 things:
a. Read and understand the documentation in `docs/` and `tasks/`
a. Get required code context from `src` and other codes at other places.
---
# IMPLEMENTATION (ACT MODE/Code MODE):
<PROGRAMMING PRINCIPLES>
- algorithm_efficiency: use the most efficient algorithms and data structures
- modularity: write modular code, break complex logic into smaller atomic parts. Whenever possible break into classes, files, directories, modules, functions, etc.
- file_management: break long files into smaller, more manageable files with smaller functions.
- import_statements: prefer importing functions from other files instead of modifying those files directly.
- file_organization: organize files into directories and folders.
- reuse: prefer to reuse existing code instead of writing it from scratch. 
- code_preservation: Preserve What Works. Don’t modify working components without necessity.
- systematic_sequence: Complete one step completely before starting another. Keep systematic sequence of functionalities.
- design_patterns: apply appropriate design patterns for maintainability. Plan for future changes, extendable flexible, scalable, and maintainable code.
- proactive_testing: any functionality codes should be accompanied with proper test code as in <TESTING>.
</PROGRAMMING PRINCIPLES>

<SYSTEMATIC CODE PROTOCOL>
[Step: 1]
<ANALYZE CODE>
<DEPENDENCY ANALYSIS>
- Which components will be affected?
- What dependencies exist?
- Is this local or does it affect core logic?
- Which functionalities will be affected and how?
- What cascading effects will this change have?
</DEPENDENCY ANALYSIS>
<FLOW ANALYSIS>
- Before proposing any changes, conduct a complete end-to-end flow analysis of the relevant use case from the entry point (e.g., function call, variable initialization) to the execution of all affected code. 
- Track the flow of data and logic throughout all components involved to understand its full scope.
</FLOW ANALYSIS>
- Document these dependencies thoroughly, including the specific usage of functions or logic in files specified by @memory.mdc
</ANALYZE CODE>

[Step: 2]
<PLAN CODE>
- If needed initiate <CLARIFICATION> process.
- Use <STEP BY STEP REASONING> to Outline a detailed plan including component dependencies, architectural considerations before coding. Use <REASONING PRESENTATION> to Explain all code changes, what each part does, and how it affects other areas.
<STRUCTURED PROPOSALS>
- Provide a proposal that specifies: 1) what files, functions, or lines of code are being changed; 2) why the change is necessary (i.e. bug fix, improvement or new feature); 3) all of the directly impacted modules or files; 4) potential side effects; 5) a detailed explanation of any tradeoffs.
</STRUCTURED PROPOSALS> 
</PLAN CODE>

[Step: 3]
<MAKE CHANGES>

1. Document Current State in files specified by @memory.mdc
- What’s currently working?
- What’s the current error/issue?
- Which files will be affected?

2. Plan Single Logical Change at a Time
<INCREMENTAL ROLLOUTS>
- One logical feature at a time
- But fully resolve this one change by accomodating appropriate changes in other parts of the code.
- Adjust all existing dependencies and issues created by this change.
- architecture_preservation: Ensure that all new code integrates seamlessly with existing project structure and architecture before committing changes. Do not make changes that disrupt existing code organization or files.
</INCREMENTAL ROLLOUTS>

3. Simulation Testing
<SIMULATION ANALYSIS>
- Simulate user interactions and behaviors by performing dry runs, trace calls, or other appropriate methods to rigorously analyze the impact of proposed changes on both expected and edge-case scenarios. 
- Generate feedback on all potential side effects.
</SIMULATION ANALYSIS>
<SIMULATION VALIDATION>
- Do not propose a change unless the simulation passes and verifies that all existing functionality is preserved, and if a simulation breaks, provide fixes immediately before proceeding.
</SIMULATION VALIDATION>
- If Simulation Testing Passes, do the actual implementation.
</MAKE CHANGES>

[Step: 4] Perform <TESTING>.

[Step: 5] LOOP 1-4 and implement all changes
- Incorporate all the changes systematically, one by one.
- Verify the changes and test them one by one.

[Step: 6] Optimize the implemented codes
- Optimize the implemented code, after all changes are tested and verified.

</SYSTEMATIC CODE PROTOCOL>

<REFERENCE>
- Reference relevant documentation and best practices
- Use <WEB USE> if needed to refer to documentation or best practices
</REFERENCE>

# TESTING (Always write TEST after IMPLEMENTATION) [ACT/Code MODE]
<TESTING>

<DEPENDENCY BASED TESTING>
Create unit tests for any new functionality. Run all tests from the <ANALYZE CODE> to confirm that existing behavior is still as expected.
</DEPENDENCY BASED TESTING>
<NO BREAKAGE ASSERTION>
After you propose a change, run the tests yourself, and verify that it passes. Do not rely on me to do this, and be certain that my code will not be broken.
</NO BREAKAGE ASSERTION>

1. Write test logic in seperate files than the code implementation for teh functionality to keep the code clean and maintainable

<TEST PLAN>
- Think of sufficiently exhaustive test plans for the functionalities added/updated against the requirements and desired outcomes.
- Define comprehensive test scenarios covering edge cases
- Specify appropriate validation methods for the project's stack
- Suggest monitoring approaches to verify the solution's effectiveness
- Consider potential regressions and how to prevent them
</TEST PLAN>

2. Write test code for ANY added critical functionality ALWAYS. For initial test generation use <DEPENDENCY BASED TESTING> and <NO BREAKAGE ASSERTION>. Then use <TEST PLAN> to write code for extensive testing.
3. Document testing as specified in @memory.mdc
</TESTING>

- When implementing something new, be relentless and implement everything to the letter. Stop only when you're done till successfully testing, not before.

---
After every code implementation/change ALWAYS do 2 things:
a. Update other possibly affected codes in `src` and other codes at other places.
b. Update the documentation in `docs/` and `tasks/`.
</file>

<file path=".cursor/rules/lessons-learned.mdc">
---
description: 
globs: lessons-learned.mdc
alwaysApply: false
---
# Memory Bank Rules: Lessons-learned.mdc

**File Purpose:** This file serves as a cumulative log of key insights, significant learnings, resolved misconceptions, and effective patterns discovered during the project lifecycle. It helps prevent repeating mistakes and reinforces successful approaches for all agents interacting with the project.

**Cursor's Responsibility:**

1.  **Identify Learnings:** During task execution or context review, actively identify situations where:
    *   An initial assumption or approach was incorrect and needed correction (e.g., misunderstanding routing, state management issues).
    *   A particularly effective solution or pattern was implemented.
    *   A subtle requirement or constraint was discovered or clarified.
    *   A significant refactoring occurred due to a previous design flaw.
2.  **Record Concisely:** After completing a task where a notable learning occurred, add a new entry to this file.
    *   Use a clear heading (e.g., date or related feature).
    *   Briefly describe the initial situation or misconception.
    *   Clearly state the resolution or the correct approach discovered.
    *   Summarize the key takeaway or "lesson learned" in a reusable format.
3.  **Categorize (Optional):** If the file grows large, consider adding categories (e.g., `# Backend`, `# Frontend`, `# Testing`, `# Architecture`).
4.  **Reference Context:** When applicable, briefly mention related memory bank files or specific tasks for deeper context, but keep the entry self-contained enough to convey the core lesson.
5.  **Review Regularly:** Briefly scan this file during the initial context review phase of a new task to benefit from past experiences.

**Format:**

*   Use Markdown for readability.
*   Use headings, bullet points, and code formatting where appropriate.
*   Prioritize clarity and conciseness.

**Example Entry:**

```markdown
## Component Replacement Strategy (Frontend - 2024-03-26)

*   **Misconception:** Attempted to add a new Dashboard component alongside the existing one during refactoring.
*   **Resolution:** Realized a complete replacement of the old implementation within `DashboardPage.jsx` was necessary for clarity and to avoid conflicting logic.
*   **Lesson Learned:** When replacing core functionality or components, prioritize a clean cutover rather than running old and new implementations in parallel. Ensure all references are updated. (See `activeContext.md` from that date for details).
</file>

<file path=".cursor/rules/logging-errors.mdc">
---
description: Logging errors, documenting errors, issue, fixes
globs: 
alwaysApply: false
---
# Error Logging Guidelines

Log errors in the docs/error-documentation.md file.

## 1. Use Appropriate Severity Levels
- **ERROR**: For unrecoverable failures or exceptions that need immediate attention.
- **WARN**: For unexpected states or recoverable issues that may need review.
- **INFO**: For high-level application flow events (e.g., startup, shutdown).
- **DEBUG**: For detailed diagnostic information during development.

## 2. Structured and Contextual Logging
- Log in a structured format (JSON or key-value) to enable searching and filtering.
- Include contextual metadata:
  - Request or correlation IDs
  - User or session identifiers (when available)
  - Function or module names
  - Timestamps (use ISO 8601 UTC)

## 3. Clear and Actionable Messages
- Write log messages that describe **what** happened and **why**, not just **where**.
- Include variable values and state that led to the error.
- Avoid generic messages like "An error occurred." Instead:
  ```js
  logger.error('Failed to fetch orders', { userId, orderCount, error });
  ```

## 4. Avoid Sensitive Data Leakage
- Do not log passwords, tokens, PII, or other sensitive data.
- Mask or omit any fields that contain sensitive information.

## 5. Centralize Logging Configuration
- Configure log levels, formats, and transports in a shared module or config file (e.g., `src/utils/logger.ts`).
- Use a consistent logger instance across the codebase.

## 6. Error Propagation
- Catch and log errors at the boundary (e.g., controllers, API routes), then rethrow or return appropriate responses.
- Avoid swallowing errors silently.

## 7. Monitoring and Alerts
- Integrate with external monitoring tools (e.g., Sentry, Datadog) for critical errors.
- Attach stack traces and breadcrumbs when reporting.

## 8. Testing and Validation
- Write unit tests to simulate error conditions and verify that logs are emitted at the right level with the correct message.

*Document last updated: YYYY-MM-DD*
</file>

<file path=".cursor/rules/memory.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: ALWAYS INCLUDE to HAVE Project Context.
globs: 
alwaysApply: true
---
# Memory Files Structure
This outlines the fundamental principles, required files, workflow structure, and essential procedures that govern documentation, and maintaining a memory using file system.
The Memory Files consists of required core files and optional context files. Files build upon each other in a clear hierarchy:
```mermaid
flowchart TD
    PB[ [product_requirement_docs.md](mdc:docs/product_requirement_docs.md) ] --> PC[ [technical.md](mdc:docs/technical.md) ]
    PB --> SP[ [architecture.md](mdc:docs/architecture.md) ]

    SP --> TC[ [tasks_plan.md](mdc:tasks/tasks_plan.md) ]
    PC --> TC
    PB --> TC
    
    TC --> AC[ [active_context.md](mdc:tasks/active_context.md) ]

    AC --> ER[ [error-documentation.mdc](mdc:.cursor/rules/error-documentation.mdc)]
    AC --> LL[ [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) ]
    
    subgraph LIT[ @docs/literature ]
        L1[...]
        L2[...]
    end
    
    subgraph RFC[ @tasks/rfc/ ]
        R1[...]
        R2[...]
    end
    
    PC --o LIT
    TC --o RFC

```
## Core Files (Required)
  7 files: 
  1. [product_requirement_docs.md](mdc:docs/product_requirement_docs.md) (docs/product_requirement_docs.md): Product Requirement Document (PRD) for the project or an SOP. 
  - Why this project exists
  - Problems it solves
  - Defines core requirements and goals
  - Foundation document that shapes all other files
  - Source of truth for project scope
  - Created at project start if it doesn't exist

  2. [architecture.md](mdc:docs/architecture.md) (docs/architecture.md): System architecture
  - How it should work
  - Component relationships
  - Dependencies
  - Work flow of the Solution
  - Mermaid diagram of solution overview: each component and code flow

  3. [technical.md](mdc:docs/technical.md) (docs/technical.md): Development environment and stack
  - Technologies used
  - Development setup
  - Key technical decisions
  - Design patterns in use
  - Technical constraints

  4. [tasks_plan.md](mdc:tasks/tasks_plan.md) (tasks/tasks_plan.md): Detailed Task backlog
  - In-Depth Tasks list and Project Progress
  - What works
  - What's left to build
  - Current status
  - Known issues
  
  5. [active_context.md](mdc:tasks/active_context.md) (tasks/active_context.md): Current state of development
  - Current work focus
  - Active decisions and considerations
  - Recent changes
  - Next steps

  6. [error-documentation.mdc](mdc:.cursor/rules/error-documentation.mdc) (.cursor/rules/error-documentation.mdc): 
  - During your interaction, if you find a fix to a mistake in this project or a correction you received reusable, you should take note in the @error-documentation.mdc file so you will not make the same mistake again.
  - Known issues: their state, context, and resolution

  7. [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) (.cursor/rules/lessons-learned.mdc): learning journal for each project
  - It captures important patterns, preferences, and project intelligence
  - It is detailed in @lessons-learned.mdc

## Context Files (Optional)
Detailed docs. Retrieve on demand if needed for context.

1. docs/literature/ :
  - literature survey and researches are in this directory  
  - Each literature topic is a latex file (docs/literature/*.tex)

2. tasks/rfc/ :
  - contains RFC for each individual task in @tasks_plan.md
  - RFCs will be in latex file format (tasks/*.tex)

## Additional Context
Create additional files or folders as Memory files in docs/ or tasks/ when they help organize:
- Integration specifications
- Testing strategies
- Benchmarking setups
- Possible Extensions
- Deployment procedures

# Core Workflows
Now we define the procedural workflows to read/write to these memeory files.
The system operates in distinct MODES: (PLAN/ACT) or analogously (Architect/Code), controlled exclusively by the user input or the task in current request. Current input will determine the MODE, based on which the Workflow selection is always dictated. In user input explicit mode setting can also be specified by "MODE = PLAN MODE"/"Architect MODE" or "MODE = ACT MODE"/"Code MODE", so if explicit MODE setting present follow that, else guess the mode from the request. Ask for the MODE if you are not 100% confident, if any doubt ask explicitely.

## PLAN or Architect MODE
```mermaid
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Files ("docs/": (a)"docs/architecture.md" (b)"docs/product_requirement_docs.md" (c)"docs/technical.md". "tasks/" : (a)"tasks/active_context.md" (b)"tasks/tasks_plan.md". if needed further: "docs/literature" and "tasks/rfc") ]
    ReadFiles --> CheckFiles{Files Complete?}
    
    CheckFiles -->|No| Plan[Create Plan]
    Plan --> DocumentChat[Document in Chat]
    
    CheckFiles -->|Yes| VerifyContext[Verify Context]
    VerifyContext --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]
    
    Present --> Verification{Approach Verified?}

    Verification -->|No| Clarify[Seek Clarification]
    Clarify --> Strategy[Develop Strategy]

    Verification -->|Yes| DocumentMemory[Document in Memory Files ("docs/": (a)"docs/architecture.md" (b)"docs/product_requirement_docs.md" (c)"docs/technical.md". "tasks/" : (a)"tasks/active_context.md" (b)"tasks/tasks_plan.md" if needed further: "docs/literature" and "tasks/rfc")]
```

## ACT or Code MODE
```mermaid
flowchart TD
    Start[Start] --> Context[Check Memory Files (Core Files always ("docs/": (a)"docs/architecture.md" (b)"docs/product_requirement_docs.md" (c)"docs/technical.md". "tasks/" : (a)"tasks/active_context.md" (b)"tasks/tasks_plan.md"), rest based on context (if needed further: "docs/literature" and "tasks/rfc")) ]
    Context --> Update[Update Documentation]
    Update --> Rules[Update [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc), [error-documentation.mdc](mdc:.cursor/rules/error-documentation.mdc) if needed]
    Rules --> Execute[Execute Task]
    Execute --> Document[Document Changes in Memory Files ("docs/": (a)"docs/architecture.md" (b)"docs/product_requirement_docs.md" (c)"docs/technical.md". "tasks/" : (a)"tasks/active_context.md" (b)"tasks/tasks_plan.md" if needed further: "docs/literature" and "tasks/rfc") ]
```

# Documentation Updates

Memory Files updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory files** (MUST review ALL Core Files)
4. When context needs clarification
5. After significant part of Plan is verified

```mermaid
flowchart TD
    Start[Update Process]
    
    subgraph Process
        P1[Review Core Files]
        P2[Document Current State in [active_context.md](mdc:tasks/active_context.md) and [tasks_plan.md](mdc:tasks/tasks_plan.md) ]
        P3[Clarify Next Steps and document in [tasks_plan.md](mdc:tasks/tasks_plan.md) ]
        P4[Update [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc), [error-documentation.mdc](mdc:.cursor/rules/error-documentation.mdc)]
        P5 Update [ [architecture.md](mdc:docs/architecture.md) ]
        
        P1 --> P2 --> P3 --> P4
    end
    
    Start --> Process
```

Note: When triggered by **update memory files**, I MUST review every Core memory file, even if some don't require updates. Focus particularly on [active_context.md](mdc:tasks/active_context.md) and [tasks_plan.md](mdc:tasks/tasks_plan.md) as they track current state. And [architecture.md](mdc:docs/architecture.md) has a section of current workflow that also gets updated by any code updates.

# Project Intelligence ( [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) [.cursor/rules/lessons-learned.mdc] )

The [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) file is my learning journal for each project. It captures important patterns, preferences, and project intelligence that help me work more effectively. As I work with you and the project, I'll discover and document key insights that aren't obvious from the code alone.

```mermaid
flowchart TD
    Start{Discover New Pattern}
    
    subgraph Learn [Learning Process]
        D1[Identify Pattern]
        D2[Validate with User]
        D3[Document in [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) ]
    end
    
    subgraph Apply [Usage]
        A1[Read [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) ]
        A2[Apply Learned Patterns]
        A3[Improve Future Work]
    end
    
    Start --> Learn
    Learn --> Apply
```

## What to Capture
- Critical implementation paths
- User preferences and workflow
- Project-specific patterns
- Known challenges
- Evolution of project decisions
- Tool usage patterns

The format is flexible - focus on capturing valuable insights that help me work more effectively with you and the project. Think of [lessons-learned.mdc](mdc:.cursor/rules/lessons-learned.mdc) as a living document that grows smarter as we work together.
</file>

<file path=".cursor/rules/plan.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
Before every Plan/Architect task ALWAYS do 3 things:
a. Read the existing documentation in `docs/` : i. `docs/architecture.md`, ii. `docs/product_requirement_docs.md`, iii. `docs/technical.md`
b. Read the plans and related task planning & context in `tasks/`: i. `tasks/active_context.md`, ii. `tasks/tasks_plan.md`
c. Get required solution conytext from the code files in `src` and other codes at other places.
---
- Below is the Planning Workflow to follow:

1. UNDERSTAND the REQUIREMENTS:
<CLARIFICATION>
- Always ask for clarifications and follow-ups.
- Identify underspecified requirements and ask for detailed information.
- Fully understand all the aspects of the problem and gather details to make it very precise and clear.
- Ask towards all the hypothesis and assumptions needed to be made. Remove all the ambiguities and uncertainties.
- Suggest solutions that I didn't think about, i.e. anticipate my needs and things to be specified.
- Only after having hundred percent clarity and confidence, proceed for SOLUTION.
</CLARIFICATION>

2. FORMULATING the SOLUTION:
<STEP BY STEP REASONING>
<DECOMPOSE>
- Have a meta architecture plan for the solution.
- Break down the problem into key concepts and smaller sub-problems.
</DECOMPOSE>
a. Think about all possible ways to solve the problem.
b. Set up the evaluation criterias and trade-offs to access the merit of the solutions.
c. Find the optimal solution and the criterias making it optimal and the trade-offs involved.
<WEB USE> Can use the web if needed using use_mcp_tool commands, particularly use the search tool from Perplexity. Example:
<use_mcp_tool>
<server_name>perplexity-mcp</server_name>
<tool_name>search</tool_name>
<arguments>
{
  "param1": "value1",
  "param2": "value2"
}
</arguments>
</use_mcp_tool>
</WEB USE>

<MULTI ATTEMPTS>
a. Reason out rigorously about the optimality of the solution.
b. Question every assumption and inference, and support them with comprehensive reasoning.
c. Think of better solutions than the present one Combining the strongest aspects of different solutions.
d. Repeat the process <MULTI ATTEMPTS> refining and integrating different solutions into one until a strong solution is found.
d. Can use <WEB USE> if needed to do research.
</MULTI ATTEMPTS>
</STEP BY STEP REASONING>

3. SOLUTION VALIDATION:

<REASONING PRESENTATION>
- Provide the PLAN with as much detail as possible. 
- Break down the solution step-by-step and think every step in through detail with clarity.
- Reason out its optimality w.r.t. other promising solutions.
- Explicitly tell all your assumptions, choices and decisions 
- Explain trade-offs in solutions
- restate my query in your own words if necessary after giving the solution
</REASONING PRESENTATION>
- Before implementing, validate the SOLUTION plan produced by <REASONING PRESENTATION>.

---

After every Plan/Architect task ALWAYS do 2 things:
a. Document the plan into existing documentation and update files in `docs/` : i. `docs/architecture.md`, ii. `docs/product_requirement_docs.md`, iii. `docs/technical.md`
b. Document the plans and related task planning & context in `tasks/`: i. `tasks/active_context.md`, ii. `tasks/tasks_plan.md`
</file>

<file path=".cursor/rules/python.mdc">
---
description: 
globs: **/*.py,src/**/*.py,tests/**/*.py
alwaysApply: false
---
---
description: Python best practices and patterns for modern software development with Flask and SQLite
globs: **/*.py, src/**/*.py, tests/**/*.py
---

# Python Best Practices

## Project Structure
- Use src-layout with `src/your_package_name/`
- Place tests in `tests/` directory parallel to `src/`
- Keep configuration in `config/` or as environment variables
- Store requirements in `requirements.txt` or `pyproject.toml`
- Place static files in `static/` directory
- Use `templates/` for Jinja2 templates

## Code Style
- Follow Black code formatting
- Use isort for import sorting
- Follow PEP 8 naming conventions:
  - snake_case for functions and variables
  - PascalCase for classes
  - UPPER_CASE for constants
- Maximum line length of 88 characters (Black default)
- Use absolute imports over relative imports

## Type Hints
- Use type hints for all function parameters and returns
- Import types from `typing` module
- Use `Optional[Type]` instead of `Type | None`
- Use `TypeVar` for generic types
- Define custom types in `types.py`
- Use `Protocol` for duck typing

## Flask Structure
- Use Flask factory pattern
- Organize routes using Blueprints
- Use Flask-SQLAlchemy for database
- Implement proper error handlers
- Use Flask-Login for authentication
- Structure views with proper separation of concerns

## Database
- Use SQLAlchemy ORM
- Implement database migrations with Alembic
- Use proper connection pooling
- Define models in separate modules
- Implement proper relationships
- Use proper indexing strategies

## Authentication
- Use Flask-Login for session management
- Implement Google OAuth using Flask-OAuth
- Hash passwords with bcrypt
- Use proper session security
- Implement CSRF protection
- Use proper role-based access control

## API Design
- Use Flask-RESTful for REST APIs
- Implement proper request validation
- Use proper HTTP status codes
- Handle errors consistently
- Use proper response formats
- Implement proper rate limiting

## Testing
- Use pytest for testing
- Write tests for all routes
- Use pytest-cov for coverage
- Implement proper fixtures
- Use proper mocking with pytest-mock
- Test all error scenarios

## Security
- Use HTTPS in production
- Implement proper CORS
- Sanitize all user inputs
- Use proper session configuration
- Implement proper logging
- Follow OWASP guidelines

## Performance
- Use proper caching with Flask-Caching
- Implement database query optimization
- Use proper connection pooling
- Implement proper pagination
- Use background tasks for heavy operations
- Monitor application performance

## Error Handling
- Create custom exception classes
- Use proper try-except blocks
- Implement proper logging
- Return proper error responses
- Handle edge cases properly
- Use proper error messages

## Documentation
- Use Google-style docstrings
- Document all public APIs
- Keep README.md updated
- Use proper inline comments
- Generate API documentation
- Document environment setup

## Development Workflow
- Use virtual environments (venv)
- Implement pre-commit hooks
- Use proper Git workflow
- Follow semantic versioning
- Use proper CI/CD practices
- Implement proper logging

## Dependencies
- Pin dependency versions
- Use requirements.txt for production
- Separate dev dependencies
- Use proper package versions
- Regularly update dependencies
- Check for security vulnerabilities
</file>

<file path=".cursor/rules/react.mdc">
---
description: 
globs: **/*.tsx,**/*.jsx,components/**/*
alwaysApply: false
---
---
description: React best practices and patterns for modern web applications
globs: **/*.tsx, **/*.jsx, components/**/*
---

# React Best Practices

## Component Structure
- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Implement proper prop types with TypeScript
- Split large components into smaller, focused ones

## Hooks
- Follow the Rules of Hooks
- Use custom hooks for reusable logic
- Keep hooks focused and simple
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks

## State Management
- Use useState for local component state
- Implement useReducer for complex state logic
- Use Context API for shared state
- Keep state as close to where it's used as possible
- Avoid prop drilling through proper state management
- Use state management libraries only when necessary

## Performance
- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Forms
- Use controlled components for form inputs
- Implement proper form validation
- Handle form submission states properly
- Show appropriate loading and error states
- Use form libraries for complex forms
- Implement proper accessibility for forms

## Error Handling
- Implement Error Boundaries
- Handle async errors properly
- Show user-friendly error messages
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Testing
- Write unit tests for components
- Implement integration tests for complex flows
- Use React Testing Library
- Test user interactions
- Test error scenarios
- Implement proper mock data

## Accessibility
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Test with screen readers
- Handle focus management
- Provide proper alt text for images

## Code Organization
- Group related components together
- Use proper file naming conventions
- Implement proper directory structure
- Keep styles close to components
- Use proper imports/exports
- Document complex component logic
</file>

<file path=".cursor/rules/tailwind.mdc">
---
description: 
globs: **/*.css,**/*.tsx,**/*.jsx,tailwind.config.js,tailwind.config.ts
alwaysApply: false
---
---
description: Tailwind CSS and UI component best practices for modern web applications
globs: **/*.css, **/*.tsx, **/*.jsx, tailwind.config.js, tailwind.config.ts
---

# Tailwind CSS Best Practices

## Project Setup
- Use proper Tailwind configuration
- Configure theme extension properly
- Set up proper purge configuration
- Use proper plugin integration
- Configure custom spacing and breakpoints
- Set up proper color palette

## Component Styling
- Use utility classes over custom CSS
- Group related utilities with @apply when needed
- Use proper responsive design utilities
- Implement dark mode properly
- Use proper state variants
- Keep component styles consistent

## Layout
- Use Flexbox and Grid utilities effectively
- Implement proper spacing system
- Use container queries when needed
- Implement proper responsive breakpoints
- Use proper padding and margin utilities
- Implement proper alignment utilities

## Typography
- Use proper font size utilities
- Implement proper line height
- Use proper font weight utilities
- Configure custom fonts properly
- Use proper text alignment
- Implement proper text decoration

## Colors
- Use semantic color naming
- Implement proper color contrast
- Use opacity utilities effectively
- Configure custom colors properly
- Use proper gradient utilities
- Implement proper hover states

## Components
- Use shadcn/ui components when available
- Extend components properly
- Keep component variants consistent
- Implement proper animations
- Use proper transition utilities
- Keep accessibility in mind

## Responsive Design
- Use mobile-first approach
- Implement proper breakpoints
- Use container queries effectively
- Handle different screen sizes properly
- Implement proper responsive typography
- Use proper responsive spacing

## Performance
- Use proper purge configuration
- Minimize custom CSS
- Use proper caching strategies
- Implement proper code splitting
- Optimize for production
- Monitor bundle size

## Best Practices
- Follow naming conventions
- Keep styles organized
- Use proper documentation
- Implement proper testing
- Follow accessibility guidelines
- Use proper version control
</file>

<file path="docs/lessons-learned.md">
# Lessons Learned

## Frontend Development

### Component Design
- Break down complex UIs into reusable components (e.g., RoleTable, RoleForm, RolePermissionManager)
- Use consistent patterns for forms, tables, and modals across the application
- Implement proper prop types and default props for component reliability

### State Management
- Keep state close to where it's used (page-level state for CRUD operations)
- Use loading and error states consistently across components
- Clear state and error messages when closing modals or changing views

### API Integration
- Create dedicated service classes for API endpoints
- Group related API calls in service classes (e.g., RoleService for all role-related operations)
- Handle errors consistently across all API calls

### UI/UX Patterns
- Use consistent button placement and styling for actions
- Implement clear feedback for loading and error states
- Provide confirmation dialogs for destructive actions
- Use modals for focused tasks (create/edit/manage permissions)

### Navigation
- Organize admin features in both sidebar and tab navigation
- Use consistent icons and labels across navigation elements
- Maintain visual hierarchy in navigation components

## PBAC Implementation
- Separate role management from permission management
- Use clear, descriptive names for permissions
- Implement granular permission assignment UI
- Consider UX for managing many permissions

## Error Handling
- Provide specific error messages for different failure cases
- Clear error states when retrying operations
- Show loading states during async operations
- Handle edge cases in permission management

## Testing Considerations
- Test CRUD operations for roles
- Verify permission assignment/removal
- Test error handling and loading states
- Validate form validation and submission
- Check modal behavior and state management

## Implementation Patterns

### PBAC Migration Best Practices
- Migration script (05eadf8716a5) demonstrates good practices for complex data migrations:
  - Clear separation of concerns (permissions, roles, user migration)
  - Proper order of operations (create new structures before migrating data)
  - Edge case handling (null values)
  - Use of SQLAlchemy session for complex operations
  - Atomic operations within transactions
  - Clear mapping dictionaries for data transformation
  - Proper cleanup in downgrade path
</file>

<file path="docs/lessons-learned.mdc">
---
description:
globs:
alwaysApply: false
---
</file>

<file path="fbo-launchpad-backend/docs/architecture.md">
# System Patterns

## Architectural Overview

### 1. Application Structure
```
Flask Application
├── Application Factory
├── Blueprints (Feature Modules)
├── Services (Business Logic)
└── Models (Data Layer)
```

### 2. Request Flow
```
Request → JWT Auth → Role Check → Route Handler → Service → Database
```

## Core Patterns

### 1. Authentication Pattern
```python
# Decorator Chain
@token_required
@require_role(Role1, Role2)
def endpoint():
    pass
```

- JWT token validation
- Role verification
- User status check
- Current user in g.current_user

### 2. Service Pattern
```python
class BaseService:
    def __init__(self, model):
        self.model = model

class UserService(BaseService):
    def get_users(self, filters=None):
        query = self.model.query
        if filters:
            query = self.apply_filters(query, filters)
        return query.paginate()
```

### 3. Response Pattern
```python
{
    "data": [/* items */],
    "pagination": {
        "page": 1,
        "per_page": 20,
        "total": 100
    },
    "error": null
}
```

### 4. Error Handling Pattern
```python
class APIError(Exception):
    def __init__(self, message, status_code):
        self.message = message
        self.status_code = status_code

@app.errorhandler(APIError)
def handle_api_error(error):
    return jsonify({
        "error": error.message
    }), error.status_code
```

## Database Patterns

### 1. Model Definition
```python
class BaseModel(db.Model):
    __abstract__ = True
    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
```

### 2. Relationship Patterns
- One-to-Many: User → FuelOrders
- Many-to-One: FuelOrder → Customer
- Many-to-Many: Aircraft ↔ Customers

### 3. Query Patterns
```python
# Base query with joins
query = Model.query.join(Related)

# Filter chain
query = (query
    .filter(Model.field == value)
    .order_by(Model.created_at)
    .paginate())
```

## API Patterns

### 1. URL Structure
```
/api/<resource>/                 # Collection
/api/<resource>/<id>/           # Instance
/api/<resource>/<id>/<action>   # Action
```

### 2. HTTP Methods
- GET: Retrieve
- POST: Create
- PUT: Update (Full)
- PATCH: Update (Partial)
- DELETE: Remove

### 3. Query Parameters
```
?page=1              # Pagination
?per_page=20         # Items per page
?sort=field          # Sorting
?filter[key]=value   # Filtering
```

## Security Patterns

### 1. Permission-Based Access Control (PBAC)
```python
# Permission Check Method
class User(BaseModel):
    roles = db.relationship('Role', secondary='user_roles')

    def has_permission(self, permission_name):
        return any(
            permission.name == permission_name
            for role in self.roles
            for permission in role.permissions
        )

# Permission Decorator
@require_permission('PERMISSION_NAME')
def protected_endpoint():
    pass
```

### 2. Password Handling
```python
class User(BaseModel):
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
```

### 3. Token Pattern
```python
{
    "sub": user_id,
    "exp": expiration_time
}
```

## User Management Patterns

### 1. User Status Management
```python
class User(BaseModel):
    is_active = db.Column(db.Boolean, nullable=False, default=True)
    roles = db.relationship('Role', secondary='user_roles')
    
    def deactivate(self):
        self.is_active = False
        
    def activate(self):
        self.is_active = True
```

### 2. User Creation Pattern
```python
@require_permission('MANAGE_USERS')
def create_user():
    # Validate role IDs exist
    roles = Role.query.filter(Role.id.in_(data['role_ids'])).all()
    if len(roles) != len(data['role_ids']):
        raise ValueError("Invalid role IDs provided")
        
    user = User(
        email=data['email'],
        username=data.get('name', data['email'].split('@')[0]),
        is_active=data.get('is_active', True)
    )
    user.set_password(data['password'])
    user.roles = roles
```

### 3. User Status Check Pattern
```python
def authenticate_user(email, password):
    user = User.query.options(db.selectinload(User.roles)).filter_by(email=email).first()
    if not user or not user.is_active:
        raise ValueError("Invalid credentials or inactive account")
    if not user.check_password(password):
        raise ValueError("Invalid credentials")
    return user
```

### 4. User Management Endpoints
```
# Admin User Management API
GET    /api/admin/users/        # List users (VIEW_USERS)
POST   /api/admin/users/        # Create user (MANAGE_USERS)
GET    /api/admin/users/<id>/   # Get user details (VIEW_USERS)
PATCH  /api/admin/users/<id>/   # Update user (MANAGE_USERS)
DELETE /api/admin/users/<id>/   # Soft delete user (MANAGE_USERS)

# Role Management API
GET    /api/admin/roles/        # List roles (VIEW_ROLES)
POST   /api/admin/roles/        # Create role (MANAGE_ROLES)
PATCH  /api/admin/roles/<id>/   # Update role (MANAGE_ROLES)
DELETE /api/admin/roles/<id>/   # Delete role (MANAGE_ROLES)

# Permission Management API
GET    /api/admin/permissions/  # List permissions (VIEW_PERMISSIONS)
```

## Testing Patterns

### 1. Fixture Pattern
```python
@pytest.fixture
def test_user():
    user = User(
        email="test@example.com",
        role=UserRole.CSR
    )
    user.set_password("password")
    return user
```

### 2. Test Structure
```python
def test_endpoint(client, auth_headers):
    response = client.get(
        "/api/resource",
        headers=auth_headers
    )
    assert response.status_code == 200
```

### 3. Mock Pattern
```python
@patch("service.external_api")
def test_with_mock(mock_api):
    mock_api.return_value = {"data": "test"}
    # Test implementation
```

## Documentation Patterns

### 1. OpenAPI Documentation
```python
"""
---
get:
  summary: Endpoint description
  parameters:
    - name: param
      in: query
      type: string
  responses:
    200:
      description: Success
"""
```

### 2. Code Documentation
```python
def function(param):
    """Short description.

    Detailed description.

    Args:
        param: Parameter description

    Returns:
        Return value description

    Raises:
        ErrorType: Error description
    """
```
</file>

<file path="fbo-launchpad-backend/docs/error-documentation.md">
# Error Documentation

This document records the major failure points encountered in the FBO LaunchPad project and how they were resolved.

## 1. PostCSS Plugin Loading Failure
**Symptoms:**
- Build-time error in Vite: `Failed to load PostCSS config: Cannot find module '@tailwindcss/postcss'`.

**Cause:**
- Incorrect plugin key in `postcss.config.cjs` (`'@tailwindcss/postcss'` instead of `'tailwindcss'`).

**Resolution:**
1. Updated `postcss.config.cjs` to:
   ```js
   module.exports = {
     plugins: {
       'postcss-nesting': {},
       'tailwindcss': {},
       autoprefixer: {},
     }
   }
   ```
2. Installed missing dependencies:
   ```bash
   npm install -D tailwindcss postcss autoprefixer postcss-nesting
   ```

---

## 2. `process is not defined` in Vite
**Symptoms:**
- Runtime error in console: `ReferenceError: process is not defined` in `useOrders.ts`.

**Cause:**
- Frontend code was accessing `process.env` directly in a Vite project.

**Resolution:**
1. Switched to Vite-specific environment access:
   ```ts
   const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;
   ```
2. Added `src/vite-env.d.ts` for TypeScript definitions:
   ```ts
   /// <reference types="vite/client" />
   interface ImportMetaEnv {
     readonly VITE_API_BASE_URL: string;
   }
   interface ImportMeta { readonly env: ImportMetaEnv }
   ```
3. Created `.env` in the frontend root with:
   ```env
   VITE_API_BASE_URL=http://localhost:5000/api
   ```

---

## 3. Network Error Fetching Orders
**Symptoms:**
- Frontend error: `Error Loading orders: Network Error` when calling `/orders` endpoint.

**Causes & Resolutions:**
- **Backend not running:** Started Flask server:
  ```bash
  cd fbo-launchpad-backend
  flask run --port 5001
  ```
- **Port mismatch:** Updated frontend environment or backend run port to match (e.g., `5001`).
- **Authentication missing:** Ensured login flow stores JWT in `localStorage` under `token` and included in request headers.

---

## 4. Other Common Issues
- **CORS Errors:** If present, configure Flask-CORS in the backend:
  ```py
  from flask_cors import CORS
  app = Flask(__name__)
  CORS(app, resources={r"/api/*": {"origins": "*"}})
  ```
- **Invalid JSON Responses:** Ensure backend API returns valid JSON with `data` field.

---

## 5. Alembic Migration Ordering and Session/Table Definition Issues (PBAC Phase 1)
**Symptoms:**
- Migration failed with `psycopg2.errors.UndefinedColumn: column users.role does not exist`.
- Migration failed with `UnboundLocalError: local variable 'session' referenced before assignment` and `UnboundLocalError: local variable 'roles_table_id' referenced before assignment`.

**Causes:**
- Attempted to read from `users.role` after dropping the column in the same migration script.
- Referenced session and table objects before they were defined due to reordering of migration steps.

**Resolution:**
1. Reordered migration logic to perform all data migration from `users.role` before dropping the column.
2. Moved session and table object definitions to before any use in the migration function.
3. Confirmed migration runs successfully and all data is migrated as intended.

---

## Authentication System Issues

### Circular Import Resolution
**Issue**: Circular imports between user, role, and permission models.
**Solution**: Use relative imports and move relationship tables to separate modules.
```python
# Before (problematic):
from src.models.user import User
from src.models.role import Role

# After (fixed):
from ..models.role_permission import role_permissions
```

### Rate Limiting in Tests
**Issue**: Rate limiting interfering with tests.
**Solution**: 
1. Added `reset_rate_limits()` function
2. Created autouse fixture to reset between tests
```python
@pytest.fixture(autouse=True)
def reset_rate_limiting():
    reset_rate_limits()
    yield
```

### Permission Cache Issues
**Issue**: Permission cache not properly invalidating between requests.
**Solution**:
1. Made cache request-scoped using Flask's `g` object
2. Added proper cache key format
3. Implemented automatic invalidation between requests
```python
cache_key = f'user_{self.id}_perm_{permission_name}'
if has_request_context():
    if not hasattr(g, '_permission_cache'):
        g._permission_cache = {}
```

### Role Assignment
**Issue**: Role assignment not working properly during registration.
**Solution**: 
1. Fixed role relationship in User model
2. Properly queried default role before assignment
3. Used list assignment for roles
```python
default_role = Role.query.filter_by(name='Customer Service Representative').first()
user.roles = [default_role]
```

### Missing Field Validation
**Issue**: Register endpoint not properly validating all required fields.
**Solution**: Added proper validation using Marshmallow schemas
```python
class RegisterRequestSchema(Schema):
    email = fields.Email(required=True)
    password = fields.String(required=True, validate=validate.Length(min=8))
    name = fields.String(required=False)
```

---

*Document last updated: YYYY-MM-DD*
</file>

<file path="fbo-launchpad-backend/docs/frontend_integration_guide.md">
# FBO LaunchPad Frontend Integration Guide

## Overview

FBO LaunchPad is a comprehensive Fixed Base Operator (FBO) management system designed to streamline aircraft fueling operations. The backend API provides a robust set of endpoints to support the digital fuel order workflow, focusing on the interaction between Customer Service Representatives (CSRs), Line Service Technicians (LSTs), and system administrators.

This guide details how to integrate a frontend application with the FBO LaunchPad backend API, specifically focusing on the CSR MVP functionality.

## API Base URL

The base URL for all API calls should be configured through environment variables in your frontend application:

```javascript
// Example using Vite environment variables
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api';
```

For local development, the default URL is: `http://localhost:5001/api`

## Authentication Flow

### Login Process

**Endpoint:** `POST /api/auth/login`

**Request:**
```json
{
    "email": "user@example.com",
    "password": "userpassword"
}
```

**Success Response (200 OK):**
```json
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
        "id": 1,
        "email": "user@example.com",
        "role": "CSR",
        "is_active": true
    }
}
```

**Error Response (401 Unauthorized):**
```json
{
    "error": "Invalid credentials"
}
```

### Using the JWT Token

After successful login, the JWT token must be included in all subsequent API requests:

```javascript
headers: {
    'Authorization': `Bearer ${access_token}`,
    'Content-Type': 'application/json'
}
```

**Note:** The JWT token expires after 1 hour. Users must re-login to obtain a new token as token refresh is not implemented in the MVP.

## Required CSR Endpoints

### 1. Get Active LSTs

**Purpose:** Retrieve a list of active Line Service Technicians for fuel order assignment.

**Endpoint:** `GET /api/users?role=LST&is_active=true`

**Headers:**
- `Authorization: Bearer <token>`

**Success Response (200 OK):**
```json
{
    "message": "Users retrieved successfully",
    "users": [
        {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com",
            "role": "LST",
            "is_active": true
        }
    ]
}
```

### 2. Get Active Fuel Trucks

**Purpose:** Retrieve a list of active fuel trucks for fuel order creation.

**Endpoint:** `GET /api/fuel-trucks?is_active=true`

**Headers:**
- `Authorization: Bearer <token>`

**Success Response (200 OK):**
```json
{
    "message": "Fuel trucks retrieved successfully",
    "fuel_trucks": [
        {
            "id": 1,
            "truck_number": "TRUCK001",
            "fuel_type": "Jet A",
            "capacity": "5000.00",
            "current_meter_reading": "1234.56",
            "is_active": true
        }
    ]
}
```

### 3. Create Fuel Order

**Purpose:** Create a new fuel order.

**Endpoint:** `POST /api/fuel-orders`

**Headers:**
- `Authorization: Bearer <token>`
- `Content-Type: application/json`

**Request Body:**
```json
{
    "aircraft_id": 1,
    "customer_id": 1,
    "fuel_type": "Jet A",
    "quantity": "1000.00",
    "assigned_lst_id": 1,
    "assigned_truck_id": 1,
    "notes": "Optional notes about the order"
}
```

**Success Response (201 Created):**
```json
{
    "message": "Fuel order created successfully",
    "fuel_order": {
        "id": 1,
        "status": "PENDING",
        "aircraft_id": 1,
        "customer_id": 1,
        "fuel_type": "Jet A",
        "quantity": "1000.00",
        "assigned_lst_id": 1,
        "assigned_truck_id": 1,
        "notes": "Optional notes about the order",
        "created_at": "2024-03-26T10:00:00Z"
    }
}
```

### 4. List Fuel Orders

**Purpose:** Retrieve a paginated list of fuel orders with optional filters.

**Endpoint:** `GET /api/fuel-orders`

**Headers:**
- `Authorization: Bearer <token>`

**Query Parameters:**
- `page` (optional, default: 1): Page number
- `per_page` (optional, default: 20): Items per page
- `status` (optional): Filter by order status (PENDING, IN_PROGRESS, COMPLETED, etc.)

**Success Response (200 OK):**
```json
{
    "message": "Fuel orders retrieved successfully",
    "fuel_orders": [
        {
            "id": 1,
            "status": "PENDING",
            "aircraft_id": 1,
            "customer_id": 1,
            "fuel_type": "Jet A",
            "quantity": "1000.00",
            "assigned_lst_id": 1,
            "assigned_truck_id": 1,
            "notes": "Optional notes about the order",
            "created_at": "2024-03-26T10:00:00Z"
        }
    ],
    "pagination": {
        "page": 1,
        "per_page": 20,
        "total": 50
    }
}
```

### 5. Get Single Fuel Order

**Purpose:** Retrieve detailed information about a specific fuel order.

**Endpoint:** `GET /api/fuel-orders/{order_id}`

**Headers:**
- `Authorization: Bearer <token>`

**Success Response (200 OK):**
```json
{
    "message": "Fuel order retrieved successfully",
    "fuel_order": {
        "id": 1,
        "status": "PENDING",
        "aircraft_id": 1,
        "customer_id": 1,
        "fuel_type": "Jet A",
        "quantity": "1000.00",
        "assigned_lst_id": 1,
        "assigned_truck_id": 1,
        "notes": "Optional notes about the order",
        "created_at": "2024-03-26T10:00:00Z",
        "updated_at": "2024-03-26T10:00:00Z",
        "aircraft": {
            "id": 1,
            "tail_number": "N12345",
            "aircraft_type": "Boeing 737"
        },
        "customer": {
            "id": 1,
            "name": "Example Airlines",
            "email": "contact@example.com"
        },
        "assigned_lst": {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com"
        }
    }
}
```

### 6. Mark Order as Reviewed

**Purpose:** Mark a completed fuel order as reviewed by CSR.

**Endpoint:** `PATCH /api/fuel-orders/{order_id}/review`

**Headers:**
- `Authorization: Bearer <token>`
- `Content-Type: application/json`

**Request Body:**
```json
{
    "review_notes": "Optional review notes"
}
```

**Success Response (200 OK):**
```json
{
    "message": "Fuel order reviewed successfully",
    "fuel_order": {
        "id": 1,
        "status": "REVIEWED",
        "review_notes": "Optional review notes",
        "reviewed_at": "2024-03-26T11:00:00Z"
    }
}
```

### 7. Export Orders to CSV

**Purpose:** Export fuel orders to CSV format.

**Endpoint:** `GET /api/fuel-orders/export`

**Headers:**
- `Authorization: Bearer <token>`

**Query Parameters:**
- `start_date` (optional): Filter orders from this date (YYYY-MM-DD)
- `end_date` (optional): Filter orders until this date (YYYY-MM-DD)
- `status` (optional): Filter by order status

**Success Response:**
- Content-Type: text/csv
- File download with fuel order data

## Core Data Models

### FuelOrder
```typescript
interface FuelOrder {
    id: number;
    status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'REVIEWED';
    aircraft_id: number;
    customer_id: number;
    fuel_type: string;
    quantity: string;  // Decimal as string
    assigned_lst_id: number;
    assigned_truck_id: number;
    notes?: string;
    created_at: string;  // ISO datetime
    updated_at: string;  // ISO datetime
    reviewed_at?: string;  // ISO datetime
    review_notes?: string;
}
```

### User (LST)
```typescript
interface User {
    id: number;
    name: string;
    email: string;
    role: 'LST';
    is_active: boolean;
}
```

### FuelTruck
```typescript
interface FuelTruck {
    id: number;
    truck_number: string;
    fuel_type: string;
    capacity: string;  // Decimal as string
    current_meter_reading: string;  // Decimal as string
    is_active: boolean;
}
```

## Error Handling

All endpoints follow a consistent error response format:

```json
{
    "error": "Human-readable error message"
}
```

Common HTTP Status Codes:
- 400: Bad Request (invalid input)
- 401: Unauthorized (invalid/missing token)
- 403: Forbidden (insufficient permissions)
- 404: Not Found
- 409: Conflict (e.g., duplicate data)
- 500: Internal Server Error

## Implementation Tips

1. Always include error handling for both network errors and API errors
2. Implement token expiration handling and redirect to login
3. Use proper decimal handling for fuel quantities (strings to avoid floating-point issues)
4. Implement proper date/time handling for ISO 8601 timestamps
5. Consider implementing a request interceptor for token management
6. Use proper type definitions for API responses
7. Implement proper loading states for async operations
</file>

<file path="fbo-launchpad-backend/docs/fuel_order_queue_api.md">
# Fuel Order Queue API Documentation

## Overview
Implements endpoints for the LST queue system, allowing LSTs to view and claim unassigned fuel orders.

## Endpoints

### 1. `GET /api/orders/unassigned`
- **Auth:** JWT required (LST role recommended)
- **Returns:** List of all unassigned fuel orders (where `assigned_lst_user_id` is null), ordered by `created_at` ascending.
- **Response Example:**
```json
{
  "orders": [
    {
      "id": 123,
      "tail_number": "N12345",
      "requested_amount": 250.0,
      "location_on_ramp": "Ramp A",
      "created_at": "2025-04-26T01:00:00Z",
      "fuel_type": "Jet A",
      "csr_notes": "Priority customer",
      "status": "Dispatched"
    },
    ...
  ]
}
```

### 2. `POST /api/orders/<order_id>/accept`
- **Auth:** JWT required (LST role enforced)
- **Purpose:** Allows an LST to claim an unassigned order. Only works if order is unassigned; atomic operation.
- **Request Body:** _None_
- **Response Example:**
```json
{
  "success": true,
  "order_id": 123,
  "assigned_lst_user_id": 42
}
```
- **Failure Responses:**
  - `403 Unauthorized` if not LST
  - `404 Not found` if order does not exist
  - `409 Conflict` if order already assigned

## Logic
- Orders are considered unassigned if `assigned_lst_user_id` is null.
- LSTs see a queue of all such orders and can claim one by sending a POST to `/accept`.
- On claim, the order is atomically assigned to the LST and status is updated to `ACKNOWLEDGED`.

## Related Files
- `src/routes/fuel_order_queue_routes.py`
- `src/models/fuel_order.py`

---

## Change History
- 2025-04-26: Initial implementation for LST queue system.
</file>

<file path="fbo-launchpad-backend/docs/fuel_order_routes_api_docs.md">
# Fuel Order Routes API Documentation

## Overview
This documentation covers the API endpoints implemented in `src/routes/fuel_order_routes.py` for handling fuel order operations in the backend. It includes route details, authentication, and special logic such as auto-assigning LST users.

---

## Endpoints

### 1. `GET /fuel-orders/stats/status-counts`
- **Purpose:** Get counts of fuel orders by status groups (Pending, In Progress, Completed).
- **Auth:** Requires CSR, ADMIN, or LST role (JWT-protected).
- **Responses:**
  - 200: Success, returns status counts.
  - 401/403/500: Error cases with descriptive messages.

### 2. `POST /fuel-orders/`
- **Purpose:** Create a new fuel order.
- **Auth:** Requires CSR, ADMIN, or LST role (JWT-protected).
- **Request Body:**
  - Required: `tail_number`, `fuel_type`, `assigned_lst_user_id`, `assigned_truck_id`, `requested_amount`, `location_on_ramp`
  - Optional: `customer_id`, `additive_requested`, `csr_notes`
- **Special Logic:**
  - If `assigned_lst_user_id` is set to `-1`, the backend will automatically select and assign the least busy active LST user using the following logic:
    - Queries all active LST users.
    - Counts their active/in-progress orders (`DISPATCHED`, `ACKNOWLEDGED`, `EN_ROUTE`, `FUELING`).
    - Assigns the LST with the fewest such orders.
    - Logs the auto-assignment for traceability.
  - If no LST is available, returns an error.
- **Responses:**
  - 201: Success, returns created fuel order.
  - 400/500: Error cases with descriptive messages.

---

## Special Constants
- `AUTO_ASSIGN_LST_ID = -1`: If this value is provided in the payload as `assigned_lst_user_id`, the backend will auto-select the least busy LST.

---

## Security
- All endpoints require JWT authentication.
- Role-based access enforced via decorators.

---

## Logging
- Each major step in the fuel order creation process is logged for debugging and auditing.
- Auto-assignment actions are specifically logged (assigned user and order count).

---

## Usage Notes
- The frontend should send `assigned_lst_user_id: -1` to enable backend auto-assignment of LST.
- All other validation and assignment logic remains unchanged.

---

# End of Documentation
</file>

<file path="fbo-launchpad-backend/docs/lessons-learned.md">
PBAC Migration Lessons (2025-05-02):
- When seeding roles and permissions in Alembic, always insert roles after permissions, then use a session to fetch IDs for mapping in association tables (role_permissions).
- Use op.bulk_insert for initial data, but fetch IDs with a session for correct mapping.
- Ensure downgrade reverses all seeded data in the correct order (role_permissions, then roles, then permissions).
- (2025-05-03) Always migrate user role assignments to the new user_roles table before dropping the old users.role column. Ensure downgrade deletes all user_roles links for reversibility and data integrity.
- (2025-05-04) When reordering Alembic migration steps, always perform all data migration logic that depends on old columns before dropping those columns. Define all session and table objects before use in any migration step to avoid UnboundLocalError or similar issues.
- (2025-05-05) Encapsulating permission-checking logic as a method on the User model (has_permission) keeps authorization logic close to the data and improves code readability and maintainability. Using SQLAlchemy's dynamic relationships and filter_by for permission checks is efficient and leverages the ORM's ability to generate optimized SQL EXISTS queries. This pattern is recommended for future PBAC or RBAC implementations.
- (2025-05-06) When implementing permission-based decorators, always check for authentication context (g.current_user) before permission checks, and return clear error codes/messages for both missing context (500) and permission denial (403). Remove obsolete role-based decorators to avoid confusion. This pattern ensures robust, maintainable route protection.

## Authentication System Implementation

### Best Practices
1. **Rate Limiting**
   - Implement rate limiting per endpoint rather than globally
   - Use separate stores for different endpoints
   - Reset limits on successful attempts
   - Make rate limiting configurable for testing

2. **Permission Management**
   - Use request-level caching for performance
   - Implement proper cache invalidation
   - Use SQLAlchemy EXISTS for efficient queries
   - Test permission inheritance thoroughly

3. **Testing**
   - Reset stateful components (like rate limiters) between tests
   - Test edge cases in authentication flows
   - Verify permission caching behavior
   - Include performance benchmarks

4. **Error Handling**
   - Provide specific error messages for each failure case
   - Include retry-after headers for rate limiting
   - Handle database errors gracefully
   - Log authentication failures appropriately

5. **Security**
   - Never store plaintext passwords
   - Use strong hashing algorithms (PBKDF2-SHA256)
   - Implement proper token expiration
   - Validate all input fields

### Architectural Decisions
1. **Permission Caching**
   - Chose request-level caching over global caching
   - Used Flask's `g` object for automatic cleanup
   - Implemented efficient permission checking with EXISTS

2. **Role System**
   - Used many-to-many relationships for flexibility
   - Implemented role inheritance
   - Made roles extensible for future changes

3. **Rate Limiting**
   - Per-endpoint stores for fine-grained control
   - IP-based limiting for security
   - Configurable windows and attempts
</file>

<file path="fbo-launchpad-backend/docs/networkDocumentation.md">
# FBO LaunchPad API Documentation

## Authentication

### Login Endpoint
```
POST /auth/login
Content-Type: application/json
```

**Request Body:**
```json
{
    "email": "string",
    "password": "string"
}
```

**Response (200 OK):**
```json
{
    "token": "string"  // JWT token for subsequent requests
}
```

**Usage Notes:**
- All subsequent API requests must include the JWT token in the Authorization header
- Format: `Authorization: Bearer <token>`
- Two types of users: CSR (Customer Service Representative) and LST (Line Service Technician)

## Fuel Orders API

### 1. Create Fuel Order
```
POST /fuel-orders/
Authorization: Bearer <token>
Content-Type: application/json
```

**Access:** CSR users only

**Request Body:**
```json
{
    "tail_number": "string",
    "fuel_type": "string",
    "requested_amount": "number",
    "location_on_ramp": "string",
    "csr_notes": "string",
    "assigned_truck_id": "number",
    "assigned_lst_user_id": "number",
    "additive_requested": "boolean",
    "customer_id": "number"  // optional
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "tail_number": "string",
    "customer_id": "number",
    "fuel_type": "string",
    "additive_requested": "boolean",
    "requested_amount": "number",
    "assigned_lst_user_id": "number",
    "assigned_truck_id": "number",
    "location_on_ramp": "string",
    "csr_notes": "string",
    "status": "string",  // Initially "Dispatched"
    "created_at": "string"  // ISO format datetime
}
```

### 2. Get Fuel Orders List
```
GET /fuel-orders/
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
    "fuel_orders": [
        {
            "id": "number",
            "status": "string",
            "tail_number": "string",
            "customer_id": "number",
            "fuel_type": "string",
            "additive_requested": "boolean",
            "requested_amount": "string",
            "assigned_lst_user_id": "number",
            "assigned_truck_id": "number",
            "location_on_ramp": "string",
            "start_meter_reading": "string",
            "end_meter_reading": "string",
            "calculated_gallons_dispensed": "string",
            "created_at": "string",
            "dispatch_timestamp": "string",
            "acknowledge_timestamp": "string",
            "en_route_timestamp": "string",
            "fueling_start_timestamp": "string"
        }
    ],
    "pagination": {
        "page": "number",
        "per_page": "number",
        "total_pages": "number",
        "total_items": "number",
        "has_next": "boolean",
        "has_prev": "boolean"
    }
}
```

### 3. Update Fuel Order Status
```
PUT /fuel-orders/{order_id}/
Authorization: Bearer <token>
Content-Type: application/json
```

**Request Body:**
```json
{
    "status": "string",  // Must be uppercase with underscores
    "assigned_truck_id": "number"
}
```

**Valid Status Values:**
- "DISPATCHED"
- "ACKNOWLEDGED"
- "EN_ROUTE"
- "FUELING"
- "COMPLETED"
- "REVIEWED"
- "CANCELLED"

**Response (200 OK):**
```json
{
    "id": "number",
    "tail_number": "string",
    "customer_id": "number",
    "fuel_type": "string",
    "additive_requested": "boolean",
    "requested_amount": "number",
    "assigned_lst_user_id": "number",
    "assigned_truck_id": "number",
    "location_on_ramp": "string",
    "csr_notes": "string",
    "status": "string",
    "updated_at": "string"
}
```

### 4. Submit Fuel Data (Complete Order)
```
PUT /fuel-orders/{order_id}/submit-data
Authorization: Bearer <token>
Content-Type: application/json
```

**Access:** LST users only

**Request Body:**
```json
{
    "start_meter_reading": "number",
    "end_meter_reading": "number",
    "lst_notes": "string"  // optional
}
```

**Validation Rules:**
- Order must be in "FUELING" status
- `end_meter_reading` must be greater than `start_meter_reading`
- Both meter readings must be non-negative

**Response (200 OK):**
```json
{
    "message": "Fuel data submitted successfully",
    "fuel_order": {
        "id": "number",
        "status": "string",
        "tail_number": "string",
        "start_meter_reading": "string",
        "end_meter_reading": "string",
        "calculated_gallons_dispensed": "string",
        "lst_notes": "string",
        "completion_timestamp": "string"
    }
}
```

## Fuel Order Workflow

1. **Order Creation (CSR)**
   - CSR creates order with initial details
   - Status: DISPATCHED

2. **LST Acknowledgment**
   - LST acknowledges the assigned order
   - Status: ACKNOWLEDGED

3. **En Route**
   - LST indicates they're heading to the aircraft
   - Status: EN_ROUTE

4. **Fueling**
   - LST begins fueling operation
   - Status: FUELING

5. **Completion**
   - LST submits meter readings and notes
   - Must use dedicated `/submit-data` endpoint
   - Status: COMPLETED

6. **Review**
   - CSR reviews the completed order
   - Status: REVIEWED

## Frontend Implementation Guidelines

1. **Authentication Flow**
   - Implement login screen
   - Store JWT token securely
   - Include token in all API requests
   - Handle token expiration

2. **Role-Based UI**
   - Show different views for CSR and LST users
   - CSR: Order creation, review, and overview
   - LST: Order acknowledgment, status updates, and completion

3. **Status Management**
   - Use exact status strings as specified
   - Implement status transition validation
   - Show appropriate action buttons based on current status

4. **Forms**
   - Validate all required fields
   - Format numbers appropriately
   - Handle optional fields
   - Show validation errors

5. **Real-time Updates**
   - Implement polling or WebSocket for order status updates
   - Show status changes in real-time

---

## Users API

### 1. Create User
```
POST /users/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string",
    "email": "string",
    "role": "string",  // ADMIN, CSR, LST
    "password": "string"
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "name": "string",
    "email": "string",
    "role": "string",
    "is_active": "boolean",
    "created_at": "string"
}
```

### 2. Get User List
```
GET /users/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "users": [
        {
            "id": "number",
            "name": "string",
            "email": "string",
            "role": "string",
            "is_active": "boolean",
            "created_at": "string"
        }
    ]
}
```

### 3. Update User
```
PATCH /users/{user_id}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string",  // optional
    "email": "string", // optional
    "role": "string",  // optional
    "is_active": "boolean" // optional
}
```

**Response (200 OK):**
```json
{
    "id": "number",
    "name": "string",
    "email": "string",
    "role": "string",
    "is_active": "boolean",
    "created_at": "string"
}
```

### 4. Delete User
```
DELETE /users/{user_id}
Authorization: Bearer <token>
```
**Access:** Admin only (soft delete)

**Response (200 OK):**
```json
{
    "message": "User deleted"
}
```

---

## Fuel Trucks API

### 1. Create Fuel Truck
```
POST /fuel-trucks/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "truck_number": "string",
    "fuel_type": "string",
    "capacity": "number",
    "current_meter_reading": "number"  // optional
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "truck_number": "string",
    "fuel_type": "string",
    "capacity": "number",
    "current_meter_reading": "number",
    "is_active": "boolean"
}
```

### 2. Get Fuel Truck List
```
GET /fuel-trucks/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "fuel_trucks": [
        {
            "id": "number",
            "truck_number": "string",
            "fuel_type": "string",
            "capacity": "number",
            "current_meter_reading": "number",
            "is_active": "boolean"
        }
    ]
}
```

### 3. Update Fuel Truck
```
PATCH /fuel-trucks/{truck_id}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "truck_number": "string", // optional
    "fuel_type": "string", // optional
    "capacity": "number", // optional
    "current_meter_reading": "number", // optional
    "is_active": "boolean" // optional
}
```

**Response (200 OK):**
```json
{
    "id": "number",
    "truck_number": "string",
    "fuel_type": "string",
    "capacity": "number",
    "current_meter_reading": "number",
    "is_active": "boolean"
}
```

### 4. Delete Fuel Truck
```
DELETE /fuel-trucks/{truck_id}
Authorization: Bearer <token>
```
**Access:** Admin only

**Response (200 OK):**
```json
{
    "message": "Fuel truck deleted"
}
```

---

## Aircraft API

### 1. Create Aircraft
```
POST /aircraft/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "tail_number": "string",
    "aircraft_type": "string", // optional
    "customer_id": "number" // optional
}
```

**Response (201 Created):**
```json
{
    "tail_number": "string",
    "aircraft_type": "string",
    "customer_id": "number"
}
```

### 2. Get Aircraft List
```
GET /aircraft/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "aircraft": [
        {
            "tail_number": "string",
            "aircraft_type": "string",
            "customer_id": "number"
        }
    ]
}
```

### 3. Update Aircraft
```
PATCH /aircraft/{tail_number}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "aircraft_type": "string", // optional
    "customer_id": "number" // optional
}
```

**Response (200 OK):**
```json
{
    "tail_number": "string",
    "aircraft_type": "string",
    "customer_id": "number"
}
```

### 4. Delete Aircraft
```
DELETE /aircraft/{tail_number}
Authorization: Bearer <token>
```
**Access:** Admin only

**Response (200 OK):**
```json
{
    "message": "Aircraft deleted"
}
```

---

## Customers API

### 1. Create Customer
```
POST /customers/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string"
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "name": "string"
}
```

### 2. Get Customer List
```
GET /customers/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "customers": [
        {
            "id": "number",
            "name": "string"
        }
    ]
}
```

### 3. Update Customer
```
PATCH /customers/{customer_id}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string" // optional
}
```

**Response (200 OK):**
```json
{
    "id": "number",
    "name": "string"
}
```

### 4. Delete Customer
```
DELETE /customers/{customer_id}
Authorization: Bearer <token>
```
**Access:** Admin only

**Response (200 OK):**
```json
{
    "message": "Customer deleted"
}
```

---

### Inconsistencies/Required Changes
- All endpoint prefixes should be plural (e.g., `/users/`, `/fuel-trucks/`, `/aircraft/`, `/customers/`).
- Consistent use of snake_case for field names in backend, but some older docs and possibly frontend code use camelCase. **Frontend and docs should be updated to snake_case everywhere.**
- All numeric fields are returned as numbers, not strings, in real API responses.
- Status values for fuel orders must be uppercase with underscores (e.g., `DISPATCHED`).
- All timestamps are ISO 8601 strings.
- All CRUD endpoints require JWT in Authorization header.
- All create/update endpoints use POST/PATCH with JSON bodies.
- Fuel truck and aircraft uniqueness is enforced by `truck_number` and `tail_number` respectively.
- User deletion is soft (deactivation), but API returns a generic "deleted" message.

#### Additional File Changes Needed
- **Frontend code** (especially API calls, data models, and UI components) should be reviewed and updated to use snake_case for all fields to match backend and OpenAPI documentation.
- **Documentation** (including API docs and example payloads) should be standardized to snake_case for consistency and clarity.
   - Update order list when status changes

6. **Error Handling**
   - Handle all HTTP status codes
   - Show appropriate error messages
   - Implement retry logic where appropriate
</file>

<file path="fbo-launchpad-backend/docs/product_requirement_docs.md">
# FBO LaunchPad Backend Project Brief

## Project Overview
FBO LaunchPad is a comprehensive Fixed Base Operator (FBO) management system designed to streamline aircraft fueling operations. The backend provides a RESTful API that supports the core functionality of fuel order management, user authentication, and real-time status tracking.

## Core Requirements

### 1. User Management
- Support multiple user roles (CSR, LST, Admin)
- Secure authentication using JWT tokens
- Role-based access control for all operations
- User status tracking (active/inactive)

### 2. Fuel Order Management
- Complete fuel order lifecycle management
- Real-time status updates
- Meter reading validation
- Support for multiple fuel types
- Customer and aircraft tracking

### 3. Security
- JWT-based authentication
- Role-based authorization
- Secure password handling
- CORS protection for frontend integration

### 4. API Design
- RESTful architecture
- OpenAPI/Swagger documentation
- Consistent error handling
- Pagination for list endpoints

## Technical Goals
1. Maintainable and modular codebase
2. Comprehensive test coverage
3. Clear API documentation
4. Scalable database design
5. Efficient query optimization

## Success Criteria
1. All API endpoints documented and tested
2. 90%+ test coverage
3. Sub-second response times for common operations
4. Zero security vulnerabilities in authentication
5. Successful integration with frontend application

## Non-Functional Requirements
1. Response time < 1 second for 95% of requests
2. 99.9% uptime during operational hours
3. Support for concurrent users
4. Audit trail for all fuel operations
5. Backup and recovery procedures 

# Product Context

## Business Overview

FBO LaunchPad is a comprehensive Fixed Base Operator (FBO) management system designed to streamline aircraft fueling operations at airports. The system connects Customer Service Representatives (CSRs), Line Service Technicians (LSTs), and administrators in a seamless workflow for fuel order management.

## User Roles

### 1. Customer Service Representative (CSR)
- Primary point of contact for aircraft operators
- Creates and manages fuel orders
- Assigns orders to LSTs
- Reviews completed orders
- Manages customer relationships

### 2. Line Service Technician (LST)
- Executes fuel orders
- Updates order status in real-time
- Records fuel meter readings
- Ensures safety compliance
- Reports issues or concerns

### 3. Administrator
- Manages user accounts
- Oversees system operations
- Generates reports
- Configures system settings
- Monitors performance

## Core Workflows

### 1. Fuel Order Creation
```
Aircraft Arrival → CSR Creates Order → LST Assignment → Order Execution → Review
```

### 2. Order Execution
```
Order Receipt → Acknowledgment → En Route → Fueling → Completion → Review
```

### 3. User Management
```
User Creation → Role Assignment → Active Status → Access Control
```

## Business Rules

### 1. Order Management
- Only CSRs can create orders
- LSTs must acknowledge before starting
- Meter readings required for completion
- CSR review required for closure

### 2. User Access
- CSRs manage orders and assignments
- LSTs update order status and data
- Admins have full system access
- Inactive users cannot access system

### 3. Safety & Compliance
- Valid fuel truck assignment required
- Proper meter reading validation
- Complete order documentation
- Audit trail maintenance

## User Experience Goals

### 1. CSR Experience
- Quick order creation
- Clear LST availability status
- Real-time order tracking
- Efficient review process

### 2. LST Experience
- Clear order instructions
- Simple status updates
- Easy data entry
- Mobile-friendly interface

### 3. Admin Experience
- Comprehensive oversight
- Easy user management
- Clear reporting
- System configuration

## Integration Points

### 1. Frontend Application
- Real-time updates
- Responsive design
- Role-based views
- Error handling

### 2. Future Integrations
- Billing systems
- Aircraft tracking
- Weather services
- Maintenance systems

## Success Metrics

### 1. Operational
- Order completion time
- Accuracy of fuel delivery
- System uptime
- Error rate

### 2. User Satisfaction
- CSR efficiency
- LST task completion
- Admin oversight capability
- System reliability

### 3. Business Impact
- Reduced processing time
- Improved accuracy
- Better resource utilization
- Enhanced safety compliance

## Customer Requirements

### 1. Aircraft Operators
- Quick service request
- Accurate fuel delivery
- Clear communication
- Service documentation

### 2. FBO Management
- Operational oversight
- Staff management
- Performance tracking
- Compliance reporting

## Future Considerations

### 1. Feature Expansion
- Customer portal
- Mobile application
- Advanced analytics
- Automated scheduling

### 2. Integration Growth
- Payment processing
- Flight planning
- Inventory management
- Equipment tracking

### 3. Scalability
- Multi-location support
- Increased user capacity
- Enhanced reporting
- Advanced automation
</file>

<file path="fbo-launchpad-backend/docs/technical.md">
# Technical Context

## Technology Stack

### Core Framework
- **Flask** (v3.0.2): Main web framework
- **Flask-SQLAlchemy** (v3.1.1): ORM for database operations
- **Flask-Migrate** (v4.0.5): Database migration management
- **Flask-CORS** (v5.0.1): CORS support for frontend integration

### Authentication & Security
- **PyJWT** (v2.10.0): JWT token handling
- **Werkzeug**: Password hashing (pbkdf2:sha256)

### API Documentation
- **APISpec**: OpenAPI specification generation
- **Marshmallow**: Schema validation and serialization

### Testing
- **pytest**: Test framework
- **pytest-flask**: Flask testing utilities
- **pytest-env**: Environment variable management for tests

## Project Structure
```
fbo-launchpad-backend/
├── src/
│   ├── models/        # Database models
│   ├── routes/        # API endpoints
│   ├── schemas/       # Request/response schemas
│   ├── services/      # Business logic
│   └── utils/         # Shared utilities
├── tests/            # Test suite
└── memory-bank/      # Project documentation
```

## Key Design Patterns

### 1. Model-View-Service
- **Models**: Database schema definitions
- **Views**: Route handlers (controllers)
- **Services**: Business logic implementation

### 2. Repository Pattern
- Database operations abstracted in service layer
- Models define schema and relationships
- Services handle complex queries and transactions

### 3. Factory Pattern
- Application factory for Flask app creation
- Configurable environment settings
- Extension initialization

### 4. Decorator Pattern
- Authentication middleware (@token_required)
- Role-based access control (@require_role)
- Request validation

## Database Schema

### Core Tables
1. **users**
   - Authentication credentials
   - Many-to-many relationship to roles (user_roles)
   - Status tracking

2. **roles**
   - Role name and description
   - Many-to-many relationship to permissions (role_permissions)
   - Many-to-many relationship to users (user_roles)

3. **permissions**
   - Permission key (name) and description
   - Many-to-many relationship to roles (role_permissions)

4. **role_permissions** (association table)
   - Links roles.id and permissions.id

5. **user_roles** (association table)
   - Links users.id and roles.id

6. **fuel_orders**
   - Order details
   - Status tracking
   - Timestamps for workflow stages

7. **customers**
   - Customer information
   - Billing details

8. **aircraft**
   - Aircraft details
   - Maintenance records

9. **fuel_trucks**
   - Equipment tracking
   - Fuel type compatibility

## API Structure

### Authentication
- JWT-based token system
- 1-hour token expiration
- Role information embedded in token

### Request/Response Format
- JSON for all endpoints
- Consistent error response structure
- Pagination for list endpoints

### Error Handling
- HTTP status codes for different scenarios
- Detailed error messages
- Validation error formatting

## Development Workflow

### 1. Code Organization
- Modular blueprint structure
- Clear separation of concerns
- Consistent file naming

### 2. Testing Strategy
- Unit tests for services
- Integration tests for API
- Fixtures for common test data

### 3. Documentation
- OpenAPI/Swagger specs
- Inline code documentation
- Memory bank maintenance

## Deployment Considerations

### Environment Configuration
- Development: SQLite
- Testing: In-memory SQLite
- Production: PostgreSQL

### Security Measures
- CORS configuration
- Password hashing
- Token validation
- Role enforcement

### Performance
- Query optimization
- Connection pooling
- Proper indexing
- Caching strategy (future)

## Authentication System

### Overview
The authentication system uses JWT (JSON Web Tokens) for stateless authentication with Flask-JWT-Extended. It implements:
- Rate limiting per endpoint and IP address
- Permission-based access control (PBAC)
- Request-level permission caching
- Role-based user management

### Components

1. **User Model** (`src/models/user.py`)
- Handles user data and authentication
- Implements password hashing with `werkzeug.security`
- Provides permission checking with request-level caching
- Manages role relationships through SQLAlchemy

2. **Role System** (`src/models/role.py`)
- Defines user roles (Admin, CSR, LST)
- Manages role-permission relationships
- Implements role inheritance

3. **Authentication Routes** (`src/routes/auth_routes.py`)
- `/auth/register`: User registration with validation
- `/auth/login`: User login with rate limiting
- Default role assignment (CSR)
- JWT token generation and validation

### Security Features

1. **Rate Limiting**
- Separate stores for login and register endpoints
- 5 attempts per minute per IP address
- Automatic reset on successful attempts
- Configurable window and attempt limits

2. **Permission Caching**
- Request-scoped caching using Flask's `g` object
- Automatic cache invalidation between requests
- Efficient permission checking with SQLAlchemy EXISTS

3. **Password Security**
- PBKDF2-SHA256 password hashing
- Secure password validation
- No plaintext password storage

### Configuration
```python
JWT_SECRET_KEY=<secure-key>
JWT_ACCESS_TOKEN_EXPIRES=3600  # 1 hour
RATE_LIMIT_ATTEMPTS=5
RATE_LIMIT_WINDOW=60  # seconds
```
</file>

<file path="fbo-launchpad-backend/docs/testing_documentation.md">
# FBO LaunchPad Backend Testing Documentation

## Overview

This document provides comprehensive documentation for the FBO LaunchPad backend test suite. The test suite uses pytest and is designed to test authentication, fuel order management, and related functionality.

## Test Structure

### Directory Layout
```
fbo-launchpad-backend/
├── tests/
│   ├── conftest.py         # Test fixtures and configuration
│   ├── test_auth.py        # Authentication tests
│   ├── test_models.py      # Database model tests
│   └── test_routes.py      # API route tests
```

## Test Configuration

### Test Environment Setup (`conftest.py`)

The test environment is configured in `conftest.py` with the following key settings:

1. **Application Configuration**
   ```python
   app.config['TESTING'] = True
   app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
   app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
   app.config['SECRET_KEY'] = 'test-secret-key'
   ```

2. **Database Setup**
   - Uses SQLite in-memory database for tests
   - Tables are created and dropped for each test
   - Required tables: users, aircraft, customers, fuel_trucks, fuel_orders

### Test Fixtures

#### User Fixtures
1. **test_csr_user**
   - Role: CSR (Customer Service Representative)
   - Email: testcsr@example.com
   - Password: csrpass

2. **test_lst_user**
   - Role: LST (Line Service Technician)
   - Email: testlst@example.com
   - Password: csrpass

3. **test_admin_user**
   - Role: Admin
   - Email: testadmin@example.com
   - Password: password123

4. **test_inactive_user**
   - Role: CSR
   - Email: inactive@example.com
   - Password: inactivepass
   - Status: inactive

#### Resource Fixtures
1. **test_aircraft**
   - Tail Number: N12345
   - Type: Test Aircraft

2. **test_customer**
   - Name: Test Customer
   - Email: customer@example.com

3. **test_fuel_truck**
   - Truck Number: TRUCK001
   - Fuel Type: Jet A
   - Capacity: 5000.0

#### Authentication Fixtures
- **auth_headers**: Generates JWT tokens for different user roles
- Token payload includes: user ID, role, and expiration (1 hour)

## Test Suites

### 1. Authentication Tests (`test_auth.py`)

#### Registration Tests
```python
test_register_success()
test_register_missing_fields()
test_register_invalid_email()
test_register_duplicate_email()
```

Expected Behavior:
- New users are registered with LST role by default
- Username is generated from email (part before @)
- Duplicate emails are rejected
- Password is hashed before storage

#### Login Tests
```python
test_login_success()
test_login_incorrect_password()
test_login_nonexistent_email()
test_login_missing_fields()
test_login_inactive_user()
```

Expected Behavior:
- Successful login returns JWT token
- Invalid credentials return 401
- Inactive users cannot login
- Missing fields return 400

### 2. Fuel Order Tests (`test_routes.py`)

#### Order Management
```python
test_create_fuel_order()
test_get_fuel_orders()
test_update_fuel_order_status()
test_complete_fuel_order()
```

Expected Behavior:
- Orders require authentication
- CSR can create and review orders
- LST can update order status
- Complete flow: Dispatch → Acknowledge → En Route → Fueling → Complete → Review

## Authentication Requirements

### JWT Token Format
```python
{
    'sub': user.id,
    'role': user.role.value,
    'exp': datetime.utcnow() + timedelta(hours=1)
}
```

### Password Configuration
- All test users except specified use 'csrpass'
- Passwords are hashed using Werkzeug's password hashing
- Method: 'pbkdf2:sha256'

## Running Tests

### Basic Test Run
```bash
python -m pytest tests/ -v
```

### Run Specific Test File
```bash
python -m pytest tests/test_auth.py -v
```

### Run Specific Test
```bash
python -m pytest tests/test_auth.py::test_register_success -v
```

## Common Issues and Solutions

1. **SQLAlchemy Deprecation Warnings**
   - Warning about `Query.get()` being deprecated
   - Future update should use `Session.get()`

2. **JSON Serialization**
   - Enums must be converted to their values before JSON serialization
   - Use `enum_value.value` when returning in API responses

3. **Password Handling**
   - Always use `set_password()` method to hash passwords
   - Use `check_password()` method to verify passwords

## Test Dependencies

Required packages (from requirements.txt):
```
Flask==3.0.2
Flask-Cors==5.0.1
Flask-Migrate==4.0.5
Flask-SQLAlchemy==3.1.1
PyJWT>=2.0.0,<3.0.0
pytest==8.0.2
pytest-env==1.1.3
pytest-flask==1.3.0
```

## Best Practices

1. **Database Operations**
   - Always use test database (SQLite in memory)
   - Clean up after each test
   - Use transactions for data modifications

2. **Authentication**
   - Always verify token validation
   - Check role-based access
   - Validate inactive user states

3. **Test Isolation**
   - Each test should be independent
   - Use fresh fixtures for each test
   - Clean up any created resources

## Maintenance Notes

1. **Adding New Tests**
   - Follow existing patterns
   - Include both success and failure cases
   - Document expected behavior

2. **Updating Fixtures**
   - Maintain password consistency
   - Update auth_headers when adding roles
   - Keep test data realistic but simple

3. **Error Handling**
   - Verify error messages match frontend expectations
   - Include appropriate HTTP status codes

---

## Common JWT & Auth Pitfalls (for AI & Developers)

### 1. JWT Subject (`sub`) Type Mismatch
- Flask-JWT-Extended requires the `identity` (which becomes the JWT `sub` claim) to be a string. If you pass an integer (e.g., user ID), decoding will fail with `Subject must be a string`.
- **Solution:** Always use `create_access_token(identity=str(user.id))`.

### 2. Wrong Secret Key for JWT
- Flask-JWT-Extended uses `JWT_SECRET_KEY` for signing tokens, not `SECRET_KEY`.
- **Solution:** Always decode tokens with `JWT_SECRET_KEY` and ensure both creation and validation use the same key.

### 3. Algorithm Mismatch
- The default algorithm is `HS256`, but if you override it, you must specify the same in both token creation and decoding.
- **Solution:** Set `JWT_ALGORITHM = 'HS256'` in your config and use it everywhere.

### 4. Custom Decorators vs Flask-JWT-Extended
- If you use custom decorators (e.g., `token_required`), make sure they decode tokens using the correct secret and algorithm, and handle the `sub` claim as a string.
- **Solution:** Align custom logic with Flask-JWT-Extended's defaults. Prefer using `@jwt_required()` if possible.

### 5. In-Memory SQLite and Contexts
- When testing with SQLite in-memory, all DB setup, user creation, login, and API calls must happen in the same app context. Otherwise, the DB state will not persist.
- **Solution:** Wrap the entire test in `with app.app_context(): ...`.

### 6. Test Payload Schema Mismatch
- API tests must send all required fields as per the actual endpoint schema. Missing or extra fields cause 400 errors.
- **Solution:** Always check the API schema and update test payloads accordingly.

### 7. Legacy SQLAlchemy Warnings
- `Query.get()` is deprecated in SQLAlchemy 2.x. Use `Session.get()` instead.
- **Solution:** Update ORM calls to avoid warnings in future upgrades.

---

**Following these practices will save hours of debugging for both humans and AI!**
   - Log sufficient debug information
</file>

<file path="fbo-launchpad-backend/docs/testingContext.md">
# Testing Context

## Authentication Testing

### Test Coverage
1. Registration Tests (`/api/auth/register`)
   - Successful registration
   - Missing required fields
   - Invalid email format
   - Duplicate email registration

2. Login Tests (`/api/auth/login`)
   - Successful login
   - Incorrect password
   - Nonexistent email
   - Missing fields
   - Inactive user login attempt

### Test Fixtures Used
- `client`: Flask test client
- `db_session`: Database session for test isolation
- `test_users`: Pre-configured user accounts
  - CSR user
  - LST user
  - Inactive user

### Test File Structure
```
tests/
├── conftest.py         # Test fixtures and configuration
├── test_auth.py        # Authentication endpoint tests
├── test_routes.py      # Other route tests
├── test_models.py      # Model tests
└── __init__.py
```

### Running Tests
```bash
# Inside backend container
pytest tests/test_auth.py -v  # Run auth tests with verbose output
pytest                       # Run all tests
pytest -k "test_register"    # Run specific test pattern
```

### Test Implementation Details
1. Registration Tests
   - Verify response status codes
   - Check response message format
   - Validate user creation in database
   - Test password hashing
   - Verify default role assignment

2. Login Tests
   - Verify JWT token generation
   - Check error message format
   - Test authentication failures
   - Validate inactive user handling

### Next Steps
1. Add token validation tests
2. Implement password complexity tests
3. Add rate limiting tests
4. Test token refresh functionality
5. Add session management tests
</file>

<file path="fbo-launchpad-backend/fbo_launchpad_backend.egg-info/dependency_links.txt">

</file>

<file path="fbo-launchpad-backend/fbo_launchpad_backend.egg-info/PKG-INFO">
Metadata-Version: 2.4
Name: fbo-launchpad-backend
Version: 0.1.0
Requires-Dist: flask
Requires-Dist: flask-sqlalchemy
Requires-Dist: flask-migrate
Requires-Dist: psycopg2-binary
Requires-Dist: python-dotenv
Requires-Dist: apispec
Requires-Dist: apispec-webframeworks
Requires-Dist: marshmallow
Dynamic: requires-dist
</file>

<file path="fbo-launchpad-backend/fbo_launchpad_backend.egg-info/requires.txt">
flask
flask-sqlalchemy
flask-migrate
psycopg2-binary
python-dotenv
apispec
apispec-webframeworks
marshmallow
</file>

<file path="fbo-launchpad-backend/fbo_launchpad_backend.egg-info/SOURCES.txt">
setup.py
fbo_launchpad_backend.egg-info/PKG-INFO
fbo_launchpad_backend.egg-info/SOURCES.txt
fbo_launchpad_backend.egg-info/dependency_links.txt
fbo_launchpad_backend.egg-info/requires.txt
fbo_launchpad_backend.egg-info/top_level.txt
src/__init__.py
src/app.py
src/config.py
src/extensions.py
src/models/__init__.py
src/models/aircraft.py
src/models/customer.py
src/models/fuel_order.py
src/models/fuel_truck.py
src/models/user.py
src/routes/__init__.py
src/routes/auth_routes.py
src/routes/fuel_order_routes.py
src/schemas/__init__.py
src/schemas/auth_schemas.py
src/services/__init__.py
src/services/auth_service.py
src/services/fuel_order_service.py
src/utils/__init__.py
src/utils/decorators.py
tests/__init__.py
</file>

<file path="fbo-launchpad-backend/fbo_launchpad_backend.egg-info/top_level.txt">
src
tests
</file>

<file path="fbo-launchpad-backend/migrations/versions/05eadf8716a5_implement_pbac_models_permission_role_.py">
"""Implement PBAC models (Permission, Role, User roles relationship)

Revision ID: 05eadf8716a5
Revises: f1d4eec2dff2
Create Date: 2025-04-28 17:28:08.692228

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '05eadf8716a5'
down_revision = 'f1d4eec2dff2'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('permissions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )

    # Define permissions table for bulk insert
    permissions_table = sa.sql.table('permissions',
        sa.sql.column('name', sa.String),
        sa.sql.column('description', sa.Text),
        sa.sql.column('created_at', sa.DateTime),
        sa.sql.column('updated_at', sa.DateTime)
    )
    from datetime import datetime
    now = datetime.utcnow()
    all_permissions = [
        {'name': 'CREATE_ORDER', 'description': 'Allows creating new fuel orders', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_ASSIGNED_ORDERS', 'description': 'Allows viewing orders assigned to self', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_ALL_ORDERS', 'description': 'Allows viewing all fuel orders', 'created_at': now, 'updated_at': now},
        {'name': 'UPDATE_OWN_ORDER_STATUS', 'description': 'Allows LST to update status of own orders', 'created_at': now, 'updated_at': now},
        {'name': 'COMPLETE_OWN_ORDER', 'description': 'Allows LST to complete own orders', 'created_at': now, 'updated_at': now},
        {'name': 'REVIEW_ORDERS', 'description': 'Allows CSR/Admin to mark orders as reviewed', 'created_at': now, 'updated_at': now},
        {'name': 'EXPORT_ORDERS_CSV', 'description': 'Allows exporting order data to CSV', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_ORDER_STATS', 'description': 'Allows viewing order statistics', 'created_at': now, 'updated_at': now},
        {'name': 'EDIT_FUEL_ORDER', 'description': 'Allows editing fuel order details (Admin?)', 'created_at': now, 'updated_at': now},
        {'name': 'DELETE_FUEL_ORDER', 'description': 'Allows deleting fuel orders (Admin?)', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_USERS', 'description': 'Allows viewing user list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_USERS', 'description': 'Allows creating, updating, deleting users and assigning roles', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_TRUCKS', 'description': 'Allows viewing fuel truck list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_TRUCKS', 'description': 'Allows creating, updating, deleting fuel trucks', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_AIRCRAFT', 'description': 'Allows viewing aircraft list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_AIRCRAFT', 'description': 'Allows creating, updating, deleting aircraft', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_CUSTOMERS', 'description': 'Allows viewing customer list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_CUSTOMERS', 'description': 'Allows creating, updating, deleting customers', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_ROLES', 'description': 'Allows managing roles and their permissions', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_PERMISSIONS', 'description': 'Allows viewing available system permissions', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_SETTINGS', 'description': 'Allows managing global application settings', 'created_at': now, 'updated_at': now},
    ]
    op.bulk_insert(permissions_table, all_permissions)

    with op.batch_alter_table('permissions', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_permissions_name'), ['name'], unique=True)

    op.create_table('roles',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=80), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('roles', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_roles_name'), ['name'], unique=True)

    op.create_table('role_permissions',
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.Column('permission_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['permission_id'], ['permissions.id'], ),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.PrimaryKeyConstraint('role_id', 'permission_id')
    )
    op.create_table('user_roles',
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('user_id', 'role_id')
    )
    # Initialize session for data migration and seeding
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)
    permissions_table_id = sa.sql.table('permissions',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String)
    )
    roles_table_id = sa.sql.table('roles',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String)
    )
    # --- PBAC Step 6: Migrate existing users to new roles ---
    users_table = sa.sql.table('users',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('role', sa.String)
    )
    user_roles_table = sa.sql.table('user_roles',
        sa.sql.column('user_id', sa.Integer),
        sa.sql.column('role_id', sa.Integer)
    )
    old_role_to_new_role_name = {
        'ADMIN': 'System Administrator',
        'CSR': 'Customer Service Representative',
        'LST': 'Line Service Technician'
    }
    # Fetch IDs of the NEW default roles
    role_results = session.execute(sa.select(roles_table_id.c.id, roles_table_id.c.name).where(roles_table_id.c.name.in_(old_role_to_new_role_name.values()))).fetchall()
    new_role_name_to_id_map = {name: id for id, name in role_results}
    # Fetch existing users and their OLD roles
    user_results = session.execute(sa.select(users_table.c.id, users_table.c.role)).fetchall()
    user_role_assignments = []
    for user_id, old_role_value in user_results:
        if old_role_value is None:
            continue
        new_role_name = old_role_to_new_role_name.get(str(old_role_value).upper())
        if new_role_name:
            new_role_id = new_role_name_to_id_map.get(new_role_name)
            if new_role_id:
                user_role_assignments.append({'user_id': user_id, 'role_id': new_role_id})
    if user_role_assignments:
        op.bulk_insert(user_roles_table, user_role_assignments)
    session.commit()
    # --- End PBAC Step 6 ---

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_column('role')

    # --- PBAC Step 5: Seed default roles and assign permissions ---
    roles_table = sa.sql.table('roles',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String),
        sa.sql.column('description', sa.Text),
        sa.sql.column('created_at', sa.DateTime),
        sa.sql.column('updated_at', sa.DateTime)
    )
    role_permissions_table = sa.sql.table('role_permissions',
        sa.sql.column('role_id', sa.Integer),
        sa.sql.column('permission_id', sa.Integer)
    )
    # Default roles
    default_roles = [
        {'name': 'System Administrator', 'description': 'Full system access', 'created_at': now, 'updated_at': now},
        {'name': 'Customer Service Representative', 'description': 'Manages orders, customers, basic data', 'created_at': now, 'updated_at': now},
        {'name': 'Line Service Technician', 'description': 'Handles assigned fuel orders on the ramp', 'created_at': now, 'updated_at': now}
    ]
    op.bulk_insert(roles_table, default_roles)

    # Permission mapping for each role
    role_permission_mapping = {
        'System Administrator': [p['name'] for p in all_permissions],
        'Customer Service Representative': [
            'CREATE_ORDER', 'VIEW_ALL_ORDERS', 'REVIEW_ORDERS', 'EXPORT_ORDERS_CSV',
            'VIEW_ORDER_STATS', 'EDIT_FUEL_ORDER',
            'VIEW_USERS', 'VIEW_TRUCKS', 'VIEW_AIRCRAFT', 'VIEW_CUSTOMERS',
            'MANAGE_AIRCRAFT', 'MANAGE_CUSTOMERS',
            'VIEW_PERMISSIONS'
        ],
        'Line Service Technician': [
            'VIEW_ASSIGNED_ORDERS', 'UPDATE_OWN_ORDER_STATUS', 'COMPLETE_OWN_ORDER',
            'VIEW_ORDER_STATS'
        ]
    }
    # Fetch IDs for permissions and roles
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)
    perm_results = session.execute(sa.select(permissions_table_id.c.id, permissions_table_id.c.name)).fetchall()
    permission_map = {name: id for id, name in perm_results}
    role_results = session.execute(sa.select(roles_table_id.c.id, roles_table_id.c.name).where(roles_table_id.c.name.in_(role_permission_mapping.keys()))).fetchall()
    role_map = {name: id for id, name in role_results}
    role_permissions_data = []
    for role_name, permission_names in role_permission_mapping.items():
        role_id = role_map.get(role_name)
        if role_id:
            for perm_name in permission_names:
                permission_id = permission_map.get(perm_name)
                if permission_id:
                    role_permissions_data.append({'role_id': role_id, 'permission_id': permission_id})
    if role_permissions_data:
        op.bulk_insert(role_permissions_table, role_permissions_data)
    session.commit()
    # --- End PBAC Step 5 ---

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('role', postgresql.ENUM('LST', 'CSR', 'ADMIN', name='userrole'), autoincrement=False, nullable=False))

    # --- PBAC Step 6: Remove all user-role links ---
    op.execute('DELETE FROM user_roles')
    # --- End PBAC Step 6 ---

    op.drop_table('user_roles')
    op.drop_table('role_permissions')
    with op.batch_alter_table('roles', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_roles_name'))

    op.drop_table('roles')
    with op.batch_alter_table('permissions', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_permissions_name'))

    # Remove seeded permissions before dropping table
    permissions_table = sa.sql.table('permissions',
        sa.sql.column('name', sa.String)
    )
    permission_names = [
        'CREATE_ORDER',
        'VIEW_ASSIGNED_ORDERS',
        'VIEW_ALL_ORDERS',
        'UPDATE_OWN_ORDER_STATUS',
        'COMPLETE_OWN_ORDER',
        'REVIEW_ORDERS',
        'EXPORT_ORDERS_CSV',
        'VIEW_ORDER_STATS',
        'EDIT_FUEL_ORDER',
        'DELETE_FUEL_ORDER',
        'VIEW_USERS',
        'MANAGE_USERS',
        'VIEW_TRUCKS',
        'MANAGE_TRUCKS',
        'VIEW_AIRCRAFT',
        'MANAGE_AIRCRAFT',
        'VIEW_CUSTOMERS',
        'MANAGE_CUSTOMERS',
        'MANAGE_ROLES',
        'VIEW_PERMISSIONS',
        'MANAGE_SETTINGS',
    ]
    op.execute(
        permissions_table.delete().where(permissions_table.c.name.in_(permission_names))
    )

    op.drop_table('permissions')

    # --- PBAC Step 5: Remove seeded role-permissions and roles ---
    role_permissions_table = sa.sql.table('role_permissions',
        sa.sql.column('role_id', sa.Integer),
        sa.sql.column('permission_id', sa.Integer)
    )
    roles_table = sa.sql.table('roles',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String)
    )
    # Remove role-permission links for default roles
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)
    default_role_names = [
        'System Administrator',
        'Customer Service Representative',
        'Line Service Technician'
    ]
    # Get role IDs for default roles
    role_results = session.execute(sa.select(roles_table.c.id, roles_table.c.name).where(roles_table.c.name.in_(default_role_names))).fetchall()
    role_ids = [id for id, name in role_results]
    if role_ids:
        op.execute(role_permissions_table.delete().where(role_permissions_table.c.role_id.in_(role_ids)))
    # Remove default roles
    op.execute(roles_table.delete().where(roles_table.c.name.in_(default_role_names)))
    session.commit()
    # --- End PBAC Step 5 ---

    # ### end Alembic commands ###
</file>

<file path="fbo-launchpad-backend/migrations/versions/87256ef2abc1_initial_migration.py">
"""Initial migration

Revision ID: 87256ef2abc1
Revises: 05eadf8716a5
Create Date: 2025-04-30 18:28:24.451898

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '87256ef2abc1'
down_revision = '05eadf8716a5'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('aircraft',
    sa.Column('tail_number', sa.String(length=20), nullable=False),
    sa.Column('aircraft_type', sa.String(length=50), nullable=False),
    sa.Column('fuel_type', sa.String(length=20), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('tail_number')
    )
    op.create_table('customers',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('phone', sa.String(length=20), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('customers', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_customers_email'), ['email'], unique=True)

    op.create_table('fuel_trucks',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('truck_number', sa.String(length=20), nullable=False),
    sa.Column('fuel_type', sa.String(length=50), nullable=False),
    sa.Column('capacity', sa.Numeric(precision=10, scale=2), nullable=False),
    sa.Column('current_meter_reading', sa.Numeric(precision=12, scale=2), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('truck_number')
    )
    op.create_table('permissions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('permissions', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_permissions_name'), ['name'], unique=True)

    op.create_table('roles',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=80), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('roles', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_roles_name'), ['name'], unique=True)

    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=64), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('name', sa.String(length=120), nullable=True),
    sa.Column('password_hash', sa.String(length=128), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_users_email'), ['email'], unique=True)
        batch_op.create_index(batch_op.f('ix_users_username'), ['username'], unique=True)

    op.create_table('fuel_orders',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('status', sa.Enum('DISPATCHED', 'ACKNOWLEDGED', 'EN_ROUTE', 'FUELING', 'COMPLETED', 'REVIEWED', 'CANCELLED', name='fuelorderstatus'), nullable=False),
    sa.Column('tail_number', sa.String(length=20), nullable=False),
    sa.Column('customer_id', sa.Integer(), nullable=True),
    sa.Column('fuel_type', sa.String(length=50), nullable=False),
    sa.Column('additive_requested', sa.Boolean(), nullable=True),
    sa.Column('requested_amount', sa.Numeric(precision=10, scale=2), nullable=True),
    sa.Column('assigned_lst_user_id', sa.Integer(), nullable=True),
    sa.Column('assigned_truck_id', sa.Integer(), nullable=True),
    sa.Column('location_on_ramp', sa.String(length=100), nullable=True),
    sa.Column('csr_notes', sa.Text(), nullable=True),
    sa.Column('lst_notes', sa.Text(), nullable=True),
    sa.Column('start_meter_reading', sa.Numeric(precision=12, scale=2), nullable=True),
    sa.Column('end_meter_reading', sa.Numeric(precision=12, scale=2), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.Column('dispatch_timestamp', sa.DateTime(), nullable=True),
    sa.Column('acknowledge_timestamp', sa.DateTime(), nullable=True),
    sa.Column('en_route_timestamp', sa.DateTime(), nullable=True),
    sa.Column('fueling_start_timestamp', sa.DateTime(), nullable=True),
    sa.Column('completion_timestamp', sa.DateTime(), nullable=True),
    sa.Column('reviewed_timestamp', sa.DateTime(), nullable=True),
    sa.Column('reviewed_by_csr_user_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['assigned_lst_user_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['assigned_truck_id'], ['fuel_trucks.id'], ),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ),
    sa.ForeignKeyConstraint(['reviewed_by_csr_user_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['tail_number'], ['aircraft.tail_number'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_fuel_orders_assigned_lst_user_id'), ['assigned_lst_user_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_assigned_truck_id'), ['assigned_truck_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_status'), ['status'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_tail_number'), ['tail_number'], unique=False)

    op.create_table('role_permissions',
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.Column('permission_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['permission_id'], ['permissions.id'], ),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.PrimaryKeyConstraint('role_id', 'permission_id')
    )
    op.create_table('user_roles',
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('user_id', 'role_id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('user_roles')
    op.drop_table('role_permissions')
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_fuel_orders_tail_number'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_status'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_assigned_truck_id'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_assigned_lst_user_id'))

    op.drop_table('fuel_orders')
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_users_username'))
        batch_op.drop_index(batch_op.f('ix_users_email'))

    op.drop_table('users')
    with op.batch_alter_table('roles', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_roles_name'))

    op.drop_table('roles')
    with op.batch_alter_table('permissions', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_permissions_name'))

    op.drop_table('permissions')
    op.drop_table('fuel_trucks')
    with op.batch_alter_table('customers', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_customers_email'))

    op.drop_table('customers')
    op.drop_table('aircraft')
    # ### end Alembic commands ###
</file>

<file path="fbo-launchpad-backend/migrations/versions/ae3b7293103c_add_aircraft_type_column_to_aircraft_.py">
"""add aircraft_type column to aircraft table

Revision ID: ae3b7293103c
Revises: 1a764e4d3fa2
Create Date: 2025-04-23 13:31:37.962120

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'ae3b7293103c'
down_revision = '1a764e4d3fa2'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('aircraft', schema=None) as batch_op:
        batch_op.add_column(sa.Column('aircraft_type', sa.String(length=50), nullable=False))
        batch_op.drop_constraint('aircraft_customer_id_fkey', type_='foreignkey')
        batch_op.drop_column('customer_id')

    with op.batch_alter_table('customers', schema=None) as batch_op:
        batch_op.add_column(sa.Column('email', sa.String(length=120), nullable=False))
        batch_op.add_column(sa.Column('phone', sa.String(length=20), nullable=True))
        batch_op.alter_column('name',
               existing_type=sa.VARCHAR(length=150),
               type_=sa.String(length=100),
               existing_nullable=False)
        batch_op.create_index(batch_op.f('ix_customers_email'), ['email'], unique=True)

    with op.batch_alter_table('fuel_trucks', schema=None) as batch_op:
        batch_op.add_column(sa.Column('truck_number', sa.String(length=20), nullable=False))
        batch_op.add_column(sa.Column('fuel_type', sa.String(length=50), nullable=False))
        batch_op.add_column(sa.Column('capacity', sa.Numeric(precision=10, scale=2), nullable=False))
        batch_op.add_column(sa.Column('current_meter_reading', sa.Numeric(precision=12, scale=2), nullable=False))
        batch_op.drop_constraint('fuel_trucks_name_key', type_='unique')
        batch_op.create_unique_constraint(None, ['truck_number'])
        batch_op.drop_column('name')

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('username', sa.String(length=64), nullable=False))
        batch_op.add_column(sa.Column('password_hash', sa.String(length=128), nullable=True))
        batch_op.create_index(batch_op.f('ix_users_username'), ['username'], unique=True)
        batch_op.drop_column('hashed_password')
        batch_op.drop_column('name')
        batch_op.drop_column('is_active')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=False))
        batch_op.add_column(sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
        batch_op.add_column(sa.Column('hashed_password', sa.VARCHAR(length=255), autoincrement=False, nullable=False))
        batch_op.drop_index(batch_op.f('ix_users_username'))
        batch_op.drop_column('password_hash')
        batch_op.drop_column('username')

    with op.batch_alter_table('fuel_trucks', schema=None) as batch_op:
        batch_op.add_column(sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
        batch_op.drop_constraint(None, type_='unique')
        batch_op.create_unique_constraint('fuel_trucks_name_key', ['name'])
        batch_op.drop_column('current_meter_reading')
        batch_op.drop_column('capacity')
        batch_op.drop_column('fuel_type')
        batch_op.drop_column('truck_number')

    with op.batch_alter_table('customers', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_customers_email'))
        batch_op.alter_column('name',
               existing_type=sa.String(length=100),
               type_=sa.VARCHAR(length=150),
               existing_nullable=False)
        batch_op.drop_column('phone')
        batch_op.drop_column('email')

    with op.batch_alter_table('aircraft', schema=None) as batch_op:
        batch_op.add_column(sa.Column('customer_id', sa.INTEGER(), autoincrement=False, nullable=True))
        batch_op.create_foreign_key('aircraft_customer_id_fkey', 'customers', ['customer_id'], ['id'])
        batch_op.drop_column('aircraft_type')

    # ### end Alembic commands ###
</file>

<file path="fbo-launchpad-backend/migrations/versions/f1d4eec2dff2_add_is_active_column_back_to_users_table.py">
"""add is_active column back to users table

Revision ID: f1d4eec2dff2
Revises: ae3b7293103c
Create Date: 2025-04-24 21:09:13.565962

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'f1d4eec2dff2'
down_revision = 'ae3b7293103c'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.add_column(sa.Column('updated_at', sa.DateTime(), nullable=False))
        batch_op.drop_column('calculated_gallons_dispensed')

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('is_active', sa.Boolean(), nullable=False))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_column('is_active')

    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.add_column(sa.Column('calculated_gallons_dispensed', sa.NUMERIC(precision=10, scale=2), autoincrement=False, nullable=True))
        batch_op.drop_column('updated_at')

    # ### end Alembic commands ###
</file>

<file path="fbo-launchpad-backend/src/models/base.py">
from src.extensions import db

Base = db.Model
</file>

<file path="fbo-launchpad-backend/src/models/permission.py">
from src.extensions import db
from sqlalchemy import Integer, String, Text, DateTime
from datetime import datetime

class Permission(db.Model):
    __tablename__ = 'permissions'

    id = db.Column(Integer, primary_key=True)
    name = db.Column(String(100), unique=True, nullable=False, index=True)
    description = db.Column(Text, nullable=True)
    created_at = db.Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    def __repr__(self):
        return f'<Permission {self.name}>'
</file>

<file path="fbo-launchpad-backend/src/models/role_permission.py">
from src.extensions import db
from sqlalchemy import Integer, ForeignKey

role_permissions = db.Table('role_permissions',
    db.Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    db.Column('permission_id', Integer, ForeignKey('permissions.id'), primary_key=True)
)

user_roles = db.Table('user_roles',
    db.Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    db.Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True)
)
</file>

<file path="fbo-launchpad-backend/src/models/role.py">
from datetime import datetime
from sqlalchemy import Integer, String, Text, DateTime
from ..extensions import db
from .role_permission import role_permissions

class Role(db.Model):
    __tablename__ = 'roles'

    id = db.Column(Integer, primary_key=True)
    name = db.Column(String(80), unique=True, nullable=False, index=True)
    description = db.Column(Text, nullable=True)
    created_at = db.Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    permissions = db.relationship(
        'Permission',
        secondary=role_permissions,
        backref=db.backref('roles', lazy='dynamic'),
        lazy='dynamic'
    )

    def __repr__(self):
        return f'<Role {self.name}>'
</file>

<file path="fbo-launchpad-backend/src/models/settings.py">
# settings.py
# Deprecated: The Setting model and settings table are no longer used. All code removed as of April 2025.
</file>

<file path="fbo-launchpad-backend/src/routes/admin/__init__.py">
from .routes import admin_bp

__all__ = ['admin_bp']
</file>

<file path="fbo-launchpad-backend/src/routes/admin/aircraft_admin_routes.py">
from flask import request, jsonify
from ...services.aircraft_service import AircraftService
from ...services.customer_service import CustomerService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas.admin_schemas import AdminAircraftSchema, AdminAircraftListResponseSchema, ErrorResponseSchema
from src.extensions import apispec
from .routes import admin_bp

@admin_bp.route('/aircraft', methods=['GET'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def list_aircraft():
    """
    ---
    get:
      summary: List all aircraft (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      responses:
        200:
          description: List of aircraft
          content:
            application/json:
              schema: AdminAircraftListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    aircraft_list, msg, status = AircraftService.get_all_aircraft(request.args)
    schema = AdminAircraftSchema(many=True)
    return jsonify({"aircraft": schema.dump(aircraft_list)}), status

@admin_bp.route('/aircraft', methods=['POST'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def create_aircraft():
    """
    ---
    post:
      summary: Create a new aircraft (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminAircraftSchema
      responses:
        201:
          description: Aircraft created
          content:
            application/json:
              schema: AdminAircraftSchema
        400:
          description: Bad request
        409:
          description: Conflict
    """
    data = request.get_json()
    aircraft, msg, status = AircraftService.create_aircraft(data)
    if not aircraft:
        return jsonify({"error": msg}), status
    schema = AdminAircraftSchema()
    return jsonify(schema.dump(aircraft)), status

@admin_bp.route('/aircraft/<string:tail_number>', methods=['GET'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def get_aircraft(tail_number):
    """
    ---
    get:
      summary: Get an aircraft by tail number (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      parameters:
        - in: path
          name: tail_number
          schema:
            type: string
          required: true
      responses:
        200:
          description: Aircraft details
          content:
            application/json:
              schema: AdminAircraftSchema
        404:
          description: Not found
    """
    aircraft, msg, status = AircraftService.get_aircraft_by_tail(tail_number)
    if not aircraft:
        return jsonify({"error": msg}), status
    schema = AdminAircraftSchema()
    return jsonify(schema.dump(aircraft)), status

@admin_bp.route('/aircraft/<string:tail_number>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def update_aircraft(tail_number):
    """
    ---
    patch:
      summary: Update an aircraft by tail number (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      parameters:
        - in: path
          name: tail_number
          schema:
            type: string
          required: true
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminAircraftSchema
      responses:
        200:
          description: Aircraft updated
          content:
            application/json:
              schema: AdminAircraftSchema
        400:
          description: Bad request
        404:
          description: Not found
    """
    data = request.get_json()
    aircraft, msg, status = AircraftService.update_aircraft(tail_number, data)
    if not aircraft:
        return jsonify({"error": msg}), status
    schema = AdminAircraftSchema()
    return jsonify(schema.dump(aircraft)), status

@admin_bp.route('/aircraft/<string:tail_number>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def delete_aircraft(tail_number):
    """
    ---
    delete:
      summary: Delete an aircraft by tail number (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      parameters:
        - in: path
          name: tail_number
          schema:
            type: string
          required: true
      responses:
        204:
          description: Aircraft deleted
        404:
          description: Not found
        409:
          description: Conflict (referenced by other records)
    """
    deleted, msg, status = AircraftService.delete_aircraft(tail_number)
    if not deleted:
        return jsonify({"error": msg}), status
    return '', 204
</file>

<file path="fbo-launchpad-backend/src/routes/admin/assignment_settings_routes.py">
# assignment_settings_routes.py
# Deprecated: Global auto-assign setting is no longer used. All logic removed as of April 2025.
</file>

<file path="fbo-launchpad-backend/src/routes/admin/customer_admin_routes.py">
from flask import request, jsonify
from ...services.customer_service import CustomerService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas.admin_schemas import AdminCustomerSchema, AdminCustomerListResponseSchema, ErrorResponseSchema
from src.extensions import apispec
from .routes import admin_bp

@admin_bp.route('/customers', methods=['GET'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def list_customers():
    """
    ---
    get:
      summary: List all customers (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      responses:
        200:
          description: List of customers
          content:
            application/json:
              schema: AdminCustomerListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    customers, msg, status = CustomerService.get_all_customers(request.args)
    schema = AdminCustomerSchema(many=True)
    return jsonify({"customers": schema.dump(customers)}), status

@admin_bp.route('/customers', methods=['POST'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def create_customer():
    """
    ---
    post:
      summary: Create a new customer (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminCustomerSchema
      responses:
        201:
          description: Customer created
          content:
            application/json:
              schema: AdminCustomerSchema
        400:
          description: Bad request
        409:
          description: Conflict
    """
    data = request.get_json()
    customer, msg, status = CustomerService.create_customer(data)
    if not customer:
        return jsonify({"error": msg}), status
    schema = AdminCustomerSchema()
    return jsonify(schema.dump(customer)), status

@admin_bp.route('/customers/<int:customer_id>', methods=['GET'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def get_customer(customer_id):
    """
    ---
    get:
      summary: Get a customer by ID (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      parameters:
        - in: path
          name: customer_id
          schema:
            type: integer
          required: true
      responses:
        200:
          description: Customer details
          content:
            application/json:
              schema: AdminCustomerSchema
        404:
          description: Not found
    """
    customer, msg, status = CustomerService.get_customer_by_id(customer_id)
    if not customer:
        return jsonify({"error": msg}), status
    schema = AdminCustomerSchema()
    return jsonify(schema.dump(customer)), status

@admin_bp.route('/customers/<int:customer_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def update_customer(customer_id):
    """
    ---
    patch:
      summary: Update a customer by ID (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      parameters:
        - in: path
          name: customer_id
          schema:
            type: integer
          required: true
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminCustomerSchema
      responses:
        200:
          description: Customer updated
          content:
            application/json:
              schema: AdminCustomerSchema
        400:
          description: Bad request
        404:
          description: Not found
    """
    data = request.get_json()
    customer, msg, status = CustomerService.update_customer(customer_id, data)
    if not customer:
        return jsonify({"error": msg}), status
    schema = AdminCustomerSchema()
    return jsonify(schema.dump(customer)), status

@admin_bp.route('/customers/<int:customer_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def delete_customer(customer_id):
    """
    ---
    delete:
      summary: Delete a customer by ID (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      parameters:
        - in: path
          name: customer_id
          schema:
            type: integer
          required: true
      responses:
        204:
          description: Customer deleted
        404:
          description: Not found
        409:
          description: Conflict (referenced by other records)
    """
    deleted, msg, status = CustomerService.delete_customer(customer_id)
    if not deleted:
        return jsonify({"error": msg}), status
    return '', 204
</file>

<file path="fbo-launchpad-backend/src/routes/admin/permission_admin_routes.py">
from flask import request, jsonify
from ...services.permission_service import PermissionService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas import PermissionSchema, ErrorResponseSchema
from marshmallow import Schema, fields
from src.extensions import apispec
from .routes import admin_bp

class PermissionListResponseSchema(Schema):
    permissions = fields.List(fields.Nested(PermissionSchema))

@admin_bp.route('/permissions', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_permissions():
    """
    ---
    get:
      summary: List all permissions (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Permissions
      responses:
        200:
          description: List of permissions
          content:
            application/json:
              schema: PermissionListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    permissions, msg, status = PermissionService.get_all_permissions()
    schema = PermissionSchema(many=True)
    return jsonify({"permissions": schema.dump(permissions)}), status
</file>

<file path="fbo-launchpad-backend/src/routes/admin/role_admin_routes.py">
from flask import request, jsonify
from ...services.role_service import RoleService
from ...services.permission_service import PermissionService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas.role_schemas import (
    RoleSchema,
    RoleListResponseSchema,
    RoleCreateRequestSchema,
    RoleUpdateRequestSchema,
    RoleAssignPermissionRequestSchema
)
from ...schemas.permission_schemas import PermissionSchema
from ...schemas import ErrorResponseSchema
from marshmallow import ValidationError
from src.extensions import apispec
from .routes import admin_bp

@admin_bp.route('/roles', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_roles():
    """
    ---
    get:
      summary: List all roles (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      responses:
        200:
          description: List of roles
          content:
            application/json:
              schema: RoleListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    roles, msg, status = RoleService.get_all_roles()
    schema = RoleSchema(many=True)
    return jsonify({"roles": schema.dump(roles)}), status

@admin_bp.route('/roles', methods=['POST'])
@token_required
@require_permission('MANAGE_ROLES')
def create_role():
    """
    ---
    post:
      summary: Create a new role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      requestBody:
        required: true
        content:
          application/json:
            schema: RoleCreateRequestSchema
      responses:
        201:
          description: Role created
          content:
            application/json:
              schema: RoleSchema
        400:
          description: Bad request
        409:
          description: Conflict
    """
    data = request.get_json()
    role, msg, status = RoleService.create_role(data)
    if not role:
        return jsonify({"error": msg}), status
    schema = RoleSchema()
    return jsonify(schema.dump(role)), status

@admin_bp.route('/roles/<int:role_id>', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_role(role_id):
    """
    ---
    get:
      summary: Get a role by ID (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
      responses:
        200:
          description: Role details
          content:
            application/json:
              schema: RoleSchema
        404:
          description: Not found
    """
    role, msg, status = RoleService.get_role_by_id(role_id)
    if not role:
        return jsonify({"error": msg}), status
    schema = RoleSchema()
    return jsonify(schema.dump(role)), status

@admin_bp.route('/roles/<int:role_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_ROLES')
def update_role(role_id):
    """
    ---
    patch:
      summary: Update a role by ID (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
      requestBody:
        required: true
        content:
          application/json:
            schema: RoleUpdateRequestSchema
      responses:
        200:
          description: Role updated
          content:
            application/json:
              schema: RoleSchema
        400:
          description: Bad request
        404:
          description: Not found
    """
    data = request.get_json()
    role, msg, status = RoleService.update_role(role_id, data)
    if not role:
        return jsonify({"error": msg}), status
    schema = RoleSchema()
    return jsonify(schema.dump(role)), status

@admin_bp.route('/roles/<int:role_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_ROLES')
def delete_role(role_id):
    """
    ---
    delete:
      summary: Delete a role by ID (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
      responses:
        204:
          description: Role deleted
        404:
          description: Not found
        409:
          description: Conflict (role is assigned to users)
    """
    deleted, msg, status = RoleService.delete_role(role_id)
    if not deleted:
        return jsonify({"error": msg}), status
    return '', 204

@admin_bp.route('/roles/<int:role_id>/permissions', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_role_permissions(role_id):
    """
    ---
    get:
      summary: Get permissions assigned to a role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
      responses:
        200:
          description: List of permissions assigned to the role
          content:
            application/json:
              schema: RoleSchema
        404:
          description: Role not found
    """
    role, msg, status = RoleService.get_role_by_id(role_id)
    if not role:
        return jsonify({"error": msg}), status
    schema = RoleSchema()
    return jsonify(schema.dump(role)), status

@admin_bp.route('/roles/<int:role_id>/permissions', methods=['POST'])
@token_required
@require_permission('MANAGE_ROLES')
def assign_permission(role_id):
    """Assign a permission to a role.
    Requires MANAGE_ROLES permission.
    ---
    post:
      summary: Assign permission to role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role
      requestBody:
        required: true
        content:
          application/json:
            schema: RoleAssignPermissionRequestSchema
      responses:
        200:
          description: Permission assigned
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        400:
          description: Bad request
          content:
            application/json:
              schema: ErrorResponseSchema
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Role or permission not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    try:
        schema = RoleAssignPermissionRequestSchema()
        data = schema.load(request.get_json())
    except ValidationError as e:
        return jsonify({
            "error": "Validation error",
            "details": e.messages
        }), 400

    role, message, status_code = RoleService.assign_permission_to_role(role_id, data['permission_id'])
    if role is not None:
        return jsonify({"message": message}), status_code
    return jsonify({"error": message}), status_code

@admin_bp.route('/roles/<int:role_id>/permissions/<int:permission_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_ROLES')
def remove_permission(role_id, permission_id):
    """Remove a permission from a role.
    Requires MANAGE_ROLES permission.
    ---
    delete:
      summary: Remove permission from role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role
        - in: path
          name: permission_id
          schema:
            type: integer
          required: true
          description: ID of the permission to remove
      responses:
        200:
          description: Permission removed
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Role or permission not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    role, message, status_code = RoleService.remove_permission_from_role(role_id, permission_id)
    if role is not None:
        return jsonify({"message": message}), status_code
    return jsonify({"error": message}), status_code
</file>

<file path="fbo-launchpad-backend/src/routes/admin/routes.py">
from flask import Blueprint

admin_bp = Blueprint('admin', __name__, url_prefix='/api/admin')

# Import all admin route modules
from .user_admin_routes import *
from .permission_admin_routes import *
from .role_admin_routes import *
from .customer_admin_routes import *
from .aircraft_admin_routes import *
from .assignment_settings_routes import *

# Register routes with the admin blueprint
# Note: The individual route modules should use admin_bp from this module
</file>

<file path="fbo-launchpad-backend/src/routes/admin/user_admin_routes.py">
from flask import request, jsonify
from ...services.user_service import UserService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas.user_schemas import (
    UserCreateRequestSchema,
    UserUpdateRequestSchema,
    UserDetailSchema,
    UserListResponseSchema,
    UserBriefSchema,
    RoleBriefSchema
)
from ...schemas import ErrorResponseSchema
from src.extensions import apispec
from .routes import admin_bp

@admin_bp.route('/users', methods=['GET'])
@token_required
@require_permission('MANAGE_USERS')
def get_users():
    """
    ---
    get:
      summary: List all users (admin, MANAGE_USERS permission required)
      tags:
        - Admin - Users
      responses:
        200:
          description: List of users
          content:
            application/json:
              schema: UserListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    users, msg, status = UserService.get_all_users(request.args)
    schema = UserDetailSchema(many=True)
    return jsonify({"users": schema.dump(users)}), status

@admin_bp.route('/users', methods=['POST'])
@token_required
@require_permission('MANAGE_USERS')
def create_user():
    """
    ---
    post:
      summary: Create a new user (admin, MANAGE_USERS permission required)
      tags:
        - Admin - Users
      requestBody:
        required: true
        content:
          application/json:
            schema: UserCreateRequestSchema
      responses:
        201:
          description: User created
          content:
            application/json:
              schema: UserDetailSchema
        400:
          description: Bad request
        409:
          description: Conflict
    """
    data = request.get_json()
    user, msg, status = UserService.create_user(data)
    if not user:
        return jsonify({"error": msg}), status
    schema = UserDetailSchema()
    return jsonify(schema.dump(user)), status

@admin_bp.route('/users/<int:user_id>', methods=['GET'])
@token_required
@require_permission('MANAGE_USERS')
def get_user(user_id):
    """
    ---
    get:
      summary: Get a user by ID (admin, MANAGE_USERS permission required)
      tags:
        - Admin - Users
      parameters:
        - in: path
          name: user_id
          schema:
            type: integer
          required: true
      responses:
        200:
          description: User details
          content:
            application/json:
              schema: UserDetailSchema
        404:
          description: Not found
    """
    user, msg, status = UserService.get_user_by_id(user_id)
    if not user:
        return jsonify({"error": msg}), status
    schema = UserDetailSchema()
    return jsonify(schema.dump(user)), status

@admin_bp.route('/users/<int:user_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_USERS')
def update_user(user_id):
    """
    ---
    patch:
      summary: Update a user by ID (admin, MANAGE_USERS permission required)
      tags:
        - Admin - Users
      parameters:
        - in: path
          name: user_id
          schema:
            type: integer
          required: true
      requestBody:
        required: true
        content:
          application/json:
            schema: UserUpdateRequestSchema
      responses:
        200:
          description: User updated
          content:
            application/json:
              schema: UserDetailSchema
        400:
          description: Bad request
        404:
          description: Not found
    """
    data = request.get_json()
    user, msg, status = UserService.update_user(user_id, data)
    if not user:
        return jsonify({"error": msg}), status
    schema = UserDetailSchema()
    return jsonify(schema.dump(user)), status

@admin_bp.route('/users/<int:user_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_USERS')
def delete_user(user_id):
    """
    ---
    delete:
      summary: Delete a user by ID (admin, MANAGE_USERS permission required)
      tags:
        - Admin - Users
      parameters:
        - in: path
          name: user_id
          schema:
            type: integer
          required: true
      responses:
        204:
          description: User deleted
        404:
          description: Not found
        409:
          description: Conflict (user has associated records)
    """
    deleted, msg, status = UserService.delete_user(user_id)
    if not deleted:
        return jsonify({"error": msg}), status
    return '', 204
</file>

<file path="fbo-launchpad-backend/src/routes/aircraft_routes.py">
from flask import Blueprint, request, jsonify
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services.aircraft_service import AircraftService
from ..schemas.aircraft_schemas import (
    AircraftCreateSchema,
    AircraftUpdateSchema,
    AircraftResponseSchema,
    AircraftListSchema,
    ErrorResponseSchema
)

aircraft_bp = Blueprint('aircraft_bp', __name__, url_prefix='/api/aircraft')

@aircraft_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_AIRCRAFT')
def list_aircraft():
    """Get all aircraft (VIEW_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    responses:
      200:
        description: Aircraft list
        content:
          application/json:
            schema: AircraftListSchema
    """
    filters = {}
    if 'customer_id' in request.args:
        filters['customer_id'] = request.args.get('customer_id', type=int)
    aircraft, message, status_code = AircraftService.get_all_aircraft(filters)
    return jsonify({
        "message": message,
        "aircraft": [AircraftResponseSchema().dump(a) for a in aircraft]
    }), status_code

@aircraft_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def create_aircraft():
    """Create an aircraft (MANAGE_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: AircraftCreateSchema
    responses:
      201:
        description: Aircraft created
        content:
          application/json:
            schema: AircraftResponseSchema
    """
    schema = AircraftCreateSchema()
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    aircraft, message, status_code = AircraftService.create_aircraft(data)
    if aircraft:
        return jsonify({"message": message, "aircraft": AircraftResponseSchema().dump(aircraft)}), status_code
    else:
        return jsonify({"error": message}), status_code

@aircraft_bp.route('/<string:tail_number>', methods=['GET'])
@token_required
@require_permission('VIEW_AIRCRAFT')
def get_aircraft(tail_number):
    """Get an aircraft by tail number (VIEW_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: tail_number
        schema:
          type: string
        required: true
        description: Tail number
    responses:
      200:
        description: Aircraft found
        content:
          application/json:
            schema: AircraftResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    aircraft, message, status_code = AircraftService.get_aircraft_by_tail(tail_number)
    if aircraft:
        return jsonify({"message": message, "aircraft": AircraftResponseSchema().dump(aircraft)}), status_code
    else:
        return jsonify({"error": message}), status_code

@aircraft_bp.route('/<string:tail_number>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def update_aircraft(tail_number):
    """Update an aircraft (MANAGE_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: tail_number
        schema:
          type: string
        required: true
        description: Tail number
    requestBody:
      required: true
      content:
        application/json:
          schema: AircraftUpdateSchema
    responses:
      200:
        description: Aircraft updated
        content:
          application/json:
            schema: AircraftResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = AircraftUpdateSchema(partial=True)
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    aircraft, message, status_code = AircraftService.update_aircraft(tail_number, data)
    if aircraft:
        return jsonify({"message": message, "aircraft": AircraftResponseSchema().dump(aircraft)}), status_code
    else:
        return jsonify({"error": message}), status_code

@aircraft_bp.route('/<string:tail_number>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def delete_aircraft(tail_number):
    """Delete an aircraft (MANAGE_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: tail_number
        schema:
          type: string
        required: true
        description: Tail number
    responses:
      200:
        description: Aircraft deleted
        content:
          application/json:
            schema:
              type: object
              properties:
                message:
                  type: string
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    success, message, status_code = AircraftService.delete_aircraft(tail_number)
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="fbo-launchpad-backend/src/routes/customer_routes.py">
from flask import Blueprint, request, jsonify
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services.customer_service import CustomerService
from ..schemas.customer_schemas import (
    CustomerCreateSchema,
    CustomerUpdateSchema,
    CustomerResponseSchema,
    CustomerListSchema,
    ErrorResponseSchema
)

customer_bp = Blueprint('customer_bp', __name__, url_prefix='/api/customers')

@customer_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_CUSTOMERS')
def list_customers():
    """Get all customers (VIEW_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    responses:
      200:
        description: Customer list
        content:
          application/json:
            schema: CustomerListSchema
    """
    customers, message, status_code = CustomerService.get_all_customers()
    return jsonify({
        "message": message,
        "customers": [CustomerResponseSchema().dump(c) for c in customers]
    }), status_code

@customer_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def create_customer():
    """Create a customer (MANAGE_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: CustomerCreateSchema
    responses:
      201:
        description: Customer created
        content:
          application/json:
            schema: CustomerResponseSchema
    """
    schema = CustomerCreateSchema()
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    customer, message, status_code = CustomerService.create_customer(data)
    if customer:
        return jsonify({"message": message, "customer": CustomerResponseSchema().dump(customer)}), status_code
    else:
        return jsonify({"error": message}), status_code

@customer_bp.route('/<int:customer_id>', methods=['GET'])
@token_required
@require_permission('VIEW_CUSTOMERS')
def get_customer(customer_id):
    """Get a customer by ID (VIEW_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: customer_id
        schema:
          type: integer
        required: true
        description: Customer ID
    responses:
      200:
        description: Customer found
        content:
          application/json:
            schema: CustomerResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    customer, message, status_code = CustomerService.get_customer_by_id(customer_id)
    if customer:
        return jsonify({"message": message, "customer": CustomerResponseSchema().dump(customer)}), status_code
    else:
        return jsonify({"error": message}), status_code

@customer_bp.route('/<int:customer_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def update_customer(customer_id):
    """Update a customer (MANAGE_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: customer_id
        schema:
          type: integer
        required: true
        description: Customer ID
    requestBody:
      required: true
      content:
        application/json:
          schema: CustomerUpdateSchema
    responses:
      200:
        description: Customer updated
        content:
          application/json:
            schema: CustomerResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = CustomerUpdateSchema(partial=True)
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    customer, message, status_code = CustomerService.update_customer(customer_id, data)
    if customer:
        return jsonify({"message": message, "customer": CustomerResponseSchema().dump(customer)}), status_code
    else:
        return jsonify({"error": message}), status_code

@customer_bp.route('/<int:customer_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def delete_customer(customer_id):
    """Delete a customer (MANAGE_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: customer_id
        schema:
          type: integer
        required: true
        description: Customer ID
    responses:
      200:
        description: Customer deleted
        content:
          application/json:
            schema:
              type: object
              properties:
                message:
                  type: string
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    success, message, status_code = CustomerService.delete_customer(customer_id)
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="fbo-launchpad-backend/src/routes/fuel_truck_routes.py">
from flask import Blueprint, request, jsonify, g
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services import FuelTruckService
from ..schemas import (
    FuelTruckListResponseSchema,
    FuelTruckCreateRequestSchema,
    FuelTruckCreateResponseSchema,
    FuelTruckSchema,
    ErrorResponseSchema
)

# Create the blueprint for fuel truck routes
truck_bp = Blueprint('truck_bp', __name__, url_prefix='/api/fuel-trucks')

@truck_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_TRUCKS')
def get_fuel_trucks():
    """Get a list of fuel trucks.
    Requires VIEW_TRUCKS permission. Supports filtering by active status.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: query
        name: is_active
        schema:
          type: string
          enum: ['true', 'false']
        required: false
        description: Filter trucks by active status ('true' or 'false')
    responses:
      200:
        description: List of fuel trucks retrieved successfully
        content:
          application/json:
            schema: FuelTruckListResponseSchema
      400:
        description: Bad Request (e.g., invalid filter value)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Extract filter parameters from request.args
    filters = {
        'is_active': request.args.get('is_active', None, type=str)
    }
    filters = {k: v for k, v in filters.items() if v is not None}

    # Call FuelTruckService to get trucks with filters
    trucks, message, status_code = FuelTruckService.get_trucks(filters=filters)

    if trucks is not None:
        trucks_list = [truck.to_dict() for truck in trucks]
        response = {
            "message": message,
            "fuel_trucks": trucks_list
        }
        return jsonify(response), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_TRUCKS')
def create_fuel_truck():
    """Create a new fuel truck.
    Requires MANAGE_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelTruckCreateRequestSchema
    responses:
      201:
        description: Fuel truck created successfully
        content:
          application/json:
            schema: FuelTruckCreateResponseSchema
      400:
        description: Bad Request (e.g., validation error, duplicate truck number)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Validate request data
    schema = FuelTruckCreateRequestSchema()
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400

    # Call service to create truck
    truck, message, status_code = FuelTruckService.create_truck(data)

    if truck is not None:
        response = {
            "message": message,
            "fuel_truck": FuelTruckSchema().dump(truck)
        }
        return jsonify(response), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/<int:truck_id>', methods=['GET'])
@token_required
@require_permission('VIEW_TRUCKS')
def get_fuel_truck(truck_id):
    """Get a fuel truck by ID.
    Requires VIEW_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: truck_id
        schema:
          type: integer
        required: true
        description: ID of the fuel truck to retrieve
    responses:
      200:
        description: Fuel truck retrieved successfully
        content:
          application/json:
            schema: FuelTruckSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel truck not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    truck, message, status_code = FuelTruckService.get_truck_by_id(truck_id)
    if truck is not None:
        return jsonify({
            "message": message,
            "fuel_truck": FuelTruckSchema().dump(truck)
        }), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/<int:truck_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_TRUCKS')
def update_fuel_truck(truck_id):
    """Update a fuel truck.
    Requires MANAGE_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: truck_id
        schema:
          type: integer
        required: true
        description: ID of the fuel truck to update
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelTruckCreateRequestSchema  # Reuse for simplicity
    responses:
      200:
        description: Fuel truck updated successfully
        content:
          application/json:
            schema: FuelTruckSchema
      400:
        description: Bad Request (validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel truck not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = FuelTruckCreateRequestSchema(partial=True)
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    truck, message, status_code = FuelTruckService.update_truck(truck_id, data)
    if truck is not None:
        return jsonify({
            "message": message,
            "fuel_truck": FuelTruckSchema().dump(truck)
        }), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/<int:truck_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_TRUCKS')
def delete_fuel_truck(truck_id):
    """Delete a fuel truck by ID.
    Requires MANAGE_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: truck_id
        schema:
          type: integer
        required: true
        description: ID of the fuel truck to delete
    responses:
      200:
        description: Fuel truck deleted successfully
      401:
        description: Unauthorized
      403:
        description: Forbidden (missing permission)
      404:
        description: Fuel truck not found
      500:
        description: Server error
    """
    success, message, status_code = FuelTruckService.delete_truck(truck_id)
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="fbo-launchpad-backend/src/routes/user_routes.py">
from flask import Blueprint, request, jsonify, g
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services.user_service import UserService
from marshmallow import ValidationError
from ..schemas import (
    UserCreateRequestSchema,
    UserUpdateRequestSchema,
    UserResponseSchema,
    UserListResponseSchema,
    ErrorResponseSchema
)

# Create blueprint for user routes
user_bp = Blueprint('user_bp', __name__, url_prefix='/api/users')

@user_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_USERS')
def get_users():
    """Get a list of users.
    Requires VIEW_USERS permission. Supports filtering by 'role' and 'is_active'.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: query
        name: role
        schema:
          type: string
          enum: [ADMIN, CSR, LST]
        required: false
        description: Filter users by role (case-insensitive)
      - in: query
        name: is_active
        schema:
          type: string
          enum: ['true', 'false']
        required: false
        description: Filter users by active status ('true' or 'false')
    responses:
      200:
        description: List of users retrieved successfully
        content:
          application/json:
            schema: UserListResponseSchema
      400:
        description: Bad Request (e.g., invalid filter value)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Extract filter parameters from request.args
    filters = {
        'role': request.args.get('role', None, type=str),
        'is_active': request.args.get('is_active', None, type=str)  # Keep as string, service handles conversion
    }
    # Remove None values so service doesn't process empty filters unnecessarily
    filters = {k: v for k, v in filters.items() if v is not None}
    
    # Call the service method
    users, message, status_code = UserService.get_users(filters=filters)
    
    # Handle the response
    if users is not None:
        # Serialize the list of user objects, excluding sensitive fields
        users_list = []
        for user in users:
            users_list.append({
                "id": user.id,
                "name": user.username,
                "email": user.email,
                "role": user.role.value,  # Use enum value
                "is_active": user.is_active,
                "created_at": user.created_at.isoformat()
                # DO NOT INCLUDE user.hashed_password
            })
        
        # Construct the final JSON response
        response = {
            "message": message,
            "users": users_list
        }
        return jsonify(response), status_code  # Use status_code from service (should be 200)
    else:
        # Return the error message and status code provided by the service
        return jsonify({"error": message}), status_code  # Use status_code from service (e.g., 400, 500)

@user_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_USERS')
def create_user():
    """Create a new user.
    Requires MANAGE_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: UserCreateRequestSchema
    responses:
      201:
        description: User created successfully
        content:
          application/json:
            schema: UserResponseSchema
      400:
        description: Bad Request (e.g., missing fields, validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      409:
        description: Conflict (e.g., email already exists)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    try:
        # Load and validate request data
        schema = UserCreateRequestSchema()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
            
        try:
            data = schema.load(data)
        except ValidationError as e:
            return jsonify({
                "error": "Validation error",
                "details": e.messages
            }), 400
        
        # Create user
        user, message, status_code = UserService.create_user(data)
        
        if user is not None:
            # Return serialized user data
            return jsonify({
                "message": message,
                "user": {
                    "id": user.id,
                    "name": user.username,
                    "email": user.email,
                    "role": user.role.value,
                    "is_active": user.is_active,
                    "created_at": user.created_at.isoformat()
                }
            }), status_code
        else:
            return jsonify({"error": message}), status_code
            
    except Exception as e:
        return jsonify({
            "error": "Internal server error",
            "details": str(e)
        }), 500

@user_bp.route('/<int:user_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_USERS')
def update_user(user_id):
    """Update a user.
    Requires MANAGE_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: user_id
        schema:
          type: integer
        required: true
        description: ID of user to update
    requestBody:
      required: true
      content:
        application/json:
          schema: UserUpdateRequestSchema
    responses:
      200:
        description: User updated successfully
        content:
          application/json:
            schema: UserResponseSchema
      400:
        description: Bad Request (e.g., validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: User not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    try:
        # Load and validate request data
        schema = UserUpdateRequestSchema()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
            
        try:
            data = schema.load(data)
        except ValidationError as e:
            return jsonify({
                "error": "Validation error",
                "details": e.messages
            }), 400
        
        # Update user
        user, message, status_code = UserService.update_user(user_id, data)
        
        if user is not None:
            # Return serialized user data
            return jsonify({
                "message": message,
                "user": {
                    "id": user.id,
                    "name": user.username,
                    "email": user.email,
                    "role": user.role.value,
                    "is_active": user.is_active,
                    "created_at": user.created_at.isoformat()
                }
            }), status_code
        else:
            return jsonify({"error": message}), status_code
            
    except Exception as e:
        return jsonify({
            "error": "Internal server error",
            "details": str(e)
        }), 500

@user_bp.route('/<int:user_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_USERS')
def delete_user(user_id):
    """Delete a user.
    Requires MANAGE_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: user_id
        schema:
          type: integer
        required: true
        description: ID of user to delete
    responses:
      200:
        description: User deleted successfully
      401:
        description: Unauthorized
      403:
        description: Forbidden (missing permission)
      404:
        description: User not found
      500:
        description: Server error
    """
    # Call service to delete user
    success, message, status_code = UserService.delete_user(user_id)
    
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code

@user_bp.route('/<int:user_id>', methods=['GET'])
@token_required
@require_permission('VIEW_USERS')
def get_user(user_id):
    """Get a user by ID.
    Requires VIEW_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: user_id
        schema:
          type: integer
        required: true
        description: ID of user to retrieve
    responses:
      200:
        description: User retrieved successfully
        content:
          application/json:
            schema: UserResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: User not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Call service to get user
    user, message, status_code = UserService.get_user_by_id(user_id)
    
    if user is not None:
        return jsonify({
            "message": message,
            "user": {
                "id": user.id,
                "name": user.username,
                "email": user.email,
                "role": user.role.value,
                "is_active": user.is_active,
                "created_at": user.created_at.isoformat()
            }
        }), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="fbo-launchpad-backend/src/schemas/admin_schemas.py">
from marshmallow import Schema, fields

class AdminAircraftSchema(Schema):
    tail_number = fields.String(required=True)
    aircraft_type = fields.String()
    customer_id = fields.Integer(allow_none=True)

class AdminAircraftListResponseSchema(Schema):
    aircraft = fields.List(fields.Nested(AdminAircraftSchema))

class AdminCustomerSchema(Schema):
    id = fields.Integer(required=True)
    name = fields.String(required=True)

class AdminCustomerListResponseSchema(Schema):
    customers = fields.List(fields.Nested(AdminCustomerSchema))

class ErrorResponseSchema(Schema):
    message = fields.String(required=True)
    code = fields.Integer()
</file>

<file path="fbo-launchpad-backend/src/schemas/aircraft_schemas.py">
from marshmallow import Schema, fields

class AircraftCreateSchema(Schema):
    tail_number = fields.String(required=True)
    aircraft_type = fields.String(required=False)
    customer_id = fields.Integer(required=False, allow_none=True)

class AircraftUpdateSchema(Schema):
    aircraft_type = fields.String(required=False)
    customer_id = fields.Integer(required=False, allow_none=True)

class AircraftResponseSchema(Schema):
    tail_number = fields.String()
    aircraft_type = fields.String()
    customer_id = fields.Integer(allow_none=True)

class AircraftListSchema(Schema):
    message = fields.String()
    aircraft = fields.List(fields.Nested(AircraftResponseSchema))

class ErrorResponseSchema(Schema):
    error = fields.String()
    details = fields.Raw(required=False)
</file>

<file path="fbo-launchpad-backend/src/schemas/customer_schemas.py">
from marshmallow import Schema, fields

class CustomerCreateSchema(Schema):
    name = fields.String(required=True)

class CustomerUpdateSchema(Schema):
    name = fields.String(required=False)

class CustomerResponseSchema(Schema):
    id = fields.Integer()
    name = fields.String()

class CustomerListSchema(Schema):
    message = fields.String()
    customers = fields.List(fields.Nested(CustomerResponseSchema))

class ErrorResponseSchema(Schema):
    error = fields.String()
    details = fields.Raw(required=False)
</file>

<file path="fbo-launchpad-backend/src/schemas/fuel_order_schemas.py">
from marshmallow import Schema, fields, validate, pre_load
from ..models.fuel_order import FuelOrderStatus
from .auth_schemas import ErrorResponseSchema

# --- Schemas for Payloads ---

class FuelOrderBaseSchema(Schema):
    # Common fields, adjust required/optional based on context
    tail_number = fields.Str(required=True, validate=validate.Length(max=20))
    customer_id = fields.Int(required=False, allow_none=True)
    fuel_type = fields.Str(required=True, validate=validate.Length(max=50))
    additive_requested = fields.Bool(load_default=False)
    requested_amount = fields.Decimal(required=False, allow_none=True, places=2)
    assigned_lst_user_id = fields.Int(required=True)
    assigned_truck_id = fields.Int(required=True)
    location_on_ramp = fields.Str(required=False, allow_none=True, validate=validate.Length(max=100))
    csr_notes = fields.Str(required=False, allow_none=True)

class FuelOrderCreateRequestSchema(FuelOrderBaseSchema):
    """
    Request schema for creating a fuel order. Allows assigned_lst_user_id to be -1 for auto-assign (the backend will select the least busy active LST).
    """
    assigned_lst_user_id = fields.Int(required=True, metadata={"description": "Set to -1 to auto-assign the least busy LST."})

class FuelOrderUpdateRequestSchema(Schema): # For potential future PUT/PATCH
     # Define fields allowed for update, likely optional
     pass

class FuelOrderStatusUpdateRequestSchema(Schema):
    status = fields.Str(required=True, validate=validate.OneOf([s.name for s in FuelOrderStatus]))

    # Convert incoming status string to uppercase before validation/loading
    @pre_load
    def uppercase_status(self, data, **kwargs):
        if 'status' in data and isinstance(data['status'], str):
            data['status'] = data['status'].upper()
        return data

class FuelOrderCompleteRequestSchema(Schema):
    start_meter_reading = fields.Decimal(required=True, places=2)
    end_meter_reading = fields.Decimal(required=True, places=2)
    lst_notes = fields.Str(required=False, allow_none=True)

# --- Schemas for Responses ---

class OrderStatusCountsSchema(Schema):
    pending = fields.Int(dump_only=True)
    in_progress = fields.Int(dump_only=True)
    completed = fields.Int(dump_only=True)

class OrderStatusCountsResponseSchema(Schema):
    """
    Response schema for fuel order status counts endpoint.
    """
    message = fields.Str(dump_only=True)
    counts = fields.Nested(OrderStatusCountsSchema, dump_only=True)


class FuelOrderResponseSchema(Schema):
    # Full representation of a FuelOrder
    id = fields.Int(dump_only=True)
    status = fields.Enum(FuelOrderStatus, by_value=True, dump_only=True) # Dump enum value
    tail_number = fields.Str(dump_only=True)
    customer_id = fields.Int(dump_only=True, allow_none=True)
    fuel_type = fields.Str(dump_only=True)
    additive_requested = fields.Bool(dump_only=True)
    requested_amount = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True) # Dump Decimal as string
    assigned_lst_user_id = fields.Int(dump_only=True, allow_none=True)
    assigned_truck_id = fields.Int(dump_only=True, allow_none=True)
    location_on_ramp = fields.Str(dump_only=True, allow_none=True)
    csr_notes = fields.Str(dump_only=True, allow_none=True)
    start_meter_reading = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True)
    end_meter_reading = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True)
    calculated_gallons_dispensed = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True)
    lst_notes = fields.Str(dump_only=True, allow_none=True)
    created_at = fields.DateTime(dump_only=True)
    dispatch_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    acknowledge_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    en_route_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    fueling_start_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    completion_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    reviewed_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    reviewed_by_csr_user_id = fields.Int(dump_only=True, allow_none=True)

class FuelOrderBriefResponseSchema(Schema): # For list view
    # Subset of fields for list responses
    id = fields.Int(dump_only=True)
    status = fields.Enum(FuelOrderStatus, by_value=True, dump_only=True)
    tail_number = fields.Str(dump_only=True)
    assigned_lst_user_id = fields.Int(dump_only=True, allow_none=True)
    assigned_truck_id = fields.Int(dump_only=True, allow_none=True)
    created_at = fields.DateTime(dump_only=True)

class FuelOrderCreateResponseSchema(Schema):
    message = fields.Str(dump_only=True)
    fuel_order = fields.Nested(FuelOrderResponseSchema, dump_only=True) # Return full details on create

class FuelOrderUpdateResponseSchema(Schema): # For status, complete, review
    message = fields.Str(dump_only=True)
    fuel_order = fields.Nested(FuelOrderResponseSchema, dump_only=True) # Return updated details

class PaginationSchema(Schema):
    page = fields.Int(dump_only=True)
    per_page = fields.Int(dump_only=True)
    total_pages = fields.Int(dump_only=True)
    total_items = fields.Int(dump_only=True)
    has_next = fields.Bool(dump_only=True)
    has_prev = fields.Bool(dump_only=True)

class FuelOrderListResponseSchema(Schema):
    message = fields.Str(dump_only=True)
    fuel_orders = fields.List(fields.Nested(FuelOrderBriefResponseSchema), dump_only=True) # Use brief schema for list
    pagination = fields.Nested(PaginationSchema, dump_only=True)
</file>

<file path="fbo-launchpad-backend/src/schemas/fuel_truck_schemas.py">
from marshmallow import Schema, fields

class FuelTruckSchema(Schema):
    """Schema for serializing FuelTruck model instances."""
    id = fields.Int(dump_only=True)
    truck_number = fields.Str(required=True)
    fuel_type = fields.Str(required=True)
    capacity = fields.Decimal(required=True, places=2)
    current_meter_reading = fields.Decimal(required=True, places=2)
    is_active = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

class FuelTruckCreateRequestSchema(Schema):
    """Schema for validating fuel truck creation requests."""
    truck_number = fields.Str(required=True)
    fuel_type = fields.Str(required=True)
    capacity = fields.Decimal(required=True, places=2)
    current_meter_reading = fields.Decimal(required=False, places=2, load_default=0)

class FuelTruckUpdateRequestSchema(Schema):
    """Schema for validating fuel truck update requests (PATCH). All fields optional."""
    truck_number = fields.Str(required=False)
    fuel_type = fields.Str(required=False)
    capacity = fields.Decimal(required=False, places=2)
    current_meter_reading = fields.Decimal(required=False, places=2)
    is_active = fields.Bool(required=False)

class FuelTruckCreateResponseSchema(Schema):
    """Schema for the fuel truck creation response."""
    message = fields.Str(dump_only=True)
    fuel_truck = fields.Nested(FuelTruckSchema, dump_only=True)

class FuelTruckListResponseSchema(Schema):
    """Schema for the fuel trucks list endpoint response."""
    message = fields.Str(dump_only=True)
    fuel_trucks = fields.List(fields.Nested(FuelTruckSchema), dump_only=True)
</file>

<file path="fbo-launchpad-backend/src/schemas/permission_schemas.py">
from marshmallow import Schema, fields

class PermissionSchema(Schema):
    """Schema for permission responses."""
    id = fields.Integer(dump_only=True)
    name = fields.String(dump_only=True)
    description = fields.String(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="fbo-launchpad-backend/src/schemas/role_schemas.py">
from marshmallow import Schema, fields

class RoleSchema(Schema):
    """Schema for role responses."""
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True)
    description = fields.String(required=False, allow_none=True)
    created_at = fields.DateTime(dump_only=True)

class RoleCreateRequestSchema(Schema):
    """Schema for role creation requests."""
    name = fields.String(required=True)
    description = fields.String(required=False, allow_none=True)

class RoleUpdateRequestSchema(Schema):
    """Schema for role update requests."""
    name = fields.String(required=False)
    description = fields.String(required=False, allow_none=True)

class RoleListResponseSchema(Schema):
    """Schema for role list responses."""
    message = fields.String(required=True)
    roles = fields.Nested(RoleSchema, many=True, required=True)

class RoleAssignPermissionRequestSchema(Schema):
    """Schema for assigning a permission to a role."""
    permission_id = fields.Integer(required=True)
</file>

<file path="fbo-launchpad-backend/src/schemas/user_schemas.py">
from marshmallow import Schema, fields, validate

class RoleBriefSchema(Schema):
    """Brief schema for role information in user responses."""
    id = fields.Integer()
    name = fields.String()

class UserCreateRequestSchema(Schema):
    """Schema for user creation requests."""
    email = fields.Email(required=True)
    password = fields.String(required=True, load_only=True, validate=validate.Length(min=8))
    role_ids = fields.List(fields.Integer(), required=True)
    name = fields.String(required=False)
    is_active = fields.Boolean(required=False)

class UserUpdateRequestSchema(Schema):
    """Schema for user update requests."""
    name = fields.String(required=False)
    role_ids = fields.List(fields.Integer(), required=False)
    is_active = fields.Boolean(required=False)
    password = fields.String(required=False, load_only=True, validate=validate.Length(min=8))

class UserBriefSchema(Schema):
    """Brief schema for user information in list responses."""
    id = fields.Integer()
    name = fields.String(attribute="username")
    email = fields.Email()
    roles = fields.List(fields.Nested(RoleBriefSchema))
    is_active = fields.Boolean()
    created_at = fields.DateTime()

class UserDetailSchema(Schema):
    """Detailed schema for single user responses."""
    id = fields.Integer()
    name = fields.String(attribute="username")
    email = fields.Email()
    roles = fields.List(fields.Nested(RoleBriefSchema))
    is_active = fields.Boolean()
    created_at = fields.DateTime()
    updated_at = fields.DateTime()

class UserListResponseSchema(Schema):
    """Schema for list of users response."""
    message = fields.String()
    users = fields.List(fields.Nested(UserBriefSchema))

class ErrorResponseSchema(Schema):
    """Schema for error responses."""
    error = fields.String()
    details = fields.Raw(required=False)
</file>

<file path="fbo-launchpad-backend/src/services/aircraft_service.py">
from typing import Tuple, List, Optional, Dict, Any
from ..models.aircraft import Aircraft
from ..app import db

class AircraftService:
    @staticmethod
    def create_aircraft(data: Dict[str, Any]) -> Tuple[Optional[Aircraft], str, int]:
        if 'tail_number' not in data:
            return None, "Missing required field: tail_number", 400
        if Aircraft.query.filter_by(tail_number=data['tail_number']).first():
            return None, "Aircraft with this tail number already exists", 409
        try:
            aircraft = Aircraft(
                tail_number=data['tail_number'],
                aircraft_type=data.get('aircraft_type'),
                customer_id=data.get('customer_id')
            )
            db.session.add(aircraft)
            db.session.commit()
            return aircraft, "Aircraft created successfully", 201
        except Exception as e:
            db.session.rollback()
            return None, f"Error creating aircraft: {str(e)}", 500

    @staticmethod
    def get_aircraft_by_tail(tail_number: str) -> Tuple[Optional[Aircraft], str, int]:
        try:
            aircraft = Aircraft.query.get(tail_number)
            if not aircraft:
                return None, f"Aircraft with tail number {tail_number} not found", 404
            return aircraft, "Aircraft retrieved successfully", 200
        except Exception as e:
            return None, f"Error retrieving aircraft: {str(e)}", 500

    @staticmethod
    def get_all_aircraft(filters: Optional[Dict[str, Any]] = None) -> Tuple[List[Aircraft], str, int]:
        query = Aircraft.query
        if filters and 'customer_id' in filters:
            query = query.filter_by(customer_id=filters['customer_id'])
        try:
            aircraft_list = query.order_by(Aircraft.tail_number.asc()).all()
            return aircraft_list, "Aircraft list retrieved successfully", 200
        except Exception as e:
            return [], f"Error retrieving aircraft: {str(e)}", 500

    @staticmethod
    def update_aircraft(tail_number: str, update_data: Dict[str, Any]) -> Tuple[Optional[Aircraft], str, int]:
        try:
            aircraft = Aircraft.query.get(tail_number)
            if not aircraft:
                return None, f"Aircraft with tail number {tail_number} not found", 404
            if 'aircraft_type' in update_data:
                aircraft.aircraft_type = update_data['aircraft_type']
            if 'customer_id' in update_data:
                aircraft.customer_id = update_data['customer_id']
            db.session.commit()
            return aircraft, "Aircraft updated successfully", 200
        except Exception as e:
            db.session.rollback()
            return None, f"Error updating aircraft: {str(e)}", 500

    @staticmethod
    def delete_aircraft(tail_number: str) -> Tuple[bool, str, int]:
        try:
            aircraft = Aircraft.query.get(tail_number)
            if not aircraft:
                return False, f"Aircraft with tail number {tail_number} not found", 404
            db.session.delete(aircraft)
            db.session.commit()
            return True, "Aircraft deleted successfully", 200
        except Exception as e:
            db.session.rollback()
            return False, f"Error deleting aircraft: {str(e)}", 500
</file>

<file path="fbo-launchpad-backend/src/services/customer_service.py">
from typing import Tuple, List, Optional, Dict, Any
from ..models.customer import Customer
from ..app import db

class CustomerService:
    @staticmethod
    def create_customer(data: Dict[str, Any]) -> Tuple[Optional[Customer], str, int]:
        if 'name' not in data:
            return None, "Missing required field: name", 400
        if Customer.query.filter_by(name=data['name']).first():
            return None, "Customer with this name already exists", 409
        try:
            customer = Customer(
                name=data['name']
            )
            db.session.add(customer)
            db.session.commit()
            return customer, "Customer created successfully", 201
        except Exception as e:
            db.session.rollback()
            return None, f"Error creating customer: {str(e)}", 500

    @staticmethod
    def get_customer_by_id(customer_id: int) -> Tuple[Optional[Customer], str, int]:
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None, f"Customer with ID {customer_id} not found", 404
            return customer, "Customer retrieved successfully", 200
        except Exception as e:
            return None, f"Error retrieving customer: {str(e)}", 500

    @staticmethod
    def get_all_customers(filters: Optional[Dict[str, Any]] = None) -> Tuple[List[Customer], str, int]:
        query = Customer.query
        try:
            customers = query.order_by(Customer.name.asc()).all()
            return customers, "Customer list retrieved successfully", 200
        except Exception as e:
            return [], f"Error retrieving customers: {str(e)}", 500

    @staticmethod
    def update_customer(customer_id: int, update_data: Dict[str, Any]) -> Tuple[Optional[Customer], str, int]:
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None, f"Customer with ID {customer_id} not found", 404
            if 'name' in update_data:
                # Check for uniqueness
                existing = Customer.query.filter_by(name=update_data['name']).first()
                if existing and existing.id != customer_id:
                    return None, f"Customer name {update_data['name']} already exists", 400
                customer.name = update_data['name']
            db.session.commit()
            return customer, "Customer updated successfully", 200
        except Exception as e:
            db.session.rollback()
            return None, f"Error updating customer: {str(e)}", 500

    @staticmethod
    def delete_customer(customer_id: int) -> Tuple[bool, str, int]:
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return False, f"Customer with ID {customer_id} not found", 404
            db.session.delete(customer)
            db.session.commit()
            return True, "Customer deleted successfully", 200
        except Exception as e:
            db.session.rollback()
            return False, f"Error deleting customer: {str(e)}", 500
</file>

<file path="fbo-launchpad-backend/src/services/fuel_truck_service.py">
from typing import Tuple, List, Optional, Dict, Any

from ..models.fuel_truck import FuelTruck
from ..app import db

class FuelTruckService:
    """Service class for managing fuel truck operations."""

    @classmethod
    def get_trucks(cls, filters: Optional[Dict[str, Any]] = None) -> Tuple[Optional[List[FuelTruck]], str, int]:
        # ... (existing code unchanged)
        query = FuelTruck.query
        if filters:
            is_active_filter = filters.get('is_active')
            if is_active_filter is not None:
                is_active_bool = is_active_filter.lower() == 'true'
                query = query.filter(FuelTruck.is_active == is_active_bool)
        try:
            trucks = query.order_by(FuelTruck.truck_number.asc()).all()
            return trucks, "Fuel trucks retrieved successfully", 200
        except Exception as e:
            return None, f"Database error while retrieving fuel trucks: {str(e)}", 500

    @classmethod
    def create_truck(cls, truck_data: Dict[str, Any]) -> Tuple[Optional[FuelTruck], str, int]:
        # ... (existing code unchanged)
        existing_truck = FuelTruck.query.filter_by(truck_number=truck_data['truck_number']).first()
        if existing_truck:
            return None, f"Truck number {truck_data['truck_number']} already exists", 400
        try:
            new_truck = FuelTruck(
                truck_number=truck_data['truck_number'],
                fuel_type=truck_data['fuel_type'],
                capacity=truck_data['capacity'],
                current_meter_reading=truck_data.get('current_meter_reading', 0),
                is_active=True
            )
            db.session.add(new_truck)
            db.session.commit()
            return new_truck, "Fuel truck created successfully", 201
        except Exception as e:
            db.session.rollback()
            return None, f"Database error while creating fuel truck: {str(e)}", 500

    @classmethod
    def get_truck_by_id(cls, truck_id: int) -> Tuple[Optional[FuelTruck], str, int]:
        """Get a fuel truck by its ID."""
        try:
            truck = FuelTruck.query.get(truck_id)
            if not truck:
                return None, f"Fuel truck with ID {truck_id} not found", 404
            return truck, "Fuel truck retrieved successfully", 200
        except Exception as e:
            return None, f"Database error while retrieving fuel truck: {str(e)}", 500

    @classmethod
    def update_truck(cls, truck_id: int, update_data: Dict[str, Any]) -> Tuple[Optional[FuelTruck], str, int]:
        """Update a fuel truck."""
        try:
            truck = FuelTruck.query.get(truck_id)
            if not truck:
                return None, f"Fuel truck with ID {truck_id} not found", 404
            # Update fields if provided
            if 'truck_number' in update_data:
                # Check for uniqueness
                existing = FuelTruck.query.filter_by(truck_number=update_data['truck_number']).first()
                if existing and existing.id != truck_id:
                    return None, f"Truck number {update_data['truck_number']} already exists", 400
                truck.truck_number = update_data['truck_number']
            if 'fuel_type' in update_data:
                truck.fuel_type = update_data['fuel_type']
            if 'capacity' in update_data:
                truck.capacity = update_data['capacity']
            if 'current_meter_reading' in update_data:
                truck.current_meter_reading = update_data['current_meter_reading']
            if 'is_active' in update_data:
                truck.is_active = bool(update_data['is_active'])
            db.session.commit()
            return truck, "Fuel truck updated successfully", 200
        except Exception as e:
            db.session.rollback()
            return None, f"Database error while updating fuel truck: {str(e)}", 500

    @classmethod
    def delete_truck(cls, truck_id: int) -> Tuple[bool, str, int]:
        """Delete a fuel truck by ID."""
        try:
            truck = FuelTruck.query.get(truck_id)
            if not truck:
                return False, f"Fuel truck with ID {truck_id} not found", 404
            db.session.delete(truck)
            db.session.commit()
            return True, "Fuel truck deleted successfully", 200
        except Exception as e:
            db.session.rollback()
            return False, f"Database error while deleting fuel truck: {str(e)}", 500
</file>

<file path="fbo-launchpad-backend/src/services/permission_service.py">
from typing import Tuple, List, Optional
from src.app import db
from src.models import Permission
from sqlalchemy.exc import SQLAlchemyError

class PermissionService:
    """
    Stub service for permission-related operations (Phase 3).
    """

    @classmethod
    def get_all_permissions(cls) -> Tuple[Optional[List[Permission]], str, int]:
        """
        Retrieve all permissions from the database, ordered by name.

        Returns:
            Tuple containing:
            - List[Permission]: List of all Permission objects if successful, None if error
            - str: Success/error message
            - int: HTTP status code (200 for success, 500 for error)
        """
        try:
            permissions = Permission.query.order_by(Permission.name.asc()).all()
            return permissions, "Permissions retrieved successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            error_msg = f"Database error while retrieving permissions: {str(e)}"
            # Log the error here if you have a logger configured
            print(error_msg)  # Basic logging fallback
            return None, error_msg, 500
</file>

<file path="fbo-launchpad-backend/src/services/role_service.py">
from typing import Tuple, Any, List, Optional
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from src.app import db
from src.models import Role, Permission

class RoleService:
    """Service class for managing roles and their permissions."""

    @classmethod
    def get_all_roles(cls) -> Tuple[List[Role], str, int]:
        """Retrieve all roles ordered by name."""
        try:
            roles = Role.query.order_by(Role.name.asc()).all()
            return roles, "Roles retrieved successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return [], f"Database error: {str(e)}", 500

    @classmethod
    def create_role(cls, data: dict) -> Tuple[Optional[Role], str, int]:
        """Create a new role with the provided data."""
        if not data.get('name'):
            return None, "Role name is required", 400

        try:
            # Check for existing role with same name
            existing_role = Role.query.filter_by(name=data['name']).first()
            if existing_role:
                return None, f"Role with name '{data['name']}' already exists", 409

            new_role = Role(
                name=data['name'],
                description=data.get('description')
            )
            db.session.add(new_role)
            db.session.commit()
            return new_role, "Role created successfully", 201
        except IntegrityError:
            db.session.rollback()
            return None, "Role name must be unique", 409
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def get_role_by_id(cls, role_id: int) -> Tuple[Optional[Role], str, int]:
        """Retrieve a role by its ID."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404
            return role, "Role retrieved successfully", 200
        except SQLAlchemyError as e:
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def update_role(cls, role_id: int, data: dict) -> Tuple[Optional[Role], str, int]:
        """Update an existing role's information."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404

            if 'name' in data:
                # Check for duplicate name, excluding current role
                existing_role = Role.query.filter(
                    Role.name == data['name'],
                    Role.id != role_id
                ).first()
                if existing_role:
                    return None, f"Role with name '{data['name']}' already exists", 409
                role.name = data['name']

            if 'description' in data:
                role.description = data['description']

            db.session.commit()
            return role, "Role updated successfully", 200
        except IntegrityError:
            db.session.rollback()
            return None, "Role name must be unique", 409
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def delete_role(cls, role_id: int) -> Tuple[bool, str, int]:
        """Delete a role and its permission assignments."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return False, f"Role with ID {role_id} not found", 404

            # Check if any users are assigned this role
            if role.users.first():
                return False, "Cannot delete role: Users are currently assigned to this role", 409

            # Clear permission assignments
            role.permissions = []
            db.session.delete(role)
            db.session.commit()
            return True, "Role deleted successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return False, f"Database error: {str(e)}", 500

    @classmethod
    def get_role_permissions(cls, role_id: int) -> Tuple[List[Permission], str, int]:
        """Get all permissions assigned to a role."""
        try:
            role = Role.query.options(db.joinedload(Role.permissions)).get(role_id)
            if not role:
                return [], f"Role with ID {role_id} not found", 404
            
            permissions = list(role.permissions)
            return permissions, "Permissions retrieved successfully", 200
        except SQLAlchemyError as e:
            return [], f"Database error: {str(e)}", 500

    @classmethod
    def assign_permission_to_role(cls, role_id: int, permission_id: int) -> Tuple[Optional[Role], str, int]:
        """Assign a permission to a role."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404

            permission = Permission.query.get(permission_id)
            if not permission:
                return None, f"Permission with ID {permission_id} not found", 404

            # Check if permission is already assigned
            if permission in role.permissions:
                return role, "Permission already assigned to role", 200

            role.permissions.append(permission)
            db.session.commit()
            return role, "Permission assigned successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def remove_permission_from_role(cls, role_id: int, permission_id: int) -> Tuple[Optional[Role], str, int]:
        """Remove a permission from a role."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404

            permission = Permission.query.get(permission_id)
            if not permission:
                return None, f"Permission with ID {permission_id} not found", 404

            # Check if permission is actually assigned
            if permission not in role.permissions:
                return role, "Permission not assigned to role", 200

            role.permissions.remove(permission)
            db.session.commit()
            return role, "Permission removed successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500
</file>

<file path="fbo-launchpad-backend/src/services/user_service.py">
from typing import Tuple, List, Optional, Dict, Any, Set

from ..models.user import User
from ..models.role import Role
from ..extensions import db


class UserService:
    """Service class for managing user-related operations."""

    @classmethod
    def get_users(cls, filters: Optional[Dict[str, Any]] = None) -> Tuple[Optional[List[User]], str, int]:
        """Retrieve users based on specified filters.

        Args:
            filters (Optional[Dict[str, Any]]): Optional dictionary of filter parameters.
                Supported filters:
                - role_ids (List[int]): Filter by role IDs
                - is_active (bool): Filter by user active status

        Returns:
            Tuple[Optional[List[User]], str, int]: A tuple containing:
                - List of User objects if successful, None if error
                - Message describing the result
                - HTTP status code
        """
        try:
            # Initialize base query with eager loading of roles
            query = User.query.options(db.selectinload(User.roles))

            if filters:
                # Filter by role IDs
                role_ids = filters.get('role_ids')
                if role_ids:
                    if not isinstance(role_ids, list):
                        return None, "Invalid role_ids format, must be a list", 400
                    # Join with roles and filter where role.id is in the provided list
                    query = query.join(User.roles).filter(Role.id.in_(role_ids))

                # Filter by active status
                is_active_filter = filters.get('is_active')
                if is_active_filter is not None:
                    is_active_bool = str(is_active_filter).lower() == 'true'
                    query = query.filter(User.is_active == is_active_bool)

            # Default sort by username ascending
            users = query.order_by(User.username.asc()).all()
            return users, "Users retrieved successfully", 200

        except Exception as e:
            # Log the error here if you have a logger configured
            return None, f"Database error while retrieving users: {str(e)}", 500

    @classmethod
    def create_user(cls, data: Dict[str, Any]) -> Tuple[Optional[User], str, int]:
        """Create a new user.
        
        Args:
            data (Dict[str, Any]): Dictionary containing user data
                Required keys:
                - email (str): User's email address
                - password (str): User's password
                - role_ids (List[int]): List of role IDs to assign
                Optional keys:
                - name (str): User's name
                - is_active (bool): Whether user should be active (defaults to True)
                
        Returns:
            Tuple[Optional[User], str, int]: A tuple containing:
                - Created User object if successful, None if error
                - Message describing the result
                - HTTP status code
        """
        try:
            # Validate required fields
            if not all(key in data for key in ['email', 'password', 'role_ids']):
                return None, "Missing required fields: email, password, and role_ids are required", 400

            # Validate role_ids format
            role_ids = data['role_ids']
            if not isinstance(role_ids, list):
                return None, "Invalid role_ids format, must be a list", 400

            if not role_ids:  # Empty list check
                return None, "At least one role must be assigned", 400

            # Check if email already exists
            if User.query.filter_by(email=data['email']).first():
                return None, "Email already registered", 409

            # Fetch and validate roles
            roles = Role.query.filter(Role.id.in_(role_ids)).all()
            if len(roles) != len(set(role_ids)):
                found_ids = {role.id for role in roles}
                invalid_ids = set(role_ids) - found_ids
                return None, f"Invalid role IDs provided: {list(invalid_ids)}", 400

            # Create new user
            user = User(
                email=data['email'],
                username=data.get('name', data['email'].split('@')[0]),  # Default to email username
                is_active=data.get('is_active', True)  # Default to active
            )
            user.set_password(data['password'])
            user.roles = roles  # Assign roles

            db.session.add(user)
            db.session.commit()

            return user, "User created successfully", 201

        except Exception as e:
            db.session.rollback()
            return None, f"Error creating user: {str(e)}", 500

    @classmethod
    def update_user(cls, user_id: int, data: Dict[str, Any]) -> Tuple[Optional[User], str, int]:
        """Update an existing user.
        
        Args:
            user_id (int): ID of user to update
            data (Dict[str, Any]): Dictionary containing update data
                Supported keys:
                - name (str): User's name
                - role_ids (List[int]): List of role IDs to assign
                - is_active (bool): User's active status
                - password (str): User's new password (optional)
                
        Returns:
            Tuple[Optional[User], str, int]: A tuple containing:
                - Updated User object if successful, None if error
                - Message describing the result
                - HTTP status code
        """
        try:
            user = User.query.options(db.selectinload(User.roles)).get(user_id)
            if not user:
                return None, f"User with ID {user_id} not found", 404

            # Update fields if provided
            if 'name' in data:
                user.username = data['name']

            if 'role_ids' in data:
                role_ids = data['role_ids']
                if not isinstance(role_ids, list):
                    return None, "Invalid role_ids format, must be a list", 400

                if role_ids:  # If list is not empty
                    # Fetch and validate roles
                    roles = Role.query.filter(Role.id.in_(role_ids)).all()
                    if len(roles) != len(set(role_ids)):
                        found_ids = {role.id for role in roles}
                        invalid_ids = set(role_ids) - found_ids
                        return None, f"Invalid role IDs provided: {list(invalid_ids)}", 400
                    user.roles = roles
                else:
                    user.roles = []  # Clear all roles if empty list provided

            if 'is_active' in data:
                user.is_active = bool(data['is_active'])

            if 'password' in data:
                user.set_password(data['password'])

            db.session.commit()
            return user, "User updated successfully", 200

        except Exception as e:
            db.session.rollback()
            return None, f"Error updating user: {str(e)}", 500

    @classmethod
    def delete_user(cls, user_id: int) -> Tuple[bool, str, int]:
        """Soft delete a user by setting is_active to False.
        
        Args:
            user_id (int): ID of user to delete
            
        Returns:
            Tuple[bool, str, int]: A tuple containing:
                - True if successful, False if error
                - Message describing the result
                - HTTP status code
        """
        try:
            user = User.query.get(user_id)
            if not user:
                return False, f"User with ID {user_id} not found", 404

            user.is_active = False
            db.session.commit()
            return True, "User deactivated successfully", 200

        except Exception as e:
            db.session.rollback()
            return False, f"Error deactivating user: {str(e)}", 500

    @classmethod
    def get_user_by_id(cls, user_id: int) -> Tuple[Optional[User], str, int]:
        """Get a user by ID.
        
        Args:
            user_id (int): ID of user to retrieve
            
        Returns:
            Tuple[Optional[User], str, int]: A tuple containing:
                - User object if found, None if not found
                - Message describing the result
                - HTTP status code
        """
        try:
            user = User.query.options(db.selectinload(User.roles)).get(user_id)
            if not user:
                return None, f"User with ID {user_id} not found", 404
            return user, "User retrieved successfully", 200

        except Exception as e:
            return None, f"Error retrieving user: {str(e)}", 500
</file>

<file path="fbo-launchpad-backend/src/utils/auth.py">
from functools import wraps
from flask import jsonify, current_app
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity

def admin_required():
    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            verify_jwt_in_request()
            claims = get_jwt_identity()
            
            if claims.get('role') != 'admin':
                return jsonify({'error': 'Admin privileges required'}), 403
                
            return fn(*args, **kwargs)
        return decorator
    return wrapper

def user_required():
    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            verify_jwt_in_request()
            claims = get_jwt_identity()
            
            if not claims.get('role') in ['user', 'admin']:
                return jsonify({'error': 'User privileges required'}), 403
                
            return fn(*args, **kwargs)
        return decorator
    return wrapper
</file>

<file path="fbo-launchpad-backend/src/utils/rate_limiting.py">
from functools import wraps
from flask import request, jsonify
from datetime import datetime, timedelta
import time

# Store rate limiting state
rate_limits = {}

def rate_limit(limit=5, window=300):
    """
    Rate limiting decorator that limits the number of requests per time window.
    
    Args:
        limit (int): Maximum number of requests allowed within the window
        window (int): Time window in seconds
        
    Returns:
        decorator: Function that implements rate limiting
    """
    def decorator(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            # Get client IP
            client_ip = request.remote_addr
            
            # Get current timestamp
            now = time.time()
            
            # Initialize rate limit entry for this IP if it doesn't exist
            if client_ip not in rate_limits:
                rate_limits[client_ip] = {
                    'count': 0,
                    'reset_time': now + window
                }
                
            # Check if window has expired and reset if needed
            if now > rate_limits[client_ip]['reset_time']:
                rate_limits[client_ip] = {
                    'count': 0,
                    'reset_time': now + window
                }
                
            # Increment request count
            rate_limits[client_ip]['count'] += 1
            
            # Check if limit exceeded
            if rate_limits[client_ip]['count'] > limit:
                reset_time = datetime.fromtimestamp(rate_limits[client_ip]['reset_time'])
                retry_after = int(rate_limits[client_ip]['reset_time'] - now)
                
                return jsonify({
                    'error': 'Rate limit exceeded',
                    'retry_after': retry_after
                }), 429
                
            return f(*args, **kwargs)
        return wrapped
    return decorator

def reset_rate_limits():
    """Reset all rate limiting state (useful for testing)."""
    global rate_limits
    rate_limits = {}
</file>

<file path="fbo-launchpad-backend/src/cli.py">
import click
from flask.cli import with_appcontext
from .extensions import db

@click.command('create-admin')
@with_appcontext
def create_admin():
    """Create an admin user."""
    from .models.user import User
    from .models.role import Role
    
    # Check if admin already exists
    if User.query.filter_by(email='admin@fbolaunchpad.com').first():
        click.echo("Admin user already exists!")
        return
    
    # Get admin role
    admin_role = Role.query.filter_by(name='Administrator').first()
    if not admin_role:
        click.echo("Error: Administrator role not found!")
        return
    
    # Create new admin user
    admin = User(
        email='admin@fbolaunchpad.com',
        username='admin',
        name='Admin',
        is_active=True
    )
    admin.set_password('Admin123!')
    admin.roles = [admin_role]
    
    # Save to database
    db.session.add(admin)
    db.session.commit()
    click.echo("Admin user created successfully!")

def init_app(app):
    """Register CLI commands."""
    app.cli.add_command(create_admin)
</file>

<file path="fbo-launchpad-backend/tasks/active_Context.md">
# Active Backend Context

## Current Focus
- Backend CRUD API endpoints for Users, Fuel Trucks, Aircraft, Customers
- Permission-based access control (PBAC) schema implemented (Permission, Role, role_permissions, user_roles, User.roles)
- Static role columns/enums removed from User model
- Marshmallow validation and serialization
- Consistent error handling and OpenAPI documentation

## Entities & Endpoints
- **Users**: Full CRUD, soft delete, activation, role enforcement
- **Fuel Trucks**: Full CRUD, truck number uniqueness
- **Aircraft**: Full CRUD, tail number uniqueness
- **Customers**: Full CRUD, name uniqueness
- **Security**: JWT, decorators for role and active status
- **Docs**: OpenAPI docs for all endpoints

## Security & Validation Patterns
- All CUD operations require Admin role
- JWT required for all endpoints
- Input validated with Marshmallow schemas
- Consistent error/message response structure
- Sensitive fields excluded from responses

## Known Issues
- No pagination or search on list endpoints
- Unit test coverage incomplete
- Some endpoints missing frontend integration

## Status Update
- Admin CRUD API endpoints for Aircraft and Customers are now implemented, documented, and available for frontend integration/testing.
- PBAC migration script updated: Permission, Role, user_roles, role_permissions tables created, User.role column removed. **Permissions table is now seeded with 21 finalized permissions via bulk_insert in upgrade; downgrade removes these records before dropping the table.** Migration script inspected and verified for correctness (upgrade/downgrade, data seeding).
- **Step 5 complete:** Migration now also seeds default roles (System Administrator, Customer Service Representative, Line Service Technician) and assigns the correct permissions to each via the role_permissions table. This ensures baseline access for user migration in the next step. Migration script reviewed for correctness and reversibility.
- **Step 6 complete:** Migration script now migrates all existing users to the new default roles based on their previous role assignment. Old users.role values are mapped to new role names and inserted into user_roles. Downgrade deletes all user_roles links before dropping the table. This preserves user access during PBAC transition.
- **Step 7 complete (2025-05-04):** Alembic migration script applied successfully using `flask db upgrade`. All schema changes (permissions, roles, role_permissions, user_roles tables) and data seeding/migration logic executed without error. Users migrated to new user_roles table, old users.role column removed. Migration ordering and session/table definition issues encountered and resolved (see error documentation). **PBAC Phase 1 is now complete.**
- **Step 8 complete (2025-05-05):** User.has_permission(permission_name) method implemented in src/models/user.py. This enables efficient permission checks for users based on their roles and is ready for use in new authorization logic (decorators, etc.).
- **Step 9 complete (2025-05-06):** @require_permission(permission_name) decorator implemented in src/utils/decorators.py, replacing @require_role. Decorator uses g.current_user.has_permission(permission_name) and returns 403/500 as appropriate. Old @require_role removed. Next: Refactor routes to use new decorator and update tests.
- PBAC Phase 2 Step 10 complete: All route handlers now use @require_permission with correct permission names, all redundant role checks removed, and docstrings updated. Backend authorization logic overhaul is complete. API docs may need APIDog update if docstrings changed significantly.
- **Step 11 complete (2025-05-08):** Implemented complete business logic for `RoleService` class with all required static methods for managing roles and their permissions. Service includes comprehensive error handling, input validation, and proper database transaction management. All methods follow consistent return pattern and are ready for integration with admin routes.
- **Step 12 complete (2025-05-09):** Implemented `get_all_permissions` static method in `PermissionService` class. Method retrieves all permissions ordered by name, includes proper error handling with SQLAlchemy exception catching and session rollback, and follows the consistent return pattern (data/None, message, status_code). Ready for integration with admin routes.
- **Step 13 complete (2025-05-10):** Implemented complete RESTful API endpoints in `src/routes/admin/role_admin_routes.py` for managing Roles and their Permissions. All endpoints are secured with `@require_permission('MANAGE_ROLES')`, use proper request validation and response serialization via Marshmallow schemas, and are fully documented with OpenAPI specifications. The routes are connected to the `RoleService` methods and follow the consistent error handling pattern.
- **Step 14 complete (2025-05-11):** Implemented Flask route handler in `src/routes/admin/permission_admin_routes.py` for listing all available system Permissions. Created `PermissionListResponseSchema` for consistent response serialization, secured endpoint with `@require_permission('VIEW_PERMISSIONS')`, connected to `PermissionService.get_all_permissions()` method, and added OpenAPI documentation. Ready for frontend integration via APIDog swagger.json import.
- **Step 15 complete (2025-05-12):** Refactored `UserService` class to fully support PBAC's many-to-many relationship between Users and Roles. All methods (`create_user`, `update_user`, `get_users`, `get_user_by_id`) now handle role_ids lists, validate role existence, and use SQLAlchemy's eager loading to prevent N+1 queries. The old UserRole enum has been completely removed, and proper error messages are in place for invalid role assignments. This completes the service-layer updates for PBAC Phase 3.
- **Step 16 complete (2025-05-13):** Implemented complete Admin User Management API route handlers in `src/routes/admin/user_admin_routes.py`. Created/updated user schemas to handle role_ids list and proper response serialization. All endpoints (`GET /`, `POST /`, `GET /<id>`, `PATCH /<id>`, `DELETE /<id>`) are secured with appropriate permissions (`VIEW_USERS` or `MANAGE_USERS`). Blueprint registered in `src/app.py` with proper URL prefix and OpenAPI documentation. Ready for frontend integration via APIDog swagger.json import.

## Next Steps
- Add pagination/search to list endpoints
- Write/complete unit and integration tests
- Integrate endpoints with frontend
- Improve error messages and documentation
- Update service and route logic to use new PBAC schema

## [2024-05-01] Refactor: LSTs can now create orders; POST /api/fuel-orders supports -1 for auto-assigning least busy LST; new GET /api/fuel-orders/stats/status-counts endpoint for dashboard; removed obsolete queue/global assign logic.
</file>

<file path="fbo-launchpad-backend/tasks/tasks_plan.md">
# Project Progress (Backend)

## Completed Features
- User authentication (JWT, password hashing, role-based access)
- Fuel Order CRUD endpoints
- User CRUD endpoints (Admin/CSR, soft delete)
- Fuel Truck CRUD endpoints
- Aircraft CRUD endpoints
- Customer CRUD endpoints
- OpenAPI/Swagger documentation for all endpoints
- Consistent error handling and validation (Marshmallow)

## Current API Entities & Endpoints
- **Users**: Create, list, retrieve, update, delete (Admin/CSR, soft delete, activation)
- **Fuel Orders**: Full CRUD, status management, CSV export
- **Fuel Trucks**: Full CRUD, truck number uniqueness
- **Aircraft**: Full CRUD, tail number uniqueness
- **Customers**: Full CRUD, name uniqueness
- **Security**: JWT, role-based decorators, active status enforcement
- **Docs**: All endpoints and schemas documented in OpenAPI

## Known Issues
- No pagination on list endpoints
- No search or advanced filtering
- Unit test coverage incomplete
- Some endpoints lack frontend integration

## Backend Refactor: Fuel Order Auto-Assign & Stats (April 26, 2025)

### Completed
- Refactored `FuelOrderService.create_fuel_order` to implement `-1` auto-assign for LSTs:
  - If `assigned_lst_user_id` is `-1`, backend selects least busy active LST (fewest active/in-progress orders).
  - If not `-1`, validates LST exists, is active, and is an LST.
  - Truck assignment logic unchanged.
- Updated `POST /api/fuel-orders` route:
  - Now allows LSTs to create orders (`@require_role` includes LST).
  - Docstring and validation updated to clarify `-1` behavior and type handling.
- Implemented `GET /api/fuel-orders/stats/status-counts` endpoint:
  - Counts orders by status group (pending, in progress, completed) for dashboard.
  - Available to CSR, ADMIN, and LST roles.
  - Registered schema and route in OpenAPI.
- Updated schemas:
  - `FuelOrderCreateRequestSchema` allows `-1` for auto-assign (with docstring/metadata).
  - `OrderStatusCountsResponseSchema` docstring clarified.
  - All schemas registered in `src/schemas/__init__.py`.
- Registered new schemas and paths in `src/app.py` for OpenAPI docs.
- Removed all obsolete code related to global auto-assign toggle and LST queue API (no longer relevant).
- **As of April 26, 2025:** `src/routes/admin/assignment_settings_routes.py` is now a pure deprecation stub (comment only, no Blueprint or routes). This fixes all NameError and lint errors from that file and confirms the global auto-assign admin API is fully removed.

### New API Behavior
- To auto-assign an LST, send `assigned_lst_user_id: -1` in POST payload.
- All roles (CSR, ADMIN, LST) can create fuel orders and view status counts.
- API docs and schemas up-to-date with new logic.

### Next Steps
- Add pagination and search to list endpoints
- Complete unit/integration test coverage
- Integrate all endpoints with frontend
- Review and improve error messages
- Document any new endpoints or changes in OpenAPI
3. Reporting features

## PBAC Overhaul (Phase 1)
### Step 4 Complete (2025-05-01):
- Alembic migration script for PBAC now seeds the permissions table with the finalized list of 21 permissions (bulk_insert in upgrade, targeted delete in downgrade).
- This ensures all system permissions are present for subsequent role/assignment steps.
- Migration script reviewed for correctness and reversibility.

### Step 5 Complete (2025-05-02):
- Alembic migration script now seeds the default roles (System Administrator, Customer Service Representative, Line Service Technician) and assigns the correct permissions to each via the role_permissions table.
- This ensures all baseline roles and permissions are present for user migration in the next step.
- Migration script reviewed for correctness, reversibility, and data integrity.

### Step 6 Complete (2025-05-03):
- Alembic migration script now migrates all existing users to the new default roles based on their previous role assignment.
- Reads old users.role value before column is dropped, maps to new role name, and inserts into user_roles association table.
- Ensures all users retain correct access after PBAC migration.
- Downgrade deletes all user_roles links before dropping table.
- Migration script reviewed for correctness, reversibility, and data integrity.

### Step 7 Complete (2025-05-04):
- Alembic migration script applied successfully using `flask db upgrade`.
- All schema changes (permissions, roles, role_permissions, user_roles tables) and data seeding/migration logic executed without error.
- Users migrated to new user_roles table, old users.role column removed.
- Migration ordering and session/table definition issues encountered and resolved (see error documentation).
- **PBAC Phase 1 is now complete.**

### Next Steps
- Assign seeded permissions to default roles in a follow-up migration or script.
- Update service and route logic to use new PBAC schema.
- Continue with PBAC Phase 2 as planned.

## PBAC Overhaul (Phase 2)
### Step 8 Complete (2025-05-05):
- Implemented User.has_permission(permission_name) method in src/models/user.py.
- This method checks if a user has a specific permission by iterating through their roles and checking each role's permissions efficiently using SQLAlchemy's filter_by.
- Ready for use by the new authorization decorator (to be implemented in Step 9).

### Step 9 Complete (2025-05-06):
- Implemented @require_permission(permission_name) decorator in src/utils/decorators.py.
- Decorator checks g.current_user.has_permission(permission_name) and returns 403/500 as appropriate.
- Old @require_role decorator removed.
- Ready for use in route protection for all endpoints requiring granular permission checks.
- Next: Refactor routes to use @require_permission and update tests accordingly.

### Step 10 Complete (2025-05-07):
- All route handlers now use @require_permission with correct permission names, all redundant role checks removed, and docstrings updated.
- Backend authorization logic overhaul is complete.
- API docs may need APIDog update if docstrings changed significantly.

## PBAC Overhaul (Phase 3)
### Step 11 Complete (2025-05-08):
- Implemented complete business logic for all static methods in `RoleService` class (`src/services/role_service.py`).
- Methods implemented:
  - `get_all_roles`: Retrieves all roles ordered by name
  - `create_role`: Creates new role with name validation
  - `get_role_by_id`: Retrieves role by ID
  - `update_role`: Updates role with name uniqueness check
  - `delete_role`: Deletes role with user assignment check
  - `get_role_permissions`: Gets permissions for a role
  - `assign_permission_to_role`: Assigns permission to role
  - `remove_permission_from_role`: Removes permission from role
- All methods include proper error handling, input validation, and database transaction management
- Return tuples follow consistent pattern: (result, message, status_code)
- Ready for integration with admin routes in next step

### Step 12 Complete (2025-05-09):
- Implemented `get_all_permissions` static method in `PermissionService` class.
- Method retrieves all permissions ordered by name.
- Includes proper error handling with SQLAlchemy exception catching and session rollback.
- Follows consistent return pattern (data/None, message, status_code).
- Ready for integration with admin routes.

### Step 13 Complete (2025-05-10):
- Implemented complete RESTful API endpoints in `src/routes/admin/role_admin_routes.py` for managing Roles and their Permissions.
- All endpoints secured with `@require_permission('MANAGE_ROLES')`.
- Uses proper request validation and response serialization via Marshmallow schemas.
- Fully documented with OpenAPI specifications.
- Routes connected to `RoleService` methods and follow consistent error handling pattern.

### Step 14 Complete (2025-05-11):
- Implemented Flask route handler in `src/routes/admin/permission_admin_routes.py` for listing all available system Permissions.
- Created `PermissionListResponseSchema` for consistent response serialization.
- Endpoint secured with `@require_permission('VIEW_PERMISSIONS')`.
- Connected to `PermissionService.get_all_permissions()` method.
- Added OpenAPI documentation and registered blueprint/schemas in `src/app.py`.
- Ready for frontend integration via APIDog swagger.json import.

### Step 15 Complete (2025-05-12):
- Refactored `UserService` class to handle many-to-many relationship between Users and Roles.
- Updated all methods to work with `role_ids` list instead of single `role` enum:
  - `create_user`: Now accepts and validates list of role IDs, fetches Role objects, and assigns them to user.
  - `update_user`: Handles role_ids updates, including empty list for removing all roles.
  - `get_users`: Uses eager loading (selectinload) for roles, supports filtering by role IDs.
  - `get_user_by_id`: Uses eager loading for roles to prevent N+1 queries.
- Added proper validation for role IDs existence and format.
- Improved error messages for invalid role assignments.
- Removed all references to old UserRole enum.
- Uses SQLAlchemy relationship features correctly for many-to-many associations.

### Step 16 Complete (2025-05-13):
- Implemented complete Admin User Management API route handlers in `src/routes/admin/user_admin_routes.py`.
- Created/updated user schemas in `src/schemas/user_schemas.py`:
  - Added `RoleBriefSchema` for role information in responses
  - Updated `UserCreateRequestSchema` and `UserUpdateRequestSchema` to use `role_ids` list
  - Added `UserBriefSchema` and `UserDetailSchema` for responses
  - Updated `UserListResponseSchema` to use `UserBriefSchema`
- Implemented all required endpoints with proper permission decorators:
  - `GET /api/admin/users/` - List users (`@require_permission('VIEW_USERS')`)
  - `POST /api/admin/users/` - Create user (`@require_permission('MANAGE_USERS')`)
  - `GET /api/admin/users/<id>` - Get user details (`@require_permission('VIEW_USERS')`)
  - `PATCH /api/admin/users/<id>` - Update user (`@require_permission('MANAGE_USERS')`)
  - `DELETE /api/admin/users/<id>` - Delete user (`@require_permission('MANAGE_USERS')`)
- Updated `src/app.py` to:
  - Register `user_admin_bp` blueprint with URL prefix `/api/admin/users`
  - Register all user admin schemas with apispec
  - Register all user admin views with apispec for documentation
- All endpoints properly documented with OpenAPI specifications
- Ready for frontend integration via APIDog swagger.json import

## Recent Changes
2. Implemented Admin CRUD API endpoints for Aircraft and Customers:
   - Created `src/routes/admin/aircraft_admin_routes.py` and `src/routes/admin/customer_admin_routes.py` for all admin CRUD operations (GET, POST, PATCH, DELETE).
   - Added/verified service logic in `src/services/aircraft_service.py` and `src/services/customer_service.py` (including error handling, foreign key checks, and correct PK usage).
   - Created `src/schemas/admin_schemas.py` with Marshmallow schemas for admin Aircraft and Customer operations.
   - Registered new blueprints and schemas in `src/app.py` and updated OpenAPI documentation (apispec docstrings and schema registration).
   - All endpoints secured with Admin role and JWT, with consistent error handling and OpenAPI compliance.

1. Updated user_routes.py:
   - Implemented get_users endpoint
   - Added filter parameter handling
   - Added response serialization
   - Updated API documentation

## Validation Status
- ✅ API documentation complete
- ✅ Security measures implemented
- ⏳ Test coverage pending
- ⏳ Frontend integration pending
</file>

<file path="fbo-launchpad-backend/tests/conftest.py">
import os
import pytest
import jwt
from datetime import datetime, timedelta
from src import create_app
from src.models.user import User
from src.models.role import Role
from src.models.permission import Permission
from src.models.aircraft import Aircraft
from src.models.customer import Customer
from src.models.fuel_truck import FuelTruck
from src.models.fuel_order import FuelOrder
from src.extensions import db as _db

@pytest.fixture(scope='session')
def app():
    """Create application for the tests."""
    # Set the testing environment
    os.environ['FLASK_ENV'] = 'testing'
    
    # Create app with testing config
    app = create_app('testing')
    
    # Create application context
    ctx = app.app_context()
    ctx.push()
    
    yield app
    
    ctx.pop()

@pytest.fixture(scope='session')
def db(app):
    """Set up the database for testing."""
    # Drop all tables first to ensure clean state
    _db.drop_all()
    # Create all tables
    _db.create_all()
    
    yield _db
    
    # Clean up
    _db.session.remove()
    _db.drop_all()

@pytest.fixture(scope='function')
def db_session(app, db):
    """Create a new database session for a test."""
    connection = db.engine.connect()
    transaction = connection.begin()
    
    # Create a session bound to the connection
    session = db.create_scoped_session(
        options={"bind": connection, "binds": {}}
    )
    
    # Begin a nested transaction (savepoint)
    session.begin_nested()
    
    # If the session fails to commit, the transaction is rolled back
    @session.event.listens_for(session, 'after_transaction_end')
    def restart_savepoint(session, transaction):
        if transaction.nested and not transaction._parent.nested:
            # Start a new nested transaction after the previous one ends
            session.begin_nested()
    
    yield session
    
    # Rollback everything
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture(scope='function')
def client(app):
    """Create test client."""
    return app.test_client()

@pytest.fixture(scope='session')
def test_permissions(app, db):
    """Create test permissions."""
    with app.app_context():
        permissions = [
            Permission(name='MANAGE_ROLES', description='Can manage roles'),
            Permission(name='VIEW_PERMISSIONS', description='Can view permissions'),
            Permission(name='MANAGE_USERS', description='Can manage users'),
            Permission(name='VIEW_USERS', description='Can view users'),
            Permission(name='CREATE_ORDER', description='Can create fuel orders'),
            Permission(name='MANAGE_ORDERS', description='Can manage fuel orders'),
            Permission(name='VIEW_ORDERS', description='Can view fuel orders'),
            Permission(name='COMPLETE_ORDER', description='Can complete fuel orders'),
            Permission(name='MANAGE_TRUCKS', description='Can manage fuel trucks'),
            Permission(name='VIEW_TRUCKS', description='Can view fuel trucks')
        ]
        for p in permissions:
            db.session.add(p)
        db.session.commit()
        return permissions

@pytest.fixture(scope='session')
def test_roles(app, db, test_permissions):
    """Create test roles."""
    with app.app_context():
        # Admin role gets all permissions
        admin_role = Role(name='Administrator', description='Full system access')
        admin_role.permissions.extend(test_permissions)
        
        # CSR role gets customer service permissions
        csr_role = Role(name='Customer Service Representative', description='Customer service access')
        csr_permissions = [p for p in test_permissions if p.name in [
            'CREATE_ORDER', 'MANAGE_ORDERS', 'VIEW_ORDERS', 'VIEW_USERS'
        ]]
        csr_role.permissions.extend(csr_permissions)
        
        # LST role gets limited permissions
        lst_role = Role(name='Line Service Technician', description='Line service access')
        lst_permissions = [p for p in test_permissions if p.name in [
            'VIEW_ORDERS', 'COMPLETE_ORDER', 'VIEW_TRUCKS'
        ]]
        lst_role.permissions.extend(lst_permissions)
        
        roles = [admin_role, csr_role, lst_role]
        for role in roles:
            db.session.add(role)
        db.session.commit()
        return roles

@pytest.fixture(scope='session')
def test_users(app, db, test_roles):
    """Create test users."""
    with app.app_context():
        admin_role = Role.query.filter_by(name='Administrator').first()
        csr_role = Role.query.filter_by(name='Customer Service Representative').first()
        lst_role = Role.query.filter_by(name='Line Service Technician').first()
        
        admin_user = User(
            username='admin',
            email='admin@test.com',
            name='Admin User',
            is_active=True
        )
        admin_user.set_password('adminpass')
        admin_user.roles.append(admin_role)
        
        csr_user = User(
            username='csr',
            email='csr@test.com',
            name='CSR User',
            is_active=True
        )
        csr_user.set_password('csrpass')
        csr_user.roles.append(csr_role)
        
        lst_user = User(
            username='lst',
            email='lst@test.com',
            name='LST User',
            is_active=True
        )
        lst_user.set_password('lstpass')
        lst_user.roles.append(lst_role)
        
        inactive_user = User(
            username='inactive',
            email='inactive@test.com',
            name='Inactive User',
            is_active=False
        )
        inactive_user.set_password('inactivepass')
        inactive_user.roles.append(lst_role)
        
        users = [admin_user, csr_user, lst_user, inactive_user]
        for user in users:
            db.session.add(user)
        db.session.commit()
        return users

@pytest.fixture(scope='session')
def test_admin_user(test_users):
    """Get the admin test user."""
    return test_users[0]  # First user is admin

@pytest.fixture(scope='session')
def test_csr_user(test_users):
    """Get the CSR test user."""
    return test_users[1]  # Second user is CSR

@pytest.fixture(scope='session')
def test_lst_user(test_users):
    """Get the LST test user."""
    return test_users[2]  # Third user is LST

@pytest.fixture(scope='session')
def test_inactive_user(test_users):
    """Get the inactive test user."""
    return test_users[3]  # Fourth user is inactive

@pytest.fixture(scope='session')
def auth_headers(app, test_users):
    """Generate authentication headers for test users."""
    headers = {}
    with app.app_context():
        for user in test_users:
            if user.is_active:  # Only generate tokens for active users
                token = jwt.encode(
                    {
                        'sub': user.id,  # Changed from user_id to sub for standard JWT claims
                        'exp': datetime.utcnow() + timedelta(days=1),
                        'iat': datetime.utcnow()
                    },
                    app.config['JWT_SECRET_KEY'],
                    algorithm='HS256'
                )
                role_key = user.roles[0].name.lower().split()[0]  # Get first word of role name in lowercase
                headers[role_key] = {'Authorization': f'Bearer {token}'}
    return headers

@pytest.fixture(scope='session')
def test_customer(db):
    """Create a test customer."""
    customer = Customer(
        name='Test Customer',
        email='customer@test.com',
        phone='1234567890'
    )
    db.session.add(customer)
    db.session.commit()
    return customer

@pytest.fixture(scope='session')
def test_aircraft(db, test_customer):
    """Create a test aircraft."""
    aircraft = Aircraft(
        tail_number='N12345',
        aircraft_type='Jet',
        fuel_type='Jet-A',
        customer_id=test_customer.id
    )
    db.session.add(aircraft)
    db.session.commit()
    return aircraft

@pytest.fixture(scope='session')
def test_fuel_truck(db):
    """Create a test fuel truck."""
    truck = FuelTruck(
        truck_number='FT001',
        fuel_type='Jet-A',
        capacity=5000.0,
        current_fuel_level=5000.0,
        is_active=True
    )
    db.session.add(truck)
    db.session.commit()
    return truck

@pytest.fixture
def test_fuel_order(db, test_aircraft, test_fuel_truck, test_lst_user):
    """Create a test fuel order."""
    order = FuelOrder(
        aircraft_id=test_aircraft.id,
        fuel_truck_id=test_fuel_truck.id,
        lst_id=test_lst_user.id,
        fuel_type='Jet-A',
        amount_requested=1000.0,
        status='pending'
    )
    db.session.add(order)
    db.session.commit()
    return order

@pytest.fixture(scope='function')
def runner(app):
    """Create a test CLI runner."""
    return app.test_cli_runner()
</file>

<file path="fbo-launchpad-backend/tests/test_admin_permissions.py">
"""Tests for the permission listing API endpoint."""

import pytest
from flask import json
from src.models.permission import Permission

def test_get_permissions(client, auth_headers, test_permissions):
    """Test GET /api/admin/permissions endpoint."""
    # Test unauthorized access
    response = client.get('/api/admin/permissions')
    assert response.status_code == 401, "Unauthorized request should be rejected"

    # Test forbidden access (LST)
    response = client.get('/api/admin/permissions', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access"

    # Test successful retrieval (Admin)
    response = client.get('/api/admin/permissions', headers=auth_headers['admin'])
    assert response.status_code == 200, "Admin should have access"
    data = json.loads(response.data)
    assert 'permissions' in data, "Response should contain permissions"
    
    # Verify permission list format
    permissions = data['permissions']
    for permission in permissions:
        assert 'id' in permission
        assert 'name' in permission
        assert 'description' in permission

    # Verify all test permissions are present
    permission_names = [perm['name'] for perm in permissions]
    for perm_name in test_permissions:
        assert perm_name in permission_names, f"Permission {perm_name} should be present"

    # Test access with CSR role (should be denied if VIEW_PERMISSIONS is admin-only)
    response = client.get('/api/admin/permissions', headers=auth_headers['csr'])
    assert response.status_code == 403, "CSR should be denied access to permissions list"

def test_get_permissions_csr_access(client, auth_headers):
    """Test CSR access to permissions endpoint (should be allowed VIEW_PERMISSIONS)."""
    response = client.get('/api/admin/permissions', headers=auth_headers['csr'])
    assert response.status_code == 200, "CSR should have access with VIEW_PERMISSIONS"

def test_get_permissions_response_format(client, auth_headers):
    """Test the format of the permissions response."""
    response = client.get('/api/admin/permissions', headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Check response structure
    assert 'permissions' in data
    assert isinstance(data['permissions'], list)
    
    # Check permission object structure
    for permission in data['permissions']:
        assert 'id' in permission
        assert 'name' in permission
        assert isinstance(permission['id'], int)
        assert isinstance(permission['name'], str)

def test_get_permissions_empty_db(client, auth_headers, db_session):
    """Test permissions endpoint with empty database."""
    # Delete all permissions
    Permission.query.delete()
    db_session.commit()
    
    response = client.get('/api/admin/permissions', headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 0, "Empty database should return empty list"
</file>

<file path="fbo-launchpad-backend/tests/test_admin_roles.py">
"""Tests for the role management API endpoints."""

import pytest
from flask import json
from src.models.role import Role
from src.models.permission import Permission

def test_get_roles(client, auth_headers, test_roles):
    """Test GET /api/admin/roles endpoint."""
    # Test unauthorized access
    response = client.get('/api/admin/roles')
    assert response.status_code == 401, "Unauthorized request should be rejected"

    # Test forbidden access (LST)
    response = client.get('/api/admin/roles', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access"

    # Test successful retrieval (Admin)
    response = client.get('/api/admin/roles', headers=auth_headers['admin'])
    assert response.status_code == 200, "Admin should have access"
    data = json.loads(response.data)
    assert 'roles' in data, "Response should contain roles"
    
    # Verify role list format
    roles = data['roles']
    for role in roles:
        assert 'id' in role
        assert 'name' in role
        assert 'description' in role
        assert 'created_at' in role

    # Verify all test roles are present
    role_names = [role['name'] for role in roles]
    assert 'System Administrator' in role_names
    assert 'Customer Service Representative' in role_names
    assert 'Line Service Technician' in role_names

def test_create_role(client, auth_headers, test_permissions):
    """Test POST /api/admin/roles endpoint."""
    new_role_data = {
        'name': 'Test Role',
        'description': 'A test role'
    }

    # Test unauthorized
    response = client.post('/api/admin/roles',
                          json=new_role_data)
    assert response.status_code == 401

    # Test forbidden (CSR)
    response = client.post('/api/admin/roles',
                          headers=auth_headers['csr'],
                          json=new_role_data)
    assert response.status_code == 403

    # Test successful creation (Admin)
    response = client.post('/api/admin/roles',
                          headers=auth_headers['admin'],
                          json=new_role_data)
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['role']['name'] == 'Test Role'
    assert data['role']['description'] == 'A test role'

    # Test duplicate name
    response = client.post('/api/admin/roles',
                          headers=auth_headers['admin'],
                          json=new_role_data)
    assert response.status_code == 409

def test_get_role(client, auth_headers, test_roles):
    """Test GET /api/admin/roles/<id> endpoint."""
    role_id = test_roles['csr'].id

    # Test unauthorized
    response = client.get(f'/api/admin/roles/{role_id}')
    assert response.status_code == 401

    # Test forbidden (LST)
    response = client.get(f'/api/admin/roles/{role_id}',
                         headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful retrieval (Admin)
    response = client.get(f'/api/admin/roles/{role_id}',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['role']['name'] == 'Customer Service Representative'

    # Test non-existent role
    response = client.get('/api/admin/roles/99999',
                         headers=auth_headers['admin'])
    assert response.status_code == 404

def test_update_role(client, auth_headers, db_session):
    """Test PATCH /api/admin/roles/<id> endpoint."""
    # Create a role to update
    role = Role(name='Role To Update')
    db_session.add(role)
    db_session.commit()
    role_id = role.id

    update_data = {
        'name': 'Updated Role',
        'description': 'Updated description'
    }

    # Test unauthorized
    response = client.patch(f'/api/admin/roles/{role_id}',
                          json=update_data)
    assert response.status_code == 401

    # Test forbidden (CSR)
    response = client.patch(f'/api/admin/roles/{role_id}',
                          headers=auth_headers['csr'],
                          json=update_data)
    assert response.status_code == 403

    # Test successful update (Admin)
    response = client.patch(f'/api/admin/roles/{role_id}',
                          headers=auth_headers['admin'],
                          json=update_data)
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['role']['name'] == 'Updated Role'
    assert data['role']['description'] == 'Updated description'

def test_delete_role(client, auth_headers, db_session, test_users):
    """Test DELETE /api/admin/roles/<id> endpoint."""
    # Create a role to delete
    role = Role(name='Role To Delete')
    db_session.add(role)
    db_session.commit()
    role_id = role.id

    # Test unauthorized
    response = client.delete(f'/api/admin/roles/{role_id}')
    assert response.status_code == 401

    # Test forbidden (CSR)
    response = client.delete(f'/api/admin/roles/{role_id}',
                           headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test successful deletion (Admin)
    response = client.delete(f'/api/admin/roles/{role_id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 200

    # Test deleting non-existent role
    response = client.delete('/api/admin/roles/99999',
                           headers=auth_headers['admin'])
    assert response.status_code == 404

    # Test deleting role assigned to users
    admin_role_id = test_users['admin'].roles[0].id
    response = client.delete(f'/api/admin/roles/{admin_role_id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 409

def test_role_permissions(client, auth_headers, db_session, test_permissions):
    """Test role permission assignment endpoints."""
    # Create a test role
    role = Role(name='Permission Test Role')
    db_session.add(role)
    db_session.commit()
    role_id = role.id

    # Get initial permissions
    response = client.get(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 0

    # Assign a permission
    perm = Permission.query.filter_by(name='CREATE_ORDER').first()
    response = client.post(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'],
                         json={'permission_id': perm.id})
    assert response.status_code == 200

    # Verify permission was assigned
    response = client.get(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 1
    assert data['permissions'][0]['name'] == 'CREATE_ORDER'

    # Remove the permission
    response = client.delete(f'/api/admin/roles/{role_id}/permissions/{perm.id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 200

    # Verify permission was removed
    response = client.get(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 0

    # Test assigning invalid permission ID
    response = client.post(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'],
                         json={'permission_id': 99999})
    assert response.status_code == 400
</file>

<file path="fbo-launchpad-backend/tests/test_admin_users.py">
"""Tests for the user management API endpoints."""

import pytest
from flask import json
from src.models.user import User

def test_get_users(client, auth_headers, test_users, test_roles):
    """Test GET /api/admin/users endpoint."""
    # Test unauthorized access
    response = client.get('/api/admin/users/')
    assert response.status_code == 401, "Unauthorized request should be rejected"

    # Test forbidden access (LST)
    response = client.get('/api/admin/users/', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access"

    # Test successful retrieval with VIEW_USERS (CSR)
    response = client.get('/api/admin/users/', headers=auth_headers['csr'])
    assert response.status_code == 200, "CSR should have access with VIEW_USERS"
    data = json.loads(response.data)
    assert 'users' in data, "Response should contain users"
    
    # Verify user list format
    users = data['users']
    for user in users:
        assert 'id' in user
        assert 'username' in user
        assert 'email' in user
        assert 'roles' in user
        assert isinstance(user['roles'], list)
        for role in user['roles']:
            assert 'id' in role
            assert 'name' in role

    # Verify all test users are present
    usernames = [user['username'] for user in users]
    assert 'testadmin' in usernames
    assert 'testcsr' in usernames
    assert 'testlst' in usernames

def test_create_user(client, auth_headers, test_roles):
    """Test POST /api/admin/users endpoint."""
    new_user_data = {
        'username': 'newuser',
        'email': 'newuser@test.com',
        'password': 'testpass123',
        'name': 'New User',
        'role_ids': [test_roles['csr'].id]
    }

    # Test unauthorized
    response = client.post('/api/admin/users/',
                          json=new_user_data)
    assert response.status_code == 401

    # Test forbidden (CSR - has VIEW_USERS but not MANAGE_USERS)
    response = client.post('/api/admin/users/',
                          headers=auth_headers['csr'],
                          json=new_user_data)
    assert response.status_code == 403

    # Test successful creation (Admin)
    response = client.post('/api/admin/users/',
                          headers=auth_headers['admin'],
                          json=new_user_data)
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['user']['username'] == 'newuser'
    assert data['user']['email'] == 'newuser@test.com'
    assert len(data['user']['roles']) == 1
    assert data['user']['roles'][0]['name'] == 'Customer Service Representative'

    # Test duplicate username
    response = client.post('/api/admin/users/',
                          headers=auth_headers['admin'],
                          json=new_user_data)
    assert response.status_code == 409

    # Test invalid role ID
    invalid_user = new_user_data.copy()
    invalid_user['username'] = 'invaliduser'
    invalid_user['email'] = 'invalid@test.com'
    invalid_user['role_ids'] = [99999]
    response = client.post('/api/admin/users/',
                          headers=auth_headers['admin'],
                          json=invalid_user)
    assert response.status_code == 400

def test_get_user(client, auth_headers, test_users):
    """Test GET /api/admin/users/<id> endpoint."""
    user_id = test_users['csr'].id

    # Test unauthorized
    response = client.get(f'/api/admin/users/{user_id}')
    assert response.status_code == 401

    # Test successful retrieval with VIEW_USERS (CSR)
    response = client.get(f'/api/admin/users/{user_id}',
                         headers=auth_headers['csr'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['user']['username'] == 'testcsr'
    assert 'roles' in data['user']
    assert len(data['user']['roles']) == 1
    assert data['user']['roles'][0]['name'] == 'Customer Service Representative'

    # Test non-existent user
    response = client.get('/api/admin/users/99999',
                         headers=auth_headers['admin'])
    assert response.status_code == 404

def test_update_user(client, auth_headers, test_users, test_roles):
    """Test PATCH /api/admin/users/<id> endpoint."""
    user = User(username='updateuser', email='update@test.com', name='Update User')
    user.set_password('testpass')
    user.roles.append(test_roles['lst'])
    db_session = test_roles['lst'].query.session
    db_session.add(user)
    db_session.commit()
    user_id = user.id

    update_data = {
        'name': 'Updated Name',
        'role_ids': [test_roles['csr'].id]
    }

    # Test unauthorized
    response = client.patch(f'/api/admin/users/{user_id}',
                          json=update_data)
    assert response.status_code == 401

    # Test forbidden (CSR - has VIEW_USERS but not MANAGE_USERS)
    response = client.patch(f'/api/admin/users/{user_id}',
                          headers=auth_headers['csr'],
                          json=update_data)
    assert response.status_code == 403

    # Test successful update (Admin)
    response = client.patch(f'/api/admin/users/{user_id}',
                          headers=auth_headers['admin'],
                          json=update_data)
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['user']['name'] == 'Updated Name'
    assert len(data['user']['roles']) == 1
    assert data['user']['roles'][0]['name'] == 'Customer Service Representative'

    # Test invalid role ID
    invalid_update = {'role_ids': [99999]}
    response = client.patch(f'/api/admin/users/{user_id}',
                          headers=auth_headers['admin'],
                          json=invalid_update)
    assert response.status_code == 400

def test_delete_user(client, auth_headers, test_users, db_session):
    """Test DELETE /api/admin/users/<id> endpoint."""
    # Create a user to delete
    user = User(username='deleteuser', email='delete@test.com', name='Delete User')
    user.set_password('testpass')
    db_session.add(user)
    db_session.commit()
    user_id = user.id

    # Test unauthorized
    response = client.delete(f'/api/admin/users/{user_id}')
    assert response.status_code == 401

    # Test forbidden (CSR - has VIEW_USERS but not MANAGE_USERS)
    response = client.delete(f'/api/admin/users/{user_id}',
                           headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test successful deletion (Admin)
    response = client.delete(f'/api/admin/users/{user_id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 200

    # Verify user is soft deleted
    user = User.query.get(user_id)
    assert user is not None, "User should still exist (soft delete)"
    assert not user.is_active, "User should be inactive"

    # Test deleting non-existent user
    response = client.delete('/api/admin/users/99999',
                           headers=auth_headers['admin'])
    assert response.status_code == 404
</file>

<file path="fbo-launchpad-backend/tests/test_auth.py">
"""Tests for authentication endpoints."""

import pytest
import json
from src.models.user import User
from flask import g
from src.models.role import Role
from src.models.permission import Permission
from src.routes.auth_routes import reset_rate_limits

@pytest.fixture(autouse=True)
def reset_rate_limiting():
    """Reset rate limiting between tests."""
    reset_rate_limits()
    yield

# === Registration Tests (/auth/register) ===

def test_register_success(client, db_session, test_roles):
    """ Test successful user registration """
    response = client.post('/api/auth/register', json={
        'username': 'newuser',
        'name': 'New User',
        'email': 'newuser@test.com',
        'password': 'password123'
    })
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['message'] == 'User registered successfully'
    assert 'user' in data
    assert data['user']['email'] == 'newuser@test.com'
    assert data['user']['name'] == 'New User'
    
    # Verify user exists in DB with CSR role
    user = User.query.filter_by(email='newuser@test.com').first()
    assert user is not None
    assert user.name == 'New User'
    assert user.check_password('password123')  # Verify password hashing
    
    # Verify user has CSR role
    assert len(user.roles) == 1
    assert user.roles[0].name == 'Customer Service Representative'
    
    # Verify CSR permissions
    assert user.has_permission('CREATE_ORDER')
    assert user.has_permission('VIEW_ORDERS')
    assert user.has_permission('MANAGE_ORDERS')
    assert user.has_permission('VIEW_USERS')
    assert user.has_permission('VIEW_AIRCRAFT')
    assert user.has_permission('VIEW_CUSTOMERS')
    assert user.has_permission('VIEW_TRUCKS')
    assert not user.has_permission('MANAGE_ROLES')
    assert not user.has_permission('MANAGE_USERS')

def test_register_invalid_data(client):
    """ Test registration with invalid data """
    # Missing required fields
    response = client.post('/api/auth/register', json={
        'name': 'Invalid User'
    })
    assert response.status_code == 400
    assert json.loads(response.data)['error'] == 'Invalid request data'

def test_register_duplicate_email(client, test_users):
    """ Test registration with duplicate email """
    response = client.post('/api/auth/register', json={
        'username': 'duplicate',
        'name': 'Duplicate User',
        'email': 'admin@test.com',  # Using existing email from test_users
        'password': 'password123'
    })
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'Email already registered'

# === Login Tests (/auth/login) ===

def test_login_success(client, test_users):
    """ Test successful login """
    response = client.post('/api/auth/login', json={
        'email': 'admin@test.com',
        'password': 'adminpass'
    })
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'access_token' in data
    assert data['token_type'] == 'Bearer'
    
    # Verify user permissions after login
    user = User.query.filter_by(email='admin@test.com').first()
    assert user.has_permission('CREATE_ORDER')
    assert user.has_permission('VIEW_ORDERS')
    assert user.has_permission('MANAGE_ORDERS')
    assert user.has_permission('VIEW_USERS')
    assert user.has_permission('VIEW_AIRCRAFT')
    assert user.has_permission('VIEW_CUSTOMERS')
    assert user.has_permission('VIEW_TRUCKS')
    assert not user.has_permission('MANAGE_ROLES')
    assert not user.has_permission('MANAGE_USERS')

def test_login_invalid_credentials(client, test_users):
    """ Test login with invalid credentials """
    response = client.post('/api/auth/login', json={
        'email': 'admin@test.com',
        'password': 'wrongpass'
    })
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Invalid credentials'

def test_login_inactive_user(client, test_users):
    """ Test login with inactive user """
    response = client.post('/api/auth/login', json={
        'email': 'inactive@test.com',
        'password': 'inactivepass'
    })
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Account is inactive'

def test_login_rate_limiting(client, test_users):
    """ Test login rate limiting """
    # Make 6 login attempts (exceeding the limit of 5)
    for i in range(6):
        response = client.post('/api/auth/login', json={
            'email': 'admin@test.com',
            'password': 'wrongpass'
        })
        if i < 5:
            assert response.status_code in [401, 403]  # Either invalid credentials or rate limit
        else:
            assert response.status_code == 429
            data = json.loads(response.data)
            assert 'error' in data
            assert 'retry_after_seconds' in data

def test_rate_limit_window_expiration(client, test_users):
    """ Test rate limit window expiration """
    # This test might need to be adjusted or skipped in CI environments
    # where time manipulation is not possible
    pass

def test_rate_limit_per_ip(client, test_users):
    """ Test rate limiting is per IP address """
    # This test might need to be adjusted based on how you simulate different IPs
    pass

def test_login_role_permissions(client, test_users, auth_headers):
    """ Test that login response includes correct role permissions """
    response = client.post('/api/auth/login', json={
        'email': 'admin@test.com',
        'password': 'adminpass'
    })
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'access_token' in data
    
    # Verify token contains role information
    import jwt
    token = data['access_token']
    decoded = jwt.decode(token, verify=False)  # We're not verifying the signature here
    assert 'roles' in decoded
    assert 'Administrator' in decoded['roles']

def test_permission_inheritance(client, db_session, test_users):
    """Test that admin role inherits all permissions."""
    admin = test_users['admin']
    csr = test_users['csr']
    lst = test_users['lst']
    
    # Admin should have all permissions
    assert admin.has_permission('MANAGE_ROLES')
    assert admin.has_permission('MANAGE_USERS')
    assert admin.has_permission('MANAGE_ORDERS')
    assert admin.has_permission('MANAGE_AIRCRAFT')
    assert admin.has_permission('MANAGE_CUSTOMERS')
    assert admin.has_permission('MANAGE_TRUCKS')
    
    # CSR should have subset of permissions
    assert csr.has_permission('CREATE_ORDER')
    assert csr.has_permission('MANAGE_ORDERS')
    assert csr.has_permission('VIEW_USERS')
    assert not csr.has_permission('MANAGE_ROLES')
    assert not csr.has_permission('MANAGE_USERS')
    
    # LST should have minimal permissions
    assert lst.has_permission('VIEW_ORDERS')
    assert lst.has_permission('CREATE_ORDER')
    assert lst.has_permission('VIEW_AIRCRAFT')
    assert lst.has_permission('VIEW_TRUCKS')
    assert not lst.has_permission('MANAGE_ORDERS')
    assert not lst.has_permission('MANAGE_ROLES')
    assert not lst.has_permission('MANAGE_USERS')

def test_permission_caching(client, db_session, test_users, app):
    """Test that permission checks are properly cached within a request."""
    from flask import g
    
    with app.test_request_context():
        user = test_users['csr']
        
        # First check should cache the result
        assert user.has_permission('CREATE_ORDER')
        cache_key = f'user_{user.id}_perm_CREATE_ORDER'
        assert hasattr(g, '_permission_cache')
        assert cache_key in g._permission_cache
        assert g._permission_cache[cache_key] is True

def test_permission_cache_invalidation(client, db_session, test_users, app):
    """Test that permission cache is request-scoped."""
    from flask import g
    
    user = test_users['csr']
    
    # Check permission in first request
    with app.test_request_context():
        assert not hasattr(g, '_permission_cache')  # Should not exist yet
        assert user.has_permission('CREATE_ORDER')
        cache_key = f'user_{user.id}_perm_CREATE_ORDER'
        assert hasattr(g, '_permission_cache')
        assert cache_key in g._permission_cache
        assert g._permission_cache[cache_key] is True
        
    # Check permission in new request (should not have cached value)
    with app.test_request_context():
        assert not hasattr(g, '_permission_cache')  # New request, no cache
        assert user.has_permission('CREATE_ORDER')  # Should recalculate
        assert hasattr(g, '_permission_cache')  # Cache should be created
        cache_key = f'user_{user.id}_perm_CREATE_ORDER'
        assert cache_key in g._permission_cache  # Permission should be cached

def test_inactive_user_permissions(client, db_session, test_inactive_user):
    """Test that inactive users have no permissions regardless of roles."""
    user = test_inactive_user
    assert not user.is_active
    assert not user.has_permission('VIEW_ORDERS')
    assert not user.has_permission('CREATE_ORDER')

def test_permission_check_performance(client, db_session, test_users, benchmark):
    """Test the performance of permission checking with caching."""
    user = test_users['csr']
    
    def check_permission():
        return user.has_permission('CREATE_ORDER')
    
    # Benchmark permission check
    result = benchmark(check_permission)
    assert result is True
</file>

<file path="fbo-launchpad-backend/tests/test_fuel_order_api.py">
import os
os.environ.pop('DATABASE_URL', None)
os.environ.pop('TEST_DATABASE_URL', None)

import pytest
from flask import Flask
from src import create_app, db

@pytest.fixture
def app():
    app = create_app('testing')
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

def test_create_and_get_fuel_order(app):
    with app.app_context():
        client = app.test_client()
        # Register a test user
        client.post('/api/auth/register', json={
            'email': 'testuser@example.com',
            'password': 'testpassword'
        })
        # Set correct role
        from src.models.user import User, UserRole
        from src.extensions import db
        user = User.query.filter_by(email='testuser@example.com').first()
        assert user is not None, 'User should exist after registration.'
        user.role = UserRole.CSR
        db.session.add(user)
        db.session.commit()
        # Log in to get token
        resp = client.post('/auth/login', json={
            'email': 'testuser@example.com',
            'password': 'testpassword'
        })
        print('JWT_SECRET_KEY during login:', app.config.get('JWT_SECRET_KEY'))
        token = resp.get_json()['token']

        # Debug: print JWT secret from app config before making API call
        print('JWT_SECRET_KEY during protected endpoint:', app.config.get('JWT_SECRET_KEY'))
        # Create a fuel order
        resp = client.post('/fuel-orders/', json={
            'tail_number': 'N12345',
            'fuel_type': 'Jet-A',
            'assigned_lst_user_id': 1,
            'assigned_truck_id': 1,
            'requested_amount': 100.0,
            'location_on_ramp': 'Ramp A'
        }, headers={'Authorization': f'Bearer {token}'})
        assert resp.status_code == 201

        # Get fuel orders (if implemented)
        # resp = client.get('/fuel-orders/', headers={'Authorization': f'Bearer {token}'})
        # data = resp.get_json()
        # assert any(order['requested_amount'] == 100.0 for order in data.get('orders', []))

def test_create_fuel_order_unauthorized(client):
    resp = client.post('/api/fuel-orders/', json={
        'tail_number': 'N12345',
        'fuel_type': 'Jet-A',
        'assigned_lst_user_id': 1,
        'assigned_truck_id': 1,
        'requested_amount': 100.0,
        'location_on_ramp': 'Ramp A'
    })
    assert resp.status_code == 401
</file>

<file path="fbo-launchpad-backend/tests/test_fuel_orders.py">
import pytest
import json
from decimal import Decimal
from src.models import FuelOrder, FuelOrderStatus
from src.extensions import db

# === Fuel Order Creation Tests (POST /api/fuel-orders) ===

def test_create_fuel_order_success_csr(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test successful fuel order creation by a user with CREATE_ORDER permission """
    csr_headers = auth_headers['csr']  # CSR has CREATE_ORDER permission
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number

    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
        "location_on_ramp": "Hangar 1",
        "requested_amount": "100.50",  # Send as string, backend handles Decimal
        "additive_requested": True,
        "csr_notes": "Test order notes"
        # customer_id is optional
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)

    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Fuel order created successfully'
    assert 'fuel_order' in data
    order_data = data['fuel_order']
    assert order_data['status'] == FuelOrderStatus.DISPATCHED.value
    assert order_data['tail_number'] == tail_number
    assert order_data['assigned_lst_user_id'] == lst_user_id
    assert order_data['assigned_truck_id'] == truck_id
    assert order_data['requested_amount'] == "100.50"  # Check string representation
    assert order_data['additive_requested'] is True
    assert order_data['csr_notes'] == "Test order notes"
    assert order_data['dispatch_timestamp'] is not None

    # Verify DB state
    order_in_db = FuelOrder.query.get(order_data['id'])
    assert order_in_db is not None
    assert order_in_db.status == FuelOrderStatus.DISPATCHED
    assert order_in_db.requested_amount == Decimal("100.50")  # Check Decimal in DB

def test_create_fuel_order_success_admin(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test successful fuel order creation by an admin (who has CREATE_ORDER permission) """
    admin_headers = auth_headers['admin']  # Admin has all permissions including CREATE_ORDER
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number

    payload = {  # Minimal required payload
        "tail_number": tail_number,
        "fuel_type": "100LL",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=admin_headers, json=payload)
    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Fuel order created successfully'
    assert 'fuel_order' in data
    order_data = data['fuel_order']
    assert order_data['status'] == FuelOrderStatus.DISPATCHED.value
    assert order_data['tail_number'] == tail_number
    assert order_data['assigned_lst_user_id'] == lst_user_id
    assert order_data['assigned_truck_id'] == truck_id

def test_create_fuel_order_success_lst(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test successful fuel order creation by an LST (who now has CREATE_ORDER permission) """
    lst_headers = auth_headers['lst']  # LST now has CREATE_ORDER permission
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number

    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=lst_headers, json=payload)
    assert response.status_code == 201
    data = response.get_json()
    assert 'fuel_order' in data
    assert data['message'] == 'Fuel order created successfully'

def test_create_fuel_order_unauthenticated(client, db_session, test_users, test_fuel_truck, test_aircraft):
    """ Test creating a fuel order without authentication """
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', json=payload)  # No headers
    assert response.status_code == 401  # Unauthorized
    data = response.get_json()
    assert 'error' in data
    assert "Authentication token is missing" in data['error']

def test_create_fuel_order_missing_required_fields(client, db_session, auth_headers, test_aircraft):
    """ Test creating order with missing required fields """
    csr_headers = auth_headers['csr']
    payload = {
        "tail_number": test_aircraft.tail_number
        # Missing fuel_type, assigned_lst_user_id, assigned_truck_id
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Missing required fields" in data['error']

def test_create_fuel_order_invalid_lst_id(client, db_session, auth_headers, test_fuel_truck, test_aircraft):
    """ Test creating order with a non-existent LST user ID """
    csr_headers = auth_headers['csr']
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": 99999,  # Non-existent ID
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request (Service validation)
    data = response.get_json()
    assert 'error' in data
    assert "Invalid or inactive LST user ID" in data['error']

def test_create_fuel_order_invalid_truck_id(client, db_session, auth_headers, test_users, test_aircraft):
    """ Test creating order with a non-existent Truck ID """
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": 99999,  # Non-existent ID
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Invalid or inactive Fuel Truck ID" in data['error']

def test_create_fuel_order_invalid_aircraft_id(client, db_session, auth_headers, test_users, test_fuel_truck):
    """ Test creating order with a non-existent Aircraft tail number """
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    payload = {
        "tail_number": "N999XX",  # Non-existent tail number
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Aircraft with tail number N999XX not found" in data['error']

def test_create_fuel_order_invalid_amount(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test creating order with invalid requested amount """
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
        "requested_amount": "invalid",  # Invalid amount
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Invalid requested amount" in data['error']

def test_order_status_update_permissions(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """Test order status updates with different user permissions."""
    # Create an order first
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    
    # Create order
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 201
    order_id = response.get_json()['fuel_order']['id']
    
    # Test LST can update status (has MANAGE_ORDERS permission)
    lst_headers = auth_headers['lst']
    update_payload = {"status": "IN_PROGRESS"}
    response = client.patch(f'/api/fuel-orders/{order_id}/status',
                          headers=lst_headers,
                          json=update_payload)
    assert response.status_code == 200
    
    # Test CSR can update status (has MANAGE_ORDERS permission)
    update_payload = {"status": "COMPLETED"}
    response = client.patch(f'/api/fuel-orders/{order_id}/status',
                          headers=csr_headers,
                          json=update_payload)
    assert response.status_code == 200
    
    # Test Admin can update status (has all permissions)
    admin_headers = auth_headers['admin']
    update_payload = {"status": "CANCELLED"}
    response = client.patch(f'/api/fuel-orders/{order_id}/status',
                          headers=admin_headers,
                          json=update_payload)
    assert response.status_code == 200
</file>

<file path="fbo-launchpad-backend/tests/test_fuel_trucks.py">
import pytest
from decimal import Decimal
from src.models import FuelTruck

def test_create_fuel_truck_success_admin(client, db_session, auth_headers):
    """Test successful fuel truck creation by an authenticated Admin"""
    admin_headers = auth_headers['admin']
    payload = {
        "truck_number": "TRUCK002",
        "fuel_type": "Jet A",
        "capacity": "5000.00",
        "current_meter_reading": "100.00"
    }
    response = client.post('/api/fuel-trucks/', headers=admin_headers, json=payload)
    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Fuel truck created successfully'
    assert 'fuel_truck' in data
    truck_data = data['fuel_truck']
    assert truck_data['truck_number'] == "TRUCK002"
    assert truck_data['fuel_type'] == "Jet A"
    assert float(truck_data['capacity']) == 5000.00
    assert float(truck_data['current_meter_reading']) == 100.00
    assert truck_data['is_active'] is True

def test_create_fuel_truck_forbidden_csr(client, db_session, auth_headers):
    """Test that a CSR cannot create a fuel truck"""
    csr_headers = auth_headers['csr']
    payload = {
        "truck_number": "TRUCK003",
        "fuel_type": "Jet A",
        "capacity": "5000.00"
    }
    response = client.post('/api/fuel-trucks/', headers=csr_headers, json=payload)
    assert response.status_code == 403  # Forbidden
    data = response.get_json()
    assert 'error' in data
    assert "Insufficient permissions" in data['error']

def test_create_fuel_truck_duplicate_number(client, db_session, auth_headers, test_fuel_truck):
    """Test creating a truck with a duplicate truck number"""
    admin_headers = auth_headers['admin']
    payload = {
        "truck_number": test_fuel_truck.truck_number,  # Using existing truck number
        "fuel_type": "Jet A",
        "capacity": "5000.00"
    }
    response = client.post('/api/fuel-trucks/', headers=admin_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "already exists" in data['error']

def test_create_fuel_truck_invalid_data(client, db_session, auth_headers):
    """Test creating a truck with invalid data"""
    admin_headers = auth_headers['admin']
    # Missing required fields
    payload = {
        "truck_number": "TRUCK004"
        # Missing fuel_type and capacity
    }
    response = client.post('/api/fuel-trucks/', headers=admin_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data

def test_get_fuel_trucks_success(client, db_session, auth_headers, test_fuel_truck):
    """Test successful retrieval of fuel trucks"""
    csr_headers = auth_headers['csr']
    response = client.get('/api/fuel-trucks/', headers=csr_headers)
    assert response.status_code == 200
    data = response.get_json()
    assert 'fuel_trucks' in data
    assert len(data['fuel_trucks']) >= 1
    assert any(truck['truck_number'] == test_fuel_truck.truck_number for truck in data['fuel_trucks'])

def test_get_fuel_trucks_filter_active(client, db_session, auth_headers, test_fuel_truck):
    """Test filtering fuel trucks by active status"""
    csr_headers = auth_headers['csr']
    # Create an inactive truck
    inactive_truck = FuelTruck(
        truck_number='INACTIVE001',
        fuel_type='Jet A',
        capacity=5000.0,
        is_active=False
    )
    db_session.add(inactive_truck)
    db_session.commit()

    # Test filtering active trucks
    response = client.get('/api/fuel-trucks/?is_active=true', headers=csr_headers)
    assert response.status_code == 200
    data = response.get_json()
    assert all(truck['is_active'] for truck in data['fuel_trucks'])

    # Test filtering inactive trucks
    response = client.get('/api/fuel-trucks/?is_active=false', headers=csr_headers)
    assert response.status_code == 200
    data = response.get_json()
    assert all(not truck['is_active'] for truck in data['fuel_trucks'])
</file>

<file path="fbo-launchpad-backend/tests/test_models.py">
import pytest
from datetime import datetime
from src.models.fuel_order import FuelOrder, FuelOrderStatus

def test_create_fuel_order(db_session, test_aircraft, test_customer, test_user, test_fuel_truck):
    """Test creating a new fuel order."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        customer_id=test_customer.id,
        fuel_type='Jet A',
        additive_requested=False,
        requested_amount=1000.0,
        assigned_lst_user_id=test_user.id,
        assigned_truck_id=test_fuel_truck.id,
        location_on_ramp='Gate A1'
    )
    
    db_session.add(fuel_order)
    db_session.commit()
    
    assert fuel_order.id is not None
    assert fuel_order.status == FuelOrderStatus.DISPATCHED
    assert fuel_order.created_at is not None

def test_fuel_order_status_transitions(db_session, test_aircraft):
    """Test fuel order status transitions."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        fuel_type='Jet A',
        requested_amount=1000.0
    )
    db_session.add(fuel_order)
    db_session.commit()
    
    # Test initial status
    assert fuel_order.status == FuelOrderStatus.DISPATCHED
    assert fuel_order.dispatch_timestamp is None
    
    # Test acknowledge transition
    fuel_order.status = FuelOrderStatus.ACKNOWLEDGED
    fuel_order.acknowledge_timestamp = datetime.utcnow()
    db_session.commit()
    assert fuel_order.status == FuelOrderStatus.ACKNOWLEDGED
    assert fuel_order.acknowledge_timestamp is not None
    
    # Test en route transition
    fuel_order.status = FuelOrderStatus.EN_ROUTE
    fuel_order.en_route_timestamp = datetime.utcnow()
    db_session.commit()
    assert fuel_order.status == FuelOrderStatus.EN_ROUTE
    assert fuel_order.en_route_timestamp is not None

def test_fuel_order_relationships(db_session, test_aircraft, test_customer, test_user, test_fuel_truck):
    """Test fuel order relationships with other models."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        customer_id=test_customer.id,
        fuel_type='Jet A',
        requested_amount=1000.0,
        assigned_lst_user_id=test_user.id,
        assigned_truck_id=test_fuel_truck.id
    )
    
    db_session.add(fuel_order)
    db_session.commit()
    
    # Test relationships
    assert fuel_order.aircraft.tail_number == test_aircraft.tail_number
    assert fuel_order.customer.id == test_customer.id
    assert fuel_order.assigned_lst.id == test_user.id
    assert fuel_order.assigned_truck.id == test_fuel_truck.id

def test_fuel_order_metering(db_session, test_aircraft):
    """Test fuel order metering calculations."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        fuel_type='Jet A',
        requested_amount=1000.0,
        start_meter_reading=5000.0,
        end_meter_reading=6000.0
    )
    
    db_session.add(fuel_order)
    db_session.commit()
    
    # Test metering calculations
    assert fuel_order.calculated_gallons_dispensed == 1000.0
</file>

<file path="fbo-launchpad-backend/tests/test_permissions.py">
"""Tests for the permission system."""

import pytest
from flask import json
from src.models.user import User
from src.models.role import Role
from src.models.permission import Permission
from src.utils.decorators import require_permission
from flask import Blueprint, jsonify

# Create a test blueprint with protected routes
test_bp = Blueprint('test_bp', __name__)

@test_bp.route('/test-permission')
@require_permission('TEST_PERMISSION')
def test_permission_route():
    return jsonify({'message': 'success'})

def test_user_has_permission(app, client, db, test_users, test_permissions):
    """Test the user.has_permission() method."""
    with app.app_context():
        # Admin should have all permissions
        admin = test_users[0]  # First user is admin
        for perm in test_permissions:
            assert admin.has_permission(perm.name), f"Admin should have {perm.name} permission"

        # CSR should have specific permissions
        csr = test_users[1]  # Second user is CSR
        assert csr.has_permission('CREATE_ORDER'), "CSR should have CREATE_ORDER permission"
        assert csr.has_permission('MANAGE_ORDERS'), "CSR should have MANAGE_ORDERS permission"
        assert csr.has_permission('VIEW_USERS'), "CSR should have VIEW_USERS permission"
        assert not csr.has_permission('MANAGE_ROLES'), "CSR should not have MANAGE_ROLES permission"

        # LST should have limited permissions
        lst = test_users[2]  # Third user is LST
        assert lst.has_permission('VIEW_ORDERS'), "LST should have VIEW_ORDERS permission"
        assert lst.has_permission('COMPLETE_ORDER'), "LST should have COMPLETE_ORDER permission"
        assert not lst.has_permission('MANAGE_ORDERS'), "LST should not have MANAGE_ORDERS permission"
        assert not lst.has_permission('MANAGE_ROLES'), "LST should not have MANAGE_ROLES permission"

def test_permission_decorator(app, client, db, test_users, test_permissions):
    """Test the @require_permission decorator."""
    with app.app_context():
        # Register test route
        test_perm = Permission(name='TEST_PERMISSION')
        db.session.add(test_perm)
        db.session.commit()

        # Add test permission to admin role
        admin_role = test_users[0].roles[0]  # First user is admin
        admin_role.permissions.append(test_perm)
        db.session.commit()

        # Register blueprint
        app.register_blueprint(test_bp)

        # Test with admin (has permission)
        response = client.get('/test-permission', 
                            headers={'Authorization': f'Bearer {test_users[0].generate_token()}'})
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['message'] == 'success'

        # Test with CSR (no permission)
        response = client.get('/test-permission',
                            headers={'Authorization': f'Bearer {test_users[1].generate_token()}'})
        assert response.status_code == 403
        data = json.loads(response.data)
        assert 'error' in data
        assert 'Permission denied' in data['error']

        # Test with LST (no permission)
        response = client.get('/test-permission',
                            headers={'Authorization': f'Bearer {test_users[2].generate_token()}'})
        assert response.status_code == 403
        data = json.loads(response.data)
        assert 'error' in data
        assert 'Permission denied' in data['error']

def test_permission_inheritance(app, client, db, test_users, test_permissions):
    """Test that permissions are correctly inherited through roles."""
    with app.app_context():
        # Create a new role that inherits from CSR
        parent_role = test_users[1].roles[0]  # Second user is CSR
        child_role = Role(name='Child Role', description='Inherits from CSR')
        db.session.add(child_role)
        db.session.commit()

        # Create a user with the child role
        user = User(username='childuser', email='child@test.com', name='Child User')
        user.set_password('testpass')
        user.roles.append(child_role)
        db.session.add(user)
        db.session.commit()

        # Child role should have parent's permissions
        assert user.has_permission('CREATE_ORDER'), "User should inherit CREATE_ORDER permission"
        assert user.has_permission('MANAGE_ORDERS'), "User should inherit MANAGE_ORDERS permission"
        assert user.has_permission('VIEW_USERS'), "User should inherit VIEW_USERS permission"
        assert not user.has_permission('MANAGE_ROLES'), "User should not have MANAGE_ROLES permission"

def test_permission_caching(app, client, db, test_users, test_permissions):
    """Test that permission checks are properly cached."""
    with app.app_context():
        user = test_users[1]  # Second user is CSR
        perm_name = 'CREATE_ORDER'

        # First check should cache the result
        assert user.has_permission(perm_name), "User should have CREATE_ORDER permission"

        # Remove permission but don't clear cache
        role = user.roles[0]
        perm = next(p for p in role.permissions if p.name == perm_name)
        role.permissions.remove(perm)
        db.session.commit()

        # Should still return True from cache
        assert user.has_permission(perm_name), "Cached permission should still return True"

        # Clear cache and check again
        user.clear_permission_cache()
        assert not user.has_permission(perm_name), "Permission should be False after cache clear"

        # Restore permission
        role.permissions.append(perm)
        db.session.commit()

def test_user_with_multiple_roles(app, db, test_permissions):
    """Test user with multiple roles."""
    with app.app_context():
        # Create two roles with different permissions
        role1 = Role(name='Role1')
        view_orders = next(p for p in test_permissions if p.name == 'VIEW_ORDERS')
        role1.permissions.append(view_orders)
        role2 = Role(name='Role2')
        create_order = next(p for p in test_permissions if p.name == 'CREATE_ORDER')
        role2.permissions.append(create_order)
        
        db.session.add(role1)
        db.session.add(role2)
        
        # Create user with both roles
        user = User(username='multiuser', email='multi@test.com')
        user.set_password('testpass')
        user.roles.append(role1)
        user.roles.append(role2)
        
        db.session.add(user)
        db.session.commit()
        
        # User should have permissions from both roles
        assert user.has_permission('VIEW_ORDERS'), "User should have VIEW_ORDERS from Role1"
        assert user.has_permission('CREATE_ORDER'), "User should have CREATE_ORDER from Role2"
        assert not user.has_permission('MANAGE_ROLES'), "User should not have MANAGE_ROLES"

def test_require_permission_decorator(app, client, auth_headers):
    """Test @require_permission decorator."""
    with app.app_context():
        # Test admin access (has MANAGE_ROLES)
        response = client.get('/api/admin/roles/', headers=auth_headers['admin'])
        assert response.status_code == 200, "Admin should have access to roles endpoint"

        # Test CSR access (no MANAGE_ROLES)
        response = client.get('/api/admin/roles/', headers=auth_headers['csr'])
        assert response.status_code == 403, "CSR should be denied access to roles endpoint"

        # Test LST access (no MANAGE_ROLES)
        response = client.get('/api/admin/roles/', headers=auth_headers['lst'])
        assert response.status_code == 403, "LST should be denied access to roles endpoint"

        # Test unauthorized access
        response = client.get('/api/admin/roles/')
        assert response.status_code == 401, "Unauthorized request should be rejected"

def test_permission_edge_cases(app, db, test_permissions):
    """Test edge cases for permissions."""
    with app.app_context():
        # Test user with no roles
        user = User(username='noroles', email='noroles@test.com')
        user.set_password('testpass')
        db.session.add(user)
        db.session.commit()
        
        assert not user.has_permission('VIEW_ORDERS'), "User with no roles should have no permissions"
        
        # Test user with empty role (no permissions)
        empty_role = Role(name='Empty')
        db.session.add(empty_role)
        user.roles.append(empty_role)
        db.session.commit()
        
        assert not user.has_permission('VIEW_ORDERS'), "User with empty role should have no permissions"
        
        # Test non-existent permission
        assert not user.has_permission('NON_EXISTENT'), "Non-existent permission should return False"

def test_inactive_user_permissions(app, test_inactive_user, test_roles, test_permissions):
    """Test that inactive users can't use permissions."""
    with app.app_context():
        # Give the inactive user some permissions via a role
        csr_role = next(r for r in test_roles if r.name == 'Customer Service Representative')
        test_inactive_user.roles.append(csr_role)
        
        # Even though the user has the role, they should not have permission when inactive
        assert not test_inactive_user.has_permission('VIEW_ORDERS'), \
            "Inactive user should not have permissions"
</file>

<file path="fbo-launchpad-backend/tests/test_routes.py">
import pytest
import json
from datetime import datetime
from src.models.fuel_order import FuelOrderStatus

def test_create_fuel_order(client, test_aircraft, test_customer, test_user, test_fuel_truck):
    """Test creating a fuel order via API."""
    # Login first
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    response_data = json.loads(login_response.data)
    print(f"Login response: {response_data}")
    token = response_data['token']
    
    # Create fuel order
    headers = {'Authorization': f'Bearer {token}'}
    data = {
        'tail_number': test_aircraft.tail_number,
        'customer_id': test_customer.id,
        'fuel_type': 'Jet A',
        'additive_requested': False,
        'requested_amount': 1000.0,
        'assigned_lst_user_id': test_user.id,
        'assigned_truck_id': test_fuel_truck.id,
        'location_on_ramp': 'Gate A1',
        'csr_notes': 'Test order'
    }
    
    response = client.post('/fuel-orders/', 
                         json=data,
                         headers=headers)
    print(f"Create response: {response.data.decode()}")
    assert response.status_code == 201
    
    response_data = json.loads(response.data)
    assert response_data['tail_number'] == test_aircraft.tail_number
    assert response_data['status'] == FuelOrderStatus.DISPATCHED.value

def test_get_fuel_orders(client, db_session, test_aircraft, test_user):
    """Test getting list of fuel orders."""
    # Login
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    token = json.loads(login_response.data)['token']
    headers = {'Authorization': f'Bearer {token}'}
    
    # Get fuel orders
    response = client.get('/fuel-orders/', headers=headers)
    assert response.status_code == 200
    
    data = json.loads(response.data)
    assert 'fuel_orders' in data
    assert isinstance(data['fuel_orders'], list)
    assert 'pagination' in data

def test_update_fuel_order_status(client, db_session, test_aircraft, test_csr_user, test_lst_user, test_fuel_truck):
    """Test updating fuel order status."""
    # Login as CSR
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    token = json.loads(login_response.data)['token']
    headers = {'Authorization': f'Bearer {token}'}
    
    # Create a fuel order first
    create_data = {
        'tail_number': test_aircraft.tail_number,
        'fuel_type': 'Jet A',
        'additive_requested': False,
        'requested_amount': 1000.0,
        'assigned_lst_user_id': test_lst_user.id,
        'assigned_truck_id': test_fuel_truck.id,
        'location_on_ramp': 'Gate A1',
        'csr_notes': 'Test order'
    }
    create_response = client.post('/fuel-orders/', 
                                json=create_data,
                                headers=headers)
    print(f"Create response: {create_response.data.decode()}")
    assert create_response.status_code == 201
    fuel_order_id = json.loads(create_response.data)['id']
    
    # Update status
    update_data = {
        'status': 'Acknowledged',
        'assigned_truck_id': test_fuel_truck.id
    }
    response = client.put(f'/fuel-orders/{fuel_order_id}/',
                         json=update_data,
                         headers=headers)
    assert response.status_code == 200
    
    updated_data = json.loads(response.data)
    assert updated_data['status'] == FuelOrderStatus.ACKNOWLEDGED.value
    assert updated_data['assigned_truck_id'] == test_fuel_truck.id

def test_complete_fuel_order(client, test_aircraft, test_csr_user, test_lst_user, test_fuel_truck):
    # Login as CSR
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    csr_token = json.loads(login_response.data)['token']
    auth_headers_csr = {'Authorization': f'Bearer {csr_token}'}
    
    # Login as LST
    login_response = client.post('/auth/login', json={
        'email': 'testlst@example.com',
        'password': 'csrpass'  # LST users also use csrpass in tests
    })
    assert login_response.status_code == 200
    lst_token = json.loads(login_response.data)['token']
    auth_headers_lst = {'Authorization': f'Bearer {lst_token}'}

    # Create a fuel order as CSR
    response = client.post('/fuel-orders/', json={
        'tail_number': test_aircraft.tail_number,
        'fuel_type': 'Jet A',
        'requested_amount': 1000.0,
        'location_on_ramp': 'Gate A1',
        'csr_notes': 'Test order',
        'assigned_truck_id': test_fuel_truck.id,
        'assigned_lst_user_id': test_lst_user.id,
        'additive_requested': False
    }, headers=auth_headers_csr)
    assert response.status_code == 201
    order_data = json.loads(response.data)

    # LST acknowledges the order
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'ACKNOWLEDGED',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_lst)
    assert response.status_code == 200

    # LST marks en route
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'EN_ROUTE',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_lst)
    assert response.status_code == 200

    # LST marks fueling
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'FUELING',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_lst)
    print(f"Fueling response: {response.data.decode()}")
    assert response.status_code == 200

    # LST completes the order with meter readings
    response = client.put(f'/fuel-orders/{order_data["id"]}/submit-data', json={
        'start_meter_reading': 1000.0,
        'end_meter_reading': 1950.0,
        'lst_notes': 'Completed fueling'
    }, headers=auth_headers_lst)
    print(f"Complete response: {response.data.decode()}")
    assert response.status_code == 200

    # CSR reviews the order
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'REVIEWED',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_csr)
    print(f"Review response: {response.data.decode()}")
    assert response.status_code == 200
</file>

<file path="fbo-launchpad-backend/tests/test_users.py">
"""Tests for user management endpoints."""

import pytest
import json
from src.models.user import User
from src.models.role import Role

def test_get_users_list(client, auth_headers, test_users):
    """Test GET /api/users endpoint."""
    # Test unauthorized access
    response = client.get('/api/users')
    assert response.status_code == 401

    # Test access with CSR role (should have VIEW_USERS permission)
    response = client.get('/api/users', headers=auth_headers['csr'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert isinstance(data['users'], list)
    assert len(data['users']) > 0
    for user in data['users']:
        assert 'id' in user
        assert 'email' in user
        assert 'name' in user
        assert 'roles' in user
        assert isinstance(user['roles'], list)

    # Test access with LST role (should have VIEW_USERS permission)
    response = client.get('/api/users', headers=auth_headers['lst'])
    assert response.status_code == 200

    # Test access with admin role
    response = client.get('/api/users', headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert isinstance(data['users'], list)
    assert len(data['users']) > 0

def test_get_user_detail(client, auth_headers, test_users):
    """Test GET /api/users/<id> endpoint."""
    user_id = test_users['csr'].id

    # Test unauthorized access
    response = client.get(f'/api/users/{user_id}')
    assert response.status_code == 401

    # Test access with CSR role (should have VIEW_USERS permission)
    response = client.get(f'/api/users/{user_id}', headers=auth_headers['csr'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['id'] == user_id
    assert 'email' in data
    assert 'name' in data
    assert 'roles' in data
    assert isinstance(data['roles'], list)

    # Test access with LST role (should have VIEW_USERS permission)
    response = client.get(f'/api/users/{user_id}', headers=auth_headers['lst'])
    assert response.status_code == 200

    # Test access with admin role
    response = client.get(f'/api/users/{user_id}', headers=auth_headers['admin'])
    assert response.status_code == 200

    # Test non-existent user
    response = client.get('/api/users/999999', headers=auth_headers['admin'])
    assert response.status_code == 404

def test_create_user(client, auth_headers, test_roles):
    """Test POST /api/admin/users endpoint."""
    new_user_data = {
        'name': 'New Test User',
        'email': 'newtest@test.com',
        'password': 'testpass123',
        'roles': ['Customer Service Representative']
    }

    # Test unauthorized access
    response = client.post('/api/admin/users', json=new_user_data)
    assert response.status_code == 401

    # Test access with CSR role (should not have MANAGE_USERS permission)
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test access with LST role (should not have MANAGE_USERS permission)
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful creation with admin role
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['admin'])
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['email'] == new_user_data['email']
    assert data['name'] == new_user_data['name']
    assert len(data['roles']) == 1
    assert data['roles'][0]['name'] == 'Customer Service Representative'

    # Verify user exists in database with correct roles
    user = User.query.filter_by(email=new_user_data['email']).first()
    assert user is not None
    assert user.name == new_user_data['name']
    assert len(user.roles) == 1
    assert user.roles[0].name == 'Customer Service Representative'

    # Test duplicate email
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['admin'])
    assert response.status_code == 409

def test_update_user(client, auth_headers, test_users, test_roles):
    """Test PUT /api/admin/users/<id> endpoint."""
    user_id = test_users['csr'].id
    update_data = {
        'name': 'Updated Name',
        'email': 'updated@test.com',
        'roles': ['Line Service Technician']
    }

    # Test unauthorized access
    response = client.put(f'/api/admin/users/{user_id}', json=update_data)
    assert response.status_code == 401

    # Test access with CSR role (should not have MANAGE_USERS permission)
    response = client.put(f'/api/admin/users/{user_id}', json=update_data, headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test access with LST role (should not have MANAGE_USERS permission)
    response = client.put(f'/api/admin/users/{user_id}', json=update_data, headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful update with admin role
    response = client.put(f'/api/admin/users/{user_id}', json=update_data, headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['email'] == update_data['email']
    assert data['name'] == update_data['name']
    assert len(data['roles']) == 1
    assert data['roles'][0]['name'] == 'Line Service Technician'

    # Verify changes in database
    user = User.query.get(user_id)
    assert user.email == update_data['email']
    assert user.name == update_data['name']
    assert len(user.roles) == 1
    assert user.roles[0].name == 'Line Service Technician'

    # Test non-existent user
    response = client.put('/api/admin/users/999999', json=update_data, headers=auth_headers['admin'])
    assert response.status_code == 404

def test_delete_user(client, auth_headers, test_users):
    """Test DELETE /api/admin/users/<id> endpoint."""
    user_to_delete = test_users['lst']
    user_id = user_to_delete.id

    # Test unauthorized access
    response = client.delete(f'/api/admin/users/{user_id}')
    assert response.status_code == 401

    # Test access with CSR role (should not have MANAGE_USERS permission)
    response = client.delete(f'/api/admin/users/{user_id}', headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test access with LST role (should not have MANAGE_USERS permission)
    response = client.delete(f'/api/admin/users/{user_id}', headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful deletion with admin role
    response = client.delete(f'/api/admin/users/{user_id}', headers=auth_headers['admin'])
    assert response.status_code == 200

    # Verify user is deleted
    assert User.query.get(user_id) is None

    # Test non-existent user
    response = client.delete('/api/admin/users/999999', headers=auth_headers['admin'])
    assert response.status_code == 404

def test_user_role_assignment(client, auth_headers, test_users, test_roles):
    """Test role assignment functionality."""
    user = test_users['csr']
    lst_role = Role.query.filter_by(name='Line Service Technician').first()

    # Add LST role to CSR user
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative', 'Line Service Technician']
    }

    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user has both roles
    assert len(data['roles']) == 2
    role_names = [role['name'] for role in data['roles']]
    assert 'Customer Service Representative' in role_names
    assert 'Line Service Technician' in role_names

    # Verify permissions from both roles
    user = User.query.get(user.id)
    assert user.has_permission('CREATE_ORDER')  # CSR permission
    assert user.has_permission('VIEW_ORDERS')   # LST permission
    assert user.has_permission('MANAGE_ORDERS') # CSR permission
    assert user.has_permission('VIEW_AIRCRAFT') # Both roles
    assert user.has_permission('VIEW_TRUCKS')   # Both roles

def test_user_role_removal(client, auth_headers, test_users, test_roles):
    """Test role removal functionality."""
    user = test_users['csr']
    
    # First add LST role
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative', 'Line Service Technician']
    }
    
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    
    # Then remove CSR role
    update_data['roles'] = ['Line Service Technician']
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user only has LST role
    assert len(data['roles']) == 1
    assert data['roles'][0]['name'] == 'Line Service Technician'
    
    # Verify permissions reflect only LST role
    user = User.query.get(user.id)
    assert user.has_permission('VIEW_ORDERS')     # LST permission
    assert user.has_permission('VIEW_AIRCRAFT')   # LST permission
    assert user.has_permission('VIEW_TRUCKS')     # LST permission
    assert not user.has_permission('MANAGE_ORDERS') # Lost CSR permission

def test_user_deactivation(client, auth_headers, test_users):
    """Test user deactivation functionality."""
    user = test_users['csr']
    
    # Deactivate user
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative'],
        'is_active': False
    }
    
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user is inactive
    assert not data['is_active']
    
    # Verify user cannot log in
    response = client.post('/api/auth/login', json={
        'email': user.email,
        'password': 'testpass'
    })
    assert response.status_code == 401
    data = json.loads(response.data)
    assert 'Account is inactive' in data['error']

def test_user_reactivation(client, auth_headers, test_users):
    """Test user reactivation functionality."""
    user = test_users['inactive']
    
    # Reactivate user
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative'],
        'is_active': True
    }
    
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user is active
    assert data['is_active']
    
    # Verify user can log in
    response = client.post('/api/auth/login', json={
        'email': user.email,
        'password': 'testpass'
    })
    assert response.status_code == 200
    assert 'token' in json.loads(response.data)
</file>

<file path="fbo-launchpad-backend/config.py">
import os
from datetime import timedelta

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard-to-guess-string'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'jwt-secret-string'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)
    
    @staticmethod
    def init_app(app):
        pass

class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'postgresql://localhost/fbo_launchpad_dev'

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \
        'postgresql://localhost/fbo_launchpad_test'
    WTF_CSRF_ENABLED = False

class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')

config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
</file>

<file path="fbo-launchpad-backend/create_admin.py">
from src.models.user import User, UserRole
from src.extensions import db
from src.app import create_app

def create_admin_user():
    app = create_app()
    with app.app_context():
        # Check if admin already exists
        if User.query.filter_by(email='admin@fbolaunchpad.com').first():
            print("Admin user already exists!")
            return
        
        # Create new admin user
        admin = User(
            email='admin@fbolaunchpad.com',
            username='admin',
            role=UserRole.ADMIN,
            is_active=True
        )
        admin.set_password('Admin123!')
        
        # Save to database
        db.session.add(admin)
        db.session.commit()
        print("Admin user created successfully!")

if __name__ == '__main__':
    create_admin_user()
</file>

<file path="fbo-launchpad-backend/init.sql">
-- Drop test database if it exists
DROP DATABASE IF EXISTS fbo_launchpad_test;

-- Create test database
CREATE DATABASE fbo_launchpad_test;

-- Connect to test database
\c fbo_launchpad_test

-- Create extensions if needed
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Grant privileges
GRANT ALL PRIVILEGES ON DATABASE fbo_launchpad_test TO fbo_user;
</file>

<file path="fbo-launchpad-backend/pytest.ini">
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Display all test results, including passing ones
addopts = -v

# Environment variables for testing
env =
    FLASK_ENV=testing
    FLASK_APP=src/app.py
    SECRET_KEY=test-secret-key

# Markers for test categorization
markers =
    auth: authentication related tests
    models: database model tests
    routes: API route tests
    integration: integration tests

# Logging configuration
log_cli = true
log_cli_level = INFO
log_cli_format = %(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)
log_cli_date_format = %Y-%m-%d %H:%M:%S
</file>

<file path="fbo-launchpad-backend/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    error-documentation.mdc
    lessons-learned.mdc
docs/
  architecture.md
  error-documentation.md
  frontend_integration_guide.md
  fuel_order_queue_api.md
  fuel_order_routes_api_docs.md
  lessons-learned.md
  networkDocumentation.md
  product_requirement_docs.md
  technical.md
  testing_documentation.md
  testingContext.md
fbo_launchpad_backend.egg-info/
  dependency_links.txt
  PKG-INFO
  requires.txt
  SOURCES.txt
  top_level.txt
migrations/
  versions/
    05eadf8716a5_implement_pbac_models_permission_role_.py
    1a764e4d3fa2_add_fuel_truck_customer_aircraft_fuel_.py
    1ba38c67c062_create_user_table.py
    ae3b7293103c_add_aircraft_type_column_to_aircraft_.py
    f1d4eec2dff2_add_is_active_column_back_to_users_table.py
  alembic.ini
  env.py
  README
  script.py.mako
src/
  models/
    __init__.py
    aircraft.py
    base.py
    customer.py
    fuel_order.py
    fuel_truck.py
    permission.py
    role_permission.py
    role.py
    settings.py
    user.py
  routes/
    admin/
      aircraft_admin_routes.py
      assignment_settings_routes.py
      customer_admin_routes.py
      permission_admin_routes.py
      role_admin_routes.py
      user_admin_routes.py
    auth/
      auth_routes.py
    __init__.py
    aircraft_routes.py
    auth_routes.py
    customer_routes.py
    fuel_order_queue_routes.py
    fuel_order_routes.py
    fuel_truck_routes.py
    user_routes.py
  schemas/
    __init__.py
    admin_schemas.py
    aircraft_schemas.py
    auth_schema.py
    auth_schemas.py
    customer_schemas.py
    fuel_order_schemas.py
    fuel_truck_schemas.py
    permission_schemas.py
    role_schemas.py
    user_schemas.py
  services/
    __init__.py
    aircraft_service.py
    auth_service.py
    customer_service.py
    fuel_order_service.py
    fuel_truck_service.py
    permission_service.py
    role_service.py
    user_service.py
  utils/
    __init__.py
    auth.py
    decorators.py
    README.md
  __init__.py
  app.py
  cli.py
  config.py
  extensions.py
tasks/
  active_Context.md
  tasks_plan.md
tests/
  conftest.py
  test_admin_permissions.py
  test_admin_roles.py
  test_admin_users.py
  test_auth.py
  test_fuel_order_api.py
  test_fuel_orders.py
  test_fuel_trucks.py
  test_models.py
  test_permissions.py
  test_routes.py
  test_users.py
.gitignore
config.py
create_admin.py
docker-compose.yml
Dockerfile
pytest.ini
requirements.txt
setup.py
test-requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/error-documentation.mdc">
---
description: Error documentation
globs: 
alwaysApply: false
---
# Error Documentation

## Database Transaction Management

### Pattern: SQLAlchemy Session Rollback
When handling database operations that may fail, always:
1. Wrap operations in try-except blocks
2. Catch specific exceptions (IntegrityError, SQLAlchemyError)
3. Roll back the session on error
4. Return appropriate error status codes

Example from RoleService:
```python
try:
    # Database operations...
    db.session.commit()
except IntegrityError:
    db.session.rollback()
    return None, "Role name must be unique", 409
except SQLAlchemyError as e:
    db.session.rollback()
    return None, f"Database error: {str(e)}", 500
```

### Pattern: Many-to-Many Relationship Management
When managing many-to-many relationships:
1. Clear relationships before deletion (e.g., `role.permissions = []`)
2. Check for existing relationships before adding (e.g., `permission in role.permissions`)
3. Verify both entities exist before establishing relationship
4. Handle removal of non-existent relationships gracefully

Example from RoleService:
```python
# Before deleting role
role.permissions = []  # Clear relationships
db.session.delete(role)

# Before adding relationship
if permission in role.permissions:
    return role, "Permission already assigned to role", 200
```

### Pattern: Cascading Delete Protection
Before deleting entities that may have dependent relationships:
1. Check for existing dependencies
2. Return appropriate error if dependencies exist
3. Clear relationships if deletion is allowed

Example from RoleService:
```python
if role.users.first():
    return False, "Cannot delete role: Users are currently assigned to this role", 409
```

## Input Validation

### Pattern: Required Field Validation
Always validate required fields before database operations:
```python
if not data.get('name'):
    return None, "Role name is required", 400
```

### Pattern: Uniqueness Validation
When updating unique fields:
1. Check for duplicates excluding current entity
2. Use appropriate filters in query
3. Handle IntegrityError as backup

Example:
```python
existing_role = Role.query.filter(
    Role.name == data['name'],
    Role.id != role_id
).first()
if existing_role:
    return None, f"Role with name '{data['name']}' already exists", 409
```
</file>

<file path=".cursor/rules/lessons-learned.mdc">
---
description: 
globs: 
alwaysApply: false
---
# Lessons Learned

## SQLAlchemy Best Practices

### Many-to-Many Relationship Management
1. **Eager Loading**
   - Use `selectinload` for many-to-many relationships to prevent N+1 queries
   - Example from UserService:
   ```python
   User.query.options(db.selectinload(User.roles))
   ```
   - Prefer `selectinload` over `joinedload` for collections unless you need filtering

2. **Relationship Assignment**
   - Directly assign lists of model objects to relationship attributes
   - SQLAlchemy handles the association table updates automatically
   - Example:
   ```python
   user.roles = roles  # SQLAlchemy manages user_roles table inserts/deletes
   ```

3. **Input Validation**
   - Validate both format and content of relationship IDs
   - Check for list type and non-empty requirements
   - Verify all IDs exist before assignment
   - Example from UserService:
   ```python
   if not isinstance(role_ids, list):
       return None, "Invalid role_ids format, must be a list", 400
   roles = Role.query.filter(Role.id.in_(role_ids)).all()
   if len(roles) != len(set(role_ids)):
       found_ids = {role.id for role in roles}
       invalid_ids = set(role_ids) - found_ids
       return None, f"Invalid role IDs provided: {list(invalid_ids)}", 400
   ```

4. **Empty Relationship Handling**
   - Allow explicit clearing of relationships with empty lists
   - Validate business rules for required relationships
   - Example:
   ```python
   if not role_ids:  # Empty list check
       return None, "At least one role must be assigned", 400
   ```

## API Design Patterns

### Request/Response Structure
1. **Consistent Return Format**
   - Use tuple pattern: (result, message, status_code)
   - Return None for data on errors
   - Include descriptive error messages
   - Example:
   ```python
   return user, "User created successfully", 201
   return None, "Invalid role IDs provided", 400
   ```

2. **Input Validation Hierarchy**
   - Validate format before content
   - Check required fields first
   - Validate relationships after basic fields
   - Example order:
   ```python
   # 1. Required fields
   if not all(key in data for key in ['email', 'password', 'role_ids']):
       return None, "Missing required fields", 400
   # 2. Format validation
   if not isinstance(role_ids, list):
       return None, "Invalid format", 400
   # 3. Content validation
   if User.query.filter_by(email=data['email']).first():
       return None, "Email already registered", 409
   # 4. Relationship validation
   roles = Role.query.filter(Role.id.in_(role_ids)).all()
   ```

## Migration Strategies

### Enum to Many-to-Many Migration
1. **Staged Approach**
   - First create new tables and relationships
   - Then migrate data from old to new structure
   - Finally remove old fields/tables
   - Keep backward compatibility during transition

2. **Data Validation**
   - Verify all data is migrated correctly
   - Ensure no access is lost during migration
   - Maintain data integrity throughout process

3. **Code Updates**
   - Update service layer first
   - Then update route handlers
   - Finally update frontend integration
   - Test thoroughly at each stage
</file>

<file path="docs/architecture.md">
# System Patterns

## Architectural Overview

### 1. Application Structure
```
Flask Application
├── Application Factory
├── Blueprints (Feature Modules)
├── Services (Business Logic)
└── Models (Data Layer)
```

### 2. Request Flow
```
Request → JWT Auth → Role Check → Route Handler → Service → Database
```

## Core Patterns

### 1. Authentication Pattern
```python
# Decorator Chain
@token_required
@require_role(Role1, Role2)
def endpoint():
    pass
```

- JWT token validation
- Role verification
- User status check
- Current user in g.current_user

### 2. Service Pattern
```python
class BaseService:
    def __init__(self, model):
        self.model = model

class UserService(BaseService):
    def get_users(self, filters=None):
        query = self.model.query
        if filters:
            query = self.apply_filters(query, filters)
        return query.paginate()
```

### 3. Response Pattern
```python
{
    "data": [/* items */],
    "pagination": {
        "page": 1,
        "per_page": 20,
        "total": 100
    },
    "error": null
}
```

### 4. Error Handling Pattern
```python
class APIError(Exception):
    def __init__(self, message, status_code):
        self.message = message
        self.status_code = status_code

@app.errorhandler(APIError)
def handle_api_error(error):
    return jsonify({
        "error": error.message
    }), error.status_code
```

## Database Patterns

### 1. Model Definition
```python
class BaseModel(db.Model):
    __abstract__ = True
    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
```

### 2. Relationship Patterns
- One-to-Many: User → FuelOrders
- Many-to-One: FuelOrder → Customer
- Many-to-Many: Aircraft ↔ Customers

### 3. Query Patterns
```python
# Base query with joins
query = Model.query.join(Related)

# Filter chain
query = (query
    .filter(Model.field == value)
    .order_by(Model.created_at)
    .paginate())
```

## API Patterns

### 1. URL Structure
```
/api/<resource>/                 # Collection
/api/<resource>/<id>/           # Instance
/api/<resource>/<id>/<action>   # Action
```

### 2. HTTP Methods
- GET: Retrieve
- POST: Create
- PUT: Update (Full)
- PATCH: Update (Partial)
- DELETE: Remove

### 3. Query Parameters
```
?page=1              # Pagination
?per_page=20         # Items per page
?sort=field          # Sorting
?filter[key]=value   # Filtering
```

## Security Patterns

### 1. Permission-Based Access Control (PBAC)
```python
# Permission Check Method
class User(BaseModel):
    roles = db.relationship('Role', secondary='user_roles')

    def has_permission(self, permission_name):
        return any(
            permission.name == permission_name
            for role in self.roles
            for permission in role.permissions
        )

# Permission Decorator
@require_permission('PERMISSION_NAME')
def protected_endpoint():
    pass
```

### 2. Password Handling
```python
class User(BaseModel):
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
```

### 3. Token Pattern
```python
{
    "sub": user_id,
    "exp": expiration_time
}
```

## User Management Patterns

### 1. User Status Management
```python
class User(BaseModel):
    is_active = db.Column(db.Boolean, nullable=False, default=True)
    roles = db.relationship('Role', secondary='user_roles')
    
    def deactivate(self):
        self.is_active = False
        
    def activate(self):
        self.is_active = True
```

### 2. User Creation Pattern
```python
@require_permission('MANAGE_USERS')
def create_user():
    # Validate role IDs exist
    roles = Role.query.filter(Role.id.in_(data['role_ids'])).all()
    if len(roles) != len(data['role_ids']):
        raise ValueError("Invalid role IDs provided")
        
    user = User(
        email=data['email'],
        username=data.get('name', data['email'].split('@')[0]),
        is_active=data.get('is_active', True)
    )
    user.set_password(data['password'])
    user.roles = roles
```

### 3. User Status Check Pattern
```python
def authenticate_user(email, password):
    user = User.query.options(db.selectinload(User.roles)).filter_by(email=email).first()
    if not user or not user.is_active:
        raise ValueError("Invalid credentials or inactive account")
    if not user.check_password(password):
        raise ValueError("Invalid credentials")
    return user
```

### 4. User Management Endpoints
```
# Admin User Management API
GET    /api/admin/users/        # List users (VIEW_USERS)
POST   /api/admin/users/        # Create user (MANAGE_USERS)
GET    /api/admin/users/<id>/   # Get user details (VIEW_USERS)
PATCH  /api/admin/users/<id>/   # Update user (MANAGE_USERS)
DELETE /api/admin/users/<id>/   # Soft delete user (MANAGE_USERS)

# Role Management API
GET    /api/admin/roles/        # List roles (VIEW_ROLES)
POST   /api/admin/roles/        # Create role (MANAGE_ROLES)
PATCH  /api/admin/roles/<id>/   # Update role (MANAGE_ROLES)
DELETE /api/admin/roles/<id>/   # Delete role (MANAGE_ROLES)

# Permission Management API
GET    /api/admin/permissions/  # List permissions (VIEW_PERMISSIONS)
```

## Testing Patterns

### 1. Fixture Pattern
```python
@pytest.fixture
def test_user():
    user = User(
        email="test@example.com",
        role=UserRole.CSR
    )
    user.set_password("password")
    return user
```

### 2. Test Structure
```python
def test_endpoint(client, auth_headers):
    response = client.get(
        "/api/resource",
        headers=auth_headers
    )
    assert response.status_code == 200
```

### 3. Mock Pattern
```python
@patch("service.external_api")
def test_with_mock(mock_api):
    mock_api.return_value = {"data": "test"}
    # Test implementation
```

## Documentation Patterns

### 1. OpenAPI Documentation
```python
"""
---
get:
  summary: Endpoint description
  parameters:
    - name: param
      in: query
      type: string
  responses:
    200:
      description: Success
"""
```

### 2. Code Documentation
```python
def function(param):
    """Short description.

    Detailed description.

    Args:
        param: Parameter description

    Returns:
        Return value description

    Raises:
        ErrorType: Error description
    """
```
</file>

<file path="docs/error-documentation.md">
# Error Documentation

This document records the major failure points encountered in the FBO LaunchPad project and how they were resolved.

## 1. PostCSS Plugin Loading Failure
**Symptoms:**
- Build-time error in Vite: `Failed to load PostCSS config: Cannot find module '@tailwindcss/postcss'`.

**Cause:**
- Incorrect plugin key in `postcss.config.cjs` (`'@tailwindcss/postcss'` instead of `'tailwindcss'`).

**Resolution:**
1. Updated `postcss.config.cjs` to:
   ```js
   module.exports = {
     plugins: {
       'postcss-nesting': {},
       'tailwindcss': {},
       autoprefixer: {},
     }
   }
   ```
2. Installed missing dependencies:
   ```bash
   npm install -D tailwindcss postcss autoprefixer postcss-nesting
   ```

---

## 2. `process is not defined` in Vite
**Symptoms:**
- Runtime error in console: `ReferenceError: process is not defined` in `useOrders.ts`.

**Cause:**
- Frontend code was accessing `process.env` directly in a Vite project.

**Resolution:**
1. Switched to Vite-specific environment access:
   ```ts
   const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;
   ```
2. Added `src/vite-env.d.ts` for TypeScript definitions:
   ```ts
   /// <reference types="vite/client" />
   interface ImportMetaEnv {
     readonly VITE_API_BASE_URL: string;
   }
   interface ImportMeta { readonly env: ImportMetaEnv }
   ```
3. Created `.env` in the frontend root with:
   ```env
   VITE_API_BASE_URL=http://localhost:5000/api
   ```

---

## 3. Network Error Fetching Orders
**Symptoms:**
- Frontend error: `Error Loading orders: Network Error` when calling `/orders` endpoint.

**Causes & Resolutions:**
- **Backend not running:** Started Flask server:
  ```bash
  cd fbo-launchpad-backend
  flask run --port 5001
  ```
- **Port mismatch:** Updated frontend environment or backend run port to match (e.g., `5001`).
- **Authentication missing:** Ensured login flow stores JWT in `localStorage` under `token` and included in request headers.

---

## 4. Other Common Issues
- **CORS Errors:** If present, configure Flask-CORS in the backend:
  ```py
  from flask_cors import CORS
  app = Flask(__name__)
  CORS(app, resources={r"/api/*": {"origins": "*"}})
  ```
- **Invalid JSON Responses:** Ensure backend API returns valid JSON with `data` field.

---

## 5. Alembic Migration Ordering and Session/Table Definition Issues (PBAC Phase 1)
**Symptoms:**
- Migration failed with `psycopg2.errors.UndefinedColumn: column users.role does not exist`.
- Migration failed with `UnboundLocalError: local variable 'session' referenced before assignment` and `UnboundLocalError: local variable 'roles_table_id' referenced before assignment`.

**Causes:**
- Attempted to read from `users.role` after dropping the column in the same migration script.
- Referenced session and table objects before they were defined due to reordering of migration steps.

**Resolution:**
1. Reordered migration logic to perform all data migration from `users.role` before dropping the column.
2. Moved session and table object definitions to before any use in the migration function.
3. Confirmed migration runs successfully and all data is migrated as intended.

---

## Authentication System Issues

### Circular Import Resolution
**Issue**: Circular imports between user, role, and permission models.
**Solution**: Use relative imports and move relationship tables to separate modules.
```python
# Before (problematic):
from src.models.user import User
from src.models.role import Role

# After (fixed):
from ..models.role_permission import role_permissions
```

### Rate Limiting in Tests
**Issue**: Rate limiting interfering with tests.
**Solution**: 
1. Added `reset_rate_limits()` function
2. Created autouse fixture to reset between tests
```python
@pytest.fixture(autouse=True)
def reset_rate_limiting():
    reset_rate_limits()
    yield
```

### Permission Cache Issues
**Issue**: Permission cache not properly invalidating between requests.
**Solution**:
1. Made cache request-scoped using Flask's `g` object
2. Added proper cache key format
3. Implemented automatic invalidation between requests
```python
cache_key = f'user_{self.id}_perm_{permission_name}'
if has_request_context():
    if not hasattr(g, '_permission_cache'):
        g._permission_cache = {}
```

### Role Assignment
**Issue**: Role assignment not working properly during registration.
**Solution**: 
1. Fixed role relationship in User model
2. Properly queried default role before assignment
3. Used list assignment for roles
```python
default_role = Role.query.filter_by(name='Customer Service Representative').first()
user.roles = [default_role]
```

### Missing Field Validation
**Issue**: Register endpoint not properly validating all required fields.
**Solution**: Added proper validation using Marshmallow schemas
```python
class RegisterRequestSchema(Schema):
    email = fields.Email(required=True)
    password = fields.String(required=True, validate=validate.Length(min=8))
    name = fields.String(required=False)
```

---

*Document last updated: YYYY-MM-DD*
</file>

<file path="docs/frontend_integration_guide.md">
# FBO LaunchPad Frontend Integration Guide

## Overview

FBO LaunchPad is a comprehensive Fixed Base Operator (FBO) management system designed to streamline aircraft fueling operations. The backend API provides a robust set of endpoints to support the digital fuel order workflow, focusing on the interaction between Customer Service Representatives (CSRs), Line Service Technicians (LSTs), and system administrators.

This guide details how to integrate a frontend application with the FBO LaunchPad backend API, specifically focusing on the CSR MVP functionality.

## API Base URL

The base URL for all API calls should be configured through environment variables in your frontend application:

```javascript
// Example using Vite environment variables
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api';
```

For local development, the default URL is: `http://localhost:5001/api`

## Authentication Flow

### Login Process

**Endpoint:** `POST /api/auth/login`

**Request:**
```json
{
    "email": "user@example.com",
    "password": "userpassword"
}
```

**Success Response (200 OK):**
```json
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
        "id": 1,
        "email": "user@example.com",
        "role": "CSR",
        "is_active": true
    }
}
```

**Error Response (401 Unauthorized):**
```json
{
    "error": "Invalid credentials"
}
```

### Using the JWT Token

After successful login, the JWT token must be included in all subsequent API requests:

```javascript
headers: {
    'Authorization': `Bearer ${access_token}`,
    'Content-Type': 'application/json'
}
```

**Note:** The JWT token expires after 1 hour. Users must re-login to obtain a new token as token refresh is not implemented in the MVP.

## Required CSR Endpoints

### 1. Get Active LSTs

**Purpose:** Retrieve a list of active Line Service Technicians for fuel order assignment.

**Endpoint:** `GET /api/users?role=LST&is_active=true`

**Headers:**
- `Authorization: Bearer <token>`

**Success Response (200 OK):**
```json
{
    "message": "Users retrieved successfully",
    "users": [
        {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com",
            "role": "LST",
            "is_active": true
        }
    ]
}
```

### 2. Get Active Fuel Trucks

**Purpose:** Retrieve a list of active fuel trucks for fuel order creation.

**Endpoint:** `GET /api/fuel-trucks?is_active=true`

**Headers:**
- `Authorization: Bearer <token>`

**Success Response (200 OK):**
```json
{
    "message": "Fuel trucks retrieved successfully",
    "fuel_trucks": [
        {
            "id": 1,
            "truck_number": "TRUCK001",
            "fuel_type": "Jet A",
            "capacity": "5000.00",
            "current_meter_reading": "1234.56",
            "is_active": true
        }
    ]
}
```

### 3. Create Fuel Order

**Purpose:** Create a new fuel order.

**Endpoint:** `POST /api/fuel-orders`

**Headers:**
- `Authorization: Bearer <token>`
- `Content-Type: application/json`

**Request Body:**
```json
{
    "aircraft_id": 1,
    "customer_id": 1,
    "fuel_type": "Jet A",
    "quantity": "1000.00",
    "assigned_lst_id": 1,
    "assigned_truck_id": 1,
    "notes": "Optional notes about the order"
}
```

**Success Response (201 Created):**
```json
{
    "message": "Fuel order created successfully",
    "fuel_order": {
        "id": 1,
        "status": "PENDING",
        "aircraft_id": 1,
        "customer_id": 1,
        "fuel_type": "Jet A",
        "quantity": "1000.00",
        "assigned_lst_id": 1,
        "assigned_truck_id": 1,
        "notes": "Optional notes about the order",
        "created_at": "2024-03-26T10:00:00Z"
    }
}
```

### 4. List Fuel Orders

**Purpose:** Retrieve a paginated list of fuel orders with optional filters.

**Endpoint:** `GET /api/fuel-orders`

**Headers:**
- `Authorization: Bearer <token>`

**Query Parameters:**
- `page` (optional, default: 1): Page number
- `per_page` (optional, default: 20): Items per page
- `status` (optional): Filter by order status (PENDING, IN_PROGRESS, COMPLETED, etc.)

**Success Response (200 OK):**
```json
{
    "message": "Fuel orders retrieved successfully",
    "fuel_orders": [
        {
            "id": 1,
            "status": "PENDING",
            "aircraft_id": 1,
            "customer_id": 1,
            "fuel_type": "Jet A",
            "quantity": "1000.00",
            "assigned_lst_id": 1,
            "assigned_truck_id": 1,
            "notes": "Optional notes about the order",
            "created_at": "2024-03-26T10:00:00Z"
        }
    ],
    "pagination": {
        "page": 1,
        "per_page": 20,
        "total": 50
    }
}
```

### 5. Get Single Fuel Order

**Purpose:** Retrieve detailed information about a specific fuel order.

**Endpoint:** `GET /api/fuel-orders/{order_id}`

**Headers:**
- `Authorization: Bearer <token>`

**Success Response (200 OK):**
```json
{
    "message": "Fuel order retrieved successfully",
    "fuel_order": {
        "id": 1,
        "status": "PENDING",
        "aircraft_id": 1,
        "customer_id": 1,
        "fuel_type": "Jet A",
        "quantity": "1000.00",
        "assigned_lst_id": 1,
        "assigned_truck_id": 1,
        "notes": "Optional notes about the order",
        "created_at": "2024-03-26T10:00:00Z",
        "updated_at": "2024-03-26T10:00:00Z",
        "aircraft": {
            "id": 1,
            "tail_number": "N12345",
            "aircraft_type": "Boeing 737"
        },
        "customer": {
            "id": 1,
            "name": "Example Airlines",
            "email": "contact@example.com"
        },
        "assigned_lst": {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com"
        }
    }
}
```

### 6. Mark Order as Reviewed

**Purpose:** Mark a completed fuel order as reviewed by CSR.

**Endpoint:** `PATCH /api/fuel-orders/{order_id}/review`

**Headers:**
- `Authorization: Bearer <token>`
- `Content-Type: application/json`

**Request Body:**
```json
{
    "review_notes": "Optional review notes"
}
```

**Success Response (200 OK):**
```json
{
    "message": "Fuel order reviewed successfully",
    "fuel_order": {
        "id": 1,
        "status": "REVIEWED",
        "review_notes": "Optional review notes",
        "reviewed_at": "2024-03-26T11:00:00Z"
    }
}
```

### 7. Export Orders to CSV

**Purpose:** Export fuel orders to CSV format.

**Endpoint:** `GET /api/fuel-orders/export`

**Headers:**
- `Authorization: Bearer <token>`

**Query Parameters:**
- `start_date` (optional): Filter orders from this date (YYYY-MM-DD)
- `end_date` (optional): Filter orders until this date (YYYY-MM-DD)
- `status` (optional): Filter by order status

**Success Response:**
- Content-Type: text/csv
- File download with fuel order data

## Core Data Models

### FuelOrder
```typescript
interface FuelOrder {
    id: number;
    status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'REVIEWED';
    aircraft_id: number;
    customer_id: number;
    fuel_type: string;
    quantity: string;  // Decimal as string
    assigned_lst_id: number;
    assigned_truck_id: number;
    notes?: string;
    created_at: string;  // ISO datetime
    updated_at: string;  // ISO datetime
    reviewed_at?: string;  // ISO datetime
    review_notes?: string;
}
```

### User (LST)
```typescript
interface User {
    id: number;
    name: string;
    email: string;
    role: 'LST';
    is_active: boolean;
}
```

### FuelTruck
```typescript
interface FuelTruck {
    id: number;
    truck_number: string;
    fuel_type: string;
    capacity: string;  // Decimal as string
    current_meter_reading: string;  // Decimal as string
    is_active: boolean;
}
```

## Error Handling

All endpoints follow a consistent error response format:

```json
{
    "error": "Human-readable error message"
}
```

Common HTTP Status Codes:
- 400: Bad Request (invalid input)
- 401: Unauthorized (invalid/missing token)
- 403: Forbidden (insufficient permissions)
- 404: Not Found
- 409: Conflict (e.g., duplicate data)
- 500: Internal Server Error

## Implementation Tips

1. Always include error handling for both network errors and API errors
2. Implement token expiration handling and redirect to login
3. Use proper decimal handling for fuel quantities (strings to avoid floating-point issues)
4. Implement proper date/time handling for ISO 8601 timestamps
5. Consider implementing a request interceptor for token management
6. Use proper type definitions for API responses
7. Implement proper loading states for async operations
</file>

<file path="docs/fuel_order_queue_api.md">
# Fuel Order Queue API Documentation

## Overview
Implements endpoints for the LST queue system, allowing LSTs to view and claim unassigned fuel orders.

## Endpoints

### 1. `GET /api/orders/unassigned`
- **Auth:** JWT required (LST role recommended)
- **Returns:** List of all unassigned fuel orders (where `assigned_lst_user_id` is null), ordered by `created_at` ascending.
- **Response Example:**
```json
{
  "orders": [
    {
      "id": 123,
      "tail_number": "N12345",
      "requested_amount": 250.0,
      "location_on_ramp": "Ramp A",
      "created_at": "2025-04-26T01:00:00Z",
      "fuel_type": "Jet A",
      "csr_notes": "Priority customer",
      "status": "Dispatched"
    },
    ...
  ]
}
```

### 2. `POST /api/orders/<order_id>/accept`
- **Auth:** JWT required (LST role enforced)
- **Purpose:** Allows an LST to claim an unassigned order. Only works if order is unassigned; atomic operation.
- **Request Body:** _None_
- **Response Example:**
```json
{
  "success": true,
  "order_id": 123,
  "assigned_lst_user_id": 42
}
```
- **Failure Responses:**
  - `403 Unauthorized` if not LST
  - `404 Not found` if order does not exist
  - `409 Conflict` if order already assigned

## Logic
- Orders are considered unassigned if `assigned_lst_user_id` is null.
- LSTs see a queue of all such orders and can claim one by sending a POST to `/accept`.
- On claim, the order is atomically assigned to the LST and status is updated to `ACKNOWLEDGED`.

## Related Files
- `src/routes/fuel_order_queue_routes.py`
- `src/models/fuel_order.py`

---

## Change History
- 2025-04-26: Initial implementation for LST queue system.
</file>

<file path="docs/fuel_order_routes_api_docs.md">
# Fuel Order Routes API Documentation

## Overview
This documentation covers the API endpoints implemented in `src/routes/fuel_order_routes.py` for handling fuel order operations in the backend. It includes route details, authentication, and special logic such as auto-assigning LST users.

---

## Endpoints

### 1. `GET /fuel-orders/stats/status-counts`
- **Purpose:** Get counts of fuel orders by status groups (Pending, In Progress, Completed).
- **Auth:** Requires CSR, ADMIN, or LST role (JWT-protected).
- **Responses:**
  - 200: Success, returns status counts.
  - 401/403/500: Error cases with descriptive messages.

### 2. `POST /fuel-orders/`
- **Purpose:** Create a new fuel order.
- **Auth:** Requires CSR, ADMIN, or LST role (JWT-protected).
- **Request Body:**
  - Required: `tail_number`, `fuel_type`, `assigned_lst_user_id`, `assigned_truck_id`, `requested_amount`, `location_on_ramp`
  - Optional: `customer_id`, `additive_requested`, `csr_notes`
- **Special Logic:**
  - If `assigned_lst_user_id` is set to `-1`, the backend will automatically select and assign the least busy active LST user using the following logic:
    - Queries all active LST users.
    - Counts their active/in-progress orders (`DISPATCHED`, `ACKNOWLEDGED`, `EN_ROUTE`, `FUELING`).
    - Assigns the LST with the fewest such orders.
    - Logs the auto-assignment for traceability.
  - If no LST is available, returns an error.
- **Responses:**
  - 201: Success, returns created fuel order.
  - 400/500: Error cases with descriptive messages.

---

## Special Constants
- `AUTO_ASSIGN_LST_ID = -1`: If this value is provided in the payload as `assigned_lst_user_id`, the backend will auto-select the least busy LST.

---

## Security
- All endpoints require JWT authentication.
- Role-based access enforced via decorators.

---

## Logging
- Each major step in the fuel order creation process is logged for debugging and auditing.
- Auto-assignment actions are specifically logged (assigned user and order count).

---

## Usage Notes
- The frontend should send `assigned_lst_user_id: -1` to enable backend auto-assignment of LST.
- All other validation and assignment logic remains unchanged.

---

# End of Documentation
</file>

<file path="docs/lessons-learned.md">
PBAC Migration Lessons (2025-05-02):
- When seeding roles and permissions in Alembic, always insert roles after permissions, then use a session to fetch IDs for mapping in association tables (role_permissions).
- Use op.bulk_insert for initial data, but fetch IDs with a session for correct mapping.
- Ensure downgrade reverses all seeded data in the correct order (role_permissions, then roles, then permissions).
- (2025-05-03) Always migrate user role assignments to the new user_roles table before dropping the old users.role column. Ensure downgrade deletes all user_roles links for reversibility and data integrity.
- (2025-05-04) When reordering Alembic migration steps, always perform all data migration logic that depends on old columns before dropping those columns. Define all session and table objects before use in any migration step to avoid UnboundLocalError or similar issues.
- (2025-05-05) Encapsulating permission-checking logic as a method on the User model (has_permission) keeps authorization logic close to the data and improves code readability and maintainability. Using SQLAlchemy's dynamic relationships and filter_by for permission checks is efficient and leverages the ORM's ability to generate optimized SQL EXISTS queries. This pattern is recommended for future PBAC or RBAC implementations.
- (2025-05-06) When implementing permission-based decorators, always check for authentication context (g.current_user) before permission checks, and return clear error codes/messages for both missing context (500) and permission denial (403). Remove obsolete role-based decorators to avoid confusion. This pattern ensures robust, maintainable route protection.

## Authentication System Implementation

### Best Practices
1. **Rate Limiting**
   - Implement rate limiting per endpoint rather than globally
   - Use separate stores for different endpoints
   - Reset limits on successful attempts
   - Make rate limiting configurable for testing

2. **Permission Management**
   - Use request-level caching for performance
   - Implement proper cache invalidation
   - Use SQLAlchemy EXISTS for efficient queries
   - Test permission inheritance thoroughly

3. **Testing**
   - Reset stateful components (like rate limiters) between tests
   - Test edge cases in authentication flows
   - Verify permission caching behavior
   - Include performance benchmarks

4. **Error Handling**
   - Provide specific error messages for each failure case
   - Include retry-after headers for rate limiting
   - Handle database errors gracefully
   - Log authentication failures appropriately

5. **Security**
   - Never store plaintext passwords
   - Use strong hashing algorithms (PBKDF2-SHA256)
   - Implement proper token expiration
   - Validate all input fields

### Architectural Decisions
1. **Permission Caching**
   - Chose request-level caching over global caching
   - Used Flask's `g` object for automatic cleanup
   - Implemented efficient permission checking with EXISTS

2. **Role System**
   - Used many-to-many relationships for flexibility
   - Implemented role inheritance
   - Made roles extensible for future changes

3. **Rate Limiting**
   - Per-endpoint stores for fine-grained control
   - IP-based limiting for security
   - Configurable windows and attempts
</file>

<file path="docs/networkDocumentation.md">
# FBO LaunchPad API Documentation

## Authentication

### Login Endpoint
```
POST /auth/login
Content-Type: application/json
```

**Request Body:**
```json
{
    "email": "string",
    "password": "string"
}
```

**Response (200 OK):**
```json
{
    "token": "string"  // JWT token for subsequent requests
}
```

**Usage Notes:**
- All subsequent API requests must include the JWT token in the Authorization header
- Format: `Authorization: Bearer <token>`
- Two types of users: CSR (Customer Service Representative) and LST (Line Service Technician)

## Fuel Orders API

### 1. Create Fuel Order
```
POST /fuel-orders/
Authorization: Bearer <token>
Content-Type: application/json
```

**Access:** CSR users only

**Request Body:**
```json
{
    "tail_number": "string",
    "fuel_type": "string",
    "requested_amount": "number",
    "location_on_ramp": "string",
    "csr_notes": "string",
    "assigned_truck_id": "number",
    "assigned_lst_user_id": "number",
    "additive_requested": "boolean",
    "customer_id": "number"  // optional
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "tail_number": "string",
    "customer_id": "number",
    "fuel_type": "string",
    "additive_requested": "boolean",
    "requested_amount": "number",
    "assigned_lst_user_id": "number",
    "assigned_truck_id": "number",
    "location_on_ramp": "string",
    "csr_notes": "string",
    "status": "string",  // Initially "Dispatched"
    "created_at": "string"  // ISO format datetime
}
```

### 2. Get Fuel Orders List
```
GET /fuel-orders/
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
    "fuel_orders": [
        {
            "id": "number",
            "status": "string",
            "tail_number": "string",
            "customer_id": "number",
            "fuel_type": "string",
            "additive_requested": "boolean",
            "requested_amount": "string",
            "assigned_lst_user_id": "number",
            "assigned_truck_id": "number",
            "location_on_ramp": "string",
            "start_meter_reading": "string",
            "end_meter_reading": "string",
            "calculated_gallons_dispensed": "string",
            "created_at": "string",
            "dispatch_timestamp": "string",
            "acknowledge_timestamp": "string",
            "en_route_timestamp": "string",
            "fueling_start_timestamp": "string"
        }
    ],
    "pagination": {
        "page": "number",
        "per_page": "number",
        "total_pages": "number",
        "total_items": "number",
        "has_next": "boolean",
        "has_prev": "boolean"
    }
}
```

### 3. Update Fuel Order Status
```
PUT /fuel-orders/{order_id}/
Authorization: Bearer <token>
Content-Type: application/json
```

**Request Body:**
```json
{
    "status": "string",  // Must be uppercase with underscores
    "assigned_truck_id": "number"
}
```

**Valid Status Values:**
- "DISPATCHED"
- "ACKNOWLEDGED"
- "EN_ROUTE"
- "FUELING"
- "COMPLETED"
- "REVIEWED"
- "CANCELLED"

**Response (200 OK):**
```json
{
    "id": "number",
    "tail_number": "string",
    "customer_id": "number",
    "fuel_type": "string",
    "additive_requested": "boolean",
    "requested_amount": "number",
    "assigned_lst_user_id": "number",
    "assigned_truck_id": "number",
    "location_on_ramp": "string",
    "csr_notes": "string",
    "status": "string",
    "updated_at": "string"
}
```

### 4. Submit Fuel Data (Complete Order)
```
PUT /fuel-orders/{order_id}/submit-data
Authorization: Bearer <token>
Content-Type: application/json
```

**Access:** LST users only

**Request Body:**
```json
{
    "start_meter_reading": "number",
    "end_meter_reading": "number",
    "lst_notes": "string"  // optional
}
```

**Validation Rules:**
- Order must be in "FUELING" status
- `end_meter_reading` must be greater than `start_meter_reading`
- Both meter readings must be non-negative

**Response (200 OK):**
```json
{
    "message": "Fuel data submitted successfully",
    "fuel_order": {
        "id": "number",
        "status": "string",
        "tail_number": "string",
        "start_meter_reading": "string",
        "end_meter_reading": "string",
        "calculated_gallons_dispensed": "string",
        "lst_notes": "string",
        "completion_timestamp": "string"
    }
}
```

## Fuel Order Workflow

1. **Order Creation (CSR)**
   - CSR creates order with initial details
   - Status: DISPATCHED

2. **LST Acknowledgment**
   - LST acknowledges the assigned order
   - Status: ACKNOWLEDGED

3. **En Route**
   - LST indicates they're heading to the aircraft
   - Status: EN_ROUTE

4. **Fueling**
   - LST begins fueling operation
   - Status: FUELING

5. **Completion**
   - LST submits meter readings and notes
   - Must use dedicated `/submit-data` endpoint
   - Status: COMPLETED

6. **Review**
   - CSR reviews the completed order
   - Status: REVIEWED

## Frontend Implementation Guidelines

1. **Authentication Flow**
   - Implement login screen
   - Store JWT token securely
   - Include token in all API requests
   - Handle token expiration

2. **Role-Based UI**
   - Show different views for CSR and LST users
   - CSR: Order creation, review, and overview
   - LST: Order acknowledgment, status updates, and completion

3. **Status Management**
   - Use exact status strings as specified
   - Implement status transition validation
   - Show appropriate action buttons based on current status

4. **Forms**
   - Validate all required fields
   - Format numbers appropriately
   - Handle optional fields
   - Show validation errors

5. **Real-time Updates**
   - Implement polling or WebSocket for order status updates
   - Show status changes in real-time

---

## Users API

### 1. Create User
```
POST /users/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string",
    "email": "string",
    "role": "string",  // ADMIN, CSR, LST
    "password": "string"
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "name": "string",
    "email": "string",
    "role": "string",
    "is_active": "boolean",
    "created_at": "string"
}
```

### 2. Get User List
```
GET /users/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "users": [
        {
            "id": "number",
            "name": "string",
            "email": "string",
            "role": "string",
            "is_active": "boolean",
            "created_at": "string"
        }
    ]
}
```

### 3. Update User
```
PATCH /users/{user_id}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string",  // optional
    "email": "string", // optional
    "role": "string",  // optional
    "is_active": "boolean" // optional
}
```

**Response (200 OK):**
```json
{
    "id": "number",
    "name": "string",
    "email": "string",
    "role": "string",
    "is_active": "boolean",
    "created_at": "string"
}
```

### 4. Delete User
```
DELETE /users/{user_id}
Authorization: Bearer <token>
```
**Access:** Admin only (soft delete)

**Response (200 OK):**
```json
{
    "message": "User deleted"
}
```

---

## Fuel Trucks API

### 1. Create Fuel Truck
```
POST /fuel-trucks/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "truck_number": "string",
    "fuel_type": "string",
    "capacity": "number",
    "current_meter_reading": "number"  // optional
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "truck_number": "string",
    "fuel_type": "string",
    "capacity": "number",
    "current_meter_reading": "number",
    "is_active": "boolean"
}
```

### 2. Get Fuel Truck List
```
GET /fuel-trucks/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "fuel_trucks": [
        {
            "id": "number",
            "truck_number": "string",
            "fuel_type": "string",
            "capacity": "number",
            "current_meter_reading": "number",
            "is_active": "boolean"
        }
    ]
}
```

### 3. Update Fuel Truck
```
PATCH /fuel-trucks/{truck_id}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "truck_number": "string", // optional
    "fuel_type": "string", // optional
    "capacity": "number", // optional
    "current_meter_reading": "number", // optional
    "is_active": "boolean" // optional
}
```

**Response (200 OK):**
```json
{
    "id": "number",
    "truck_number": "string",
    "fuel_type": "string",
    "capacity": "number",
    "current_meter_reading": "number",
    "is_active": "boolean"
}
```

### 4. Delete Fuel Truck
```
DELETE /fuel-trucks/{truck_id}
Authorization: Bearer <token>
```
**Access:** Admin only

**Response (200 OK):**
```json
{
    "message": "Fuel truck deleted"
}
```

---

## Aircraft API

### 1. Create Aircraft
```
POST /aircraft/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "tail_number": "string",
    "aircraft_type": "string", // optional
    "customer_id": "number" // optional
}
```

**Response (201 Created):**
```json
{
    "tail_number": "string",
    "aircraft_type": "string",
    "customer_id": "number"
}
```

### 2. Get Aircraft List
```
GET /aircraft/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "aircraft": [
        {
            "tail_number": "string",
            "aircraft_type": "string",
            "customer_id": "number"
        }
    ]
}
```

### 3. Update Aircraft
```
PATCH /aircraft/{tail_number}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "aircraft_type": "string", // optional
    "customer_id": "number" // optional
}
```

**Response (200 OK):**
```json
{
    "tail_number": "string",
    "aircraft_type": "string",
    "customer_id": "number"
}
```

### 4. Delete Aircraft
```
DELETE /aircraft/{tail_number}
Authorization: Bearer <token>
```
**Access:** Admin only

**Response (200 OK):**
```json
{
    "message": "Aircraft deleted"
}
```

---

## Customers API

### 1. Create Customer
```
POST /customers/
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string"
}
```

**Response (201 Created):**
```json
{
    "id": "number",
    "name": "string"
}
```

### 2. Get Customer List
```
GET /customers/
Authorization: Bearer <token>
```
**Access:** Admin, CSR

**Response (200 OK):**
```json
{
    "customers": [
        {
            "id": "number",
            "name": "string"
        }
    ]
}
```

### 3. Update Customer
```
PATCH /customers/{customer_id}
Authorization: Bearer <token>
Content-Type: application/json
```
**Access:** Admin only

**Request Body:**
```json
{
    "name": "string" // optional
}
```

**Response (200 OK):**
```json
{
    "id": "number",
    "name": "string"
}
```

### 4. Delete Customer
```
DELETE /customers/{customer_id}
Authorization: Bearer <token>
```
**Access:** Admin only

**Response (200 OK):**
```json
{
    "message": "Customer deleted"
}
```

---

### Inconsistencies/Required Changes
- All endpoint prefixes should be plural (e.g., `/users/`, `/fuel-trucks/`, `/aircraft/`, `/customers/`).
- Consistent use of snake_case for field names in backend, but some older docs and possibly frontend code use camelCase. **Frontend and docs should be updated to snake_case everywhere.**
- All numeric fields are returned as numbers, not strings, in real API responses.
- Status values for fuel orders must be uppercase with underscores (e.g., `DISPATCHED`).
- All timestamps are ISO 8601 strings.
- All CRUD endpoints require JWT in Authorization header.
- All create/update endpoints use POST/PATCH with JSON bodies.
- Fuel truck and aircraft uniqueness is enforced by `truck_number` and `tail_number` respectively.
- User deletion is soft (deactivation), but API returns a generic "deleted" message.

#### Additional File Changes Needed
- **Frontend code** (especially API calls, data models, and UI components) should be reviewed and updated to use snake_case for all fields to match backend and OpenAPI documentation.
- **Documentation** (including API docs and example payloads) should be standardized to snake_case for consistency and clarity.
   - Update order list when status changes

6. **Error Handling**
   - Handle all HTTP status codes
   - Show appropriate error messages
   - Implement retry logic where appropriate
</file>

<file path="docs/product_requirement_docs.md">
# FBO LaunchPad Backend Project Brief

## Project Overview
FBO LaunchPad is a comprehensive Fixed Base Operator (FBO) management system designed to streamline aircraft fueling operations. The backend provides a RESTful API that supports the core functionality of fuel order management, user authentication, and real-time status tracking.

## Core Requirements

### 1. User Management
- Support multiple user roles (CSR, LST, Admin)
- Secure authentication using JWT tokens
- Role-based access control for all operations
- User status tracking (active/inactive)

### 2. Fuel Order Management
- Complete fuel order lifecycle management
- Real-time status updates
- Meter reading validation
- Support for multiple fuel types
- Customer and aircraft tracking

### 3. Security
- JWT-based authentication
- Role-based authorization
- Secure password handling
- CORS protection for frontend integration

### 4. API Design
- RESTful architecture
- OpenAPI/Swagger documentation
- Consistent error handling
- Pagination for list endpoints

## Technical Goals
1. Maintainable and modular codebase
2. Comprehensive test coverage
3. Clear API documentation
4. Scalable database design
5. Efficient query optimization

## Success Criteria
1. All API endpoints documented and tested
2. 90%+ test coverage
3. Sub-second response times for common operations
4. Zero security vulnerabilities in authentication
5. Successful integration with frontend application

## Non-Functional Requirements
1. Response time < 1 second for 95% of requests
2. 99.9% uptime during operational hours
3. Support for concurrent users
4. Audit trail for all fuel operations
5. Backup and recovery procedures 

# Product Context

## Business Overview

FBO LaunchPad is a comprehensive Fixed Base Operator (FBO) management system designed to streamline aircraft fueling operations at airports. The system connects Customer Service Representatives (CSRs), Line Service Technicians (LSTs), and administrators in a seamless workflow for fuel order management.

## User Roles

### 1. Customer Service Representative (CSR)
- Primary point of contact for aircraft operators
- Creates and manages fuel orders
- Assigns orders to LSTs
- Reviews completed orders
- Manages customer relationships

### 2. Line Service Technician (LST)
- Executes fuel orders
- Updates order status in real-time
- Records fuel meter readings
- Ensures safety compliance
- Reports issues or concerns

### 3. Administrator
- Manages user accounts
- Oversees system operations
- Generates reports
- Configures system settings
- Monitors performance

## Core Workflows

### 1. Fuel Order Creation
```
Aircraft Arrival → CSR Creates Order → LST Assignment → Order Execution → Review
```

### 2. Order Execution
```
Order Receipt → Acknowledgment → En Route → Fueling → Completion → Review
```

### 3. User Management
```
User Creation → Role Assignment → Active Status → Access Control
```

## Business Rules

### 1. Order Management
- Only CSRs can create orders
- LSTs must acknowledge before starting
- Meter readings required for completion
- CSR review required for closure

### 2. User Access
- CSRs manage orders and assignments
- LSTs update order status and data
- Admins have full system access
- Inactive users cannot access system

### 3. Safety & Compliance
- Valid fuel truck assignment required
- Proper meter reading validation
- Complete order documentation
- Audit trail maintenance

## User Experience Goals

### 1. CSR Experience
- Quick order creation
- Clear LST availability status
- Real-time order tracking
- Efficient review process

### 2. LST Experience
- Clear order instructions
- Simple status updates
- Easy data entry
- Mobile-friendly interface

### 3. Admin Experience
- Comprehensive oversight
- Easy user management
- Clear reporting
- System configuration

## Integration Points

### 1. Frontend Application
- Real-time updates
- Responsive design
- Role-based views
- Error handling

### 2. Future Integrations
- Billing systems
- Aircraft tracking
- Weather services
- Maintenance systems

## Success Metrics

### 1. Operational
- Order completion time
- Accuracy of fuel delivery
- System uptime
- Error rate

### 2. User Satisfaction
- CSR efficiency
- LST task completion
- Admin oversight capability
- System reliability

### 3. Business Impact
- Reduced processing time
- Improved accuracy
- Better resource utilization
- Enhanced safety compliance

## Customer Requirements

### 1. Aircraft Operators
- Quick service request
- Accurate fuel delivery
- Clear communication
- Service documentation

### 2. FBO Management
- Operational oversight
- Staff management
- Performance tracking
- Compliance reporting

## Future Considerations

### 1. Feature Expansion
- Customer portal
- Mobile application
- Advanced analytics
- Automated scheduling

### 2. Integration Growth
- Payment processing
- Flight planning
- Inventory management
- Equipment tracking

### 3. Scalability
- Multi-location support
- Increased user capacity
- Enhanced reporting
- Advanced automation
</file>

<file path="docs/technical.md">
# Technical Context

## Technology Stack

### Core Framework
- **Flask** (v3.0.2): Main web framework
- **Flask-SQLAlchemy** (v3.1.1): ORM for database operations
- **Flask-Migrate** (v4.0.5): Database migration management
- **Flask-CORS** (v5.0.1): CORS support for frontend integration

### Authentication & Security
- **PyJWT** (v2.10.0): JWT token handling
- **Werkzeug**: Password hashing (pbkdf2:sha256)

### API Documentation
- **APISpec**: OpenAPI specification generation
- **Marshmallow**: Schema validation and serialization

### Testing
- **pytest**: Test framework
- **pytest-flask**: Flask testing utilities
- **pytest-env**: Environment variable management for tests

## Project Structure
```
fbo-launchpad-backend/
├── src/
│   ├── models/        # Database models
│   ├── routes/        # API endpoints
│   ├── schemas/       # Request/response schemas
│   ├── services/      # Business logic
│   └── utils/         # Shared utilities
├── tests/            # Test suite
└── memory-bank/      # Project documentation
```

## Key Design Patterns

### 1. Model-View-Service
- **Models**: Database schema definitions
- **Views**: Route handlers (controllers)
- **Services**: Business logic implementation

### 2. Repository Pattern
- Database operations abstracted in service layer
- Models define schema and relationships
- Services handle complex queries and transactions

### 3. Factory Pattern
- Application factory for Flask app creation
- Configurable environment settings
- Extension initialization

### 4. Decorator Pattern
- Authentication middleware (@token_required)
- Role-based access control (@require_role)
- Request validation

## Database Schema

### Core Tables
1. **users**
   - Authentication credentials
   - Many-to-many relationship to roles (user_roles)
   - Status tracking

2. **roles**
   - Role name and description
   - Many-to-many relationship to permissions (role_permissions)
   - Many-to-many relationship to users (user_roles)

3. **permissions**
   - Permission key (name) and description
   - Many-to-many relationship to roles (role_permissions)

4. **role_permissions** (association table)
   - Links roles.id and permissions.id

5. **user_roles** (association table)
   - Links users.id and roles.id

6. **fuel_orders**
   - Order details
   - Status tracking
   - Timestamps for workflow stages

7. **customers**
   - Customer information
   - Billing details

8. **aircraft**
   - Aircraft details
   - Maintenance records

9. **fuel_trucks**
   - Equipment tracking
   - Fuel type compatibility

## API Structure

### Authentication
- JWT-based token system
- 1-hour token expiration
- Role information embedded in token

### Request/Response Format
- JSON for all endpoints
- Consistent error response structure
- Pagination for list endpoints

### Error Handling
- HTTP status codes for different scenarios
- Detailed error messages
- Validation error formatting

## Development Workflow

### 1. Code Organization
- Modular blueprint structure
- Clear separation of concerns
- Consistent file naming

### 2. Testing Strategy
- Unit tests for services
- Integration tests for API
- Fixtures for common test data

### 3. Documentation
- OpenAPI/Swagger specs
- Inline code documentation
- Memory bank maintenance

## Deployment Considerations

### Environment Configuration
- Development: SQLite
- Testing: In-memory SQLite
- Production: PostgreSQL

### Security Measures
- CORS configuration
- Password hashing
- Token validation
- Role enforcement

### Performance
- Query optimization
- Connection pooling
- Proper indexing
- Caching strategy (future)

## Authentication System

### Overview
The authentication system uses JWT (JSON Web Tokens) for stateless authentication with Flask-JWT-Extended. It implements:
- Rate limiting per endpoint and IP address
- Permission-based access control (PBAC)
- Request-level permission caching
- Role-based user management

### Components

1. **User Model** (`src/models/user.py`)
- Handles user data and authentication
- Implements password hashing with `werkzeug.security`
- Provides permission checking with request-level caching
- Manages role relationships through SQLAlchemy

2. **Role System** (`src/models/role.py`)
- Defines user roles (Admin, CSR, LST)
- Manages role-permission relationships
- Implements role inheritance

3. **Authentication Routes** (`src/routes/auth_routes.py`)
- `/auth/register`: User registration with validation
- `/auth/login`: User login with rate limiting
- Default role assignment (CSR)
- JWT token generation and validation

### Security Features

1. **Rate Limiting**
- Separate stores for login and register endpoints
- 5 attempts per minute per IP address
- Automatic reset on successful attempts
- Configurable window and attempt limits

2. **Permission Caching**
- Request-scoped caching using Flask's `g` object
- Automatic cache invalidation between requests
- Efficient permission checking with SQLAlchemy EXISTS

3. **Password Security**
- PBKDF2-SHA256 password hashing
- Secure password validation
- No plaintext password storage

### Configuration
```python
JWT_SECRET_KEY=<secure-key>
JWT_ACCESS_TOKEN_EXPIRES=3600  # 1 hour
RATE_LIMIT_ATTEMPTS=5
RATE_LIMIT_WINDOW=60  # seconds
```
</file>

<file path="docs/testing_documentation.md">
# FBO LaunchPad Backend Testing Documentation

## Overview

This document provides comprehensive documentation for the FBO LaunchPad backend test suite. The test suite uses pytest and is designed to test authentication, fuel order management, and related functionality.

## Test Structure

### Directory Layout
```
fbo-launchpad-backend/
├── tests/
│   ├── conftest.py         # Test fixtures and configuration
│   ├── test_auth.py        # Authentication tests
│   ├── test_models.py      # Database model tests
│   └── test_routes.py      # API route tests
```

## Test Configuration

### Test Environment Setup (`conftest.py`)

The test environment is configured in `conftest.py` with the following key settings:

1. **Application Configuration**
   ```python
   app.config['TESTING'] = True
   app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
   app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
   app.config['SECRET_KEY'] = 'test-secret-key'
   ```

2. **Database Setup**
   - Uses SQLite in-memory database for tests
   - Tables are created and dropped for each test
   - Required tables: users, aircraft, customers, fuel_trucks, fuel_orders

### Test Fixtures

#### User Fixtures
1. **test_csr_user**
   - Role: CSR (Customer Service Representative)
   - Email: testcsr@example.com
   - Password: csrpass

2. **test_lst_user**
   - Role: LST (Line Service Technician)
   - Email: testlst@example.com
   - Password: csrpass

3. **test_admin_user**
   - Role: Admin
   - Email: testadmin@example.com
   - Password: password123

4. **test_inactive_user**
   - Role: CSR
   - Email: inactive@example.com
   - Password: inactivepass
   - Status: inactive

#### Resource Fixtures
1. **test_aircraft**
   - Tail Number: N12345
   - Type: Test Aircraft

2. **test_customer**
   - Name: Test Customer
   - Email: customer@example.com

3. **test_fuel_truck**
   - Truck Number: TRUCK001
   - Fuel Type: Jet A
   - Capacity: 5000.0

#### Authentication Fixtures
- **auth_headers**: Generates JWT tokens for different user roles
- Token payload includes: user ID, role, and expiration (1 hour)

## Test Suites

### 1. Authentication Tests (`test_auth.py`)

#### Registration Tests
```python
test_register_success()
test_register_missing_fields()
test_register_invalid_email()
test_register_duplicate_email()
```

Expected Behavior:
- New users are registered with LST role by default
- Username is generated from email (part before @)
- Duplicate emails are rejected
- Password is hashed before storage

#### Login Tests
```python
test_login_success()
test_login_incorrect_password()
test_login_nonexistent_email()
test_login_missing_fields()
test_login_inactive_user()
```

Expected Behavior:
- Successful login returns JWT token
- Invalid credentials return 401
- Inactive users cannot login
- Missing fields return 400

### 2. Fuel Order Tests (`test_routes.py`)

#### Order Management
```python
test_create_fuel_order()
test_get_fuel_orders()
test_update_fuel_order_status()
test_complete_fuel_order()
```

Expected Behavior:
- Orders require authentication
- CSR can create and review orders
- LST can update order status
- Complete flow: Dispatch → Acknowledge → En Route → Fueling → Complete → Review

## Authentication Requirements

### JWT Token Format
```python
{
    'sub': user.id,
    'role': user.role.value,
    'exp': datetime.utcnow() + timedelta(hours=1)
}
```

### Password Configuration
- All test users except specified use 'csrpass'
- Passwords are hashed using Werkzeug's password hashing
- Method: 'pbkdf2:sha256'

## Running Tests

### Basic Test Run
```bash
python -m pytest tests/ -v
```

### Run Specific Test File
```bash
python -m pytest tests/test_auth.py -v
```

### Run Specific Test
```bash
python -m pytest tests/test_auth.py::test_register_success -v
```

## Common Issues and Solutions

1. **SQLAlchemy Deprecation Warnings**
   - Warning about `Query.get()` being deprecated
   - Future update should use `Session.get()`

2. **JSON Serialization**
   - Enums must be converted to their values before JSON serialization
   - Use `enum_value.value` when returning in API responses

3. **Password Handling**
   - Always use `set_password()` method to hash passwords
   - Use `check_password()` method to verify passwords

## Test Dependencies

Required packages (from requirements.txt):
```
Flask==3.0.2
Flask-Cors==5.0.1
Flask-Migrate==4.0.5
Flask-SQLAlchemy==3.1.1
PyJWT>=2.0.0,<3.0.0
pytest==8.0.2
pytest-env==1.1.3
pytest-flask==1.3.0
```

## Best Practices

1. **Database Operations**
   - Always use test database (SQLite in memory)
   - Clean up after each test
   - Use transactions for data modifications

2. **Authentication**
   - Always verify token validation
   - Check role-based access
   - Validate inactive user states

3. **Test Isolation**
   - Each test should be independent
   - Use fresh fixtures for each test
   - Clean up any created resources

## Maintenance Notes

1. **Adding New Tests**
   - Follow existing patterns
   - Include both success and failure cases
   - Document expected behavior

2. **Updating Fixtures**
   - Maintain password consistency
   - Update auth_headers when adding roles
   - Keep test data realistic but simple

3. **Error Handling**
   - Verify error messages match frontend expectations
   - Include appropriate HTTP status codes

---

## Common JWT & Auth Pitfalls (for AI & Developers)

### 1. JWT Subject (`sub`) Type Mismatch
- Flask-JWT-Extended requires the `identity` (which becomes the JWT `sub` claim) to be a string. If you pass an integer (e.g., user ID), decoding will fail with `Subject must be a string`.
- **Solution:** Always use `create_access_token(identity=str(user.id))`.

### 2. Wrong Secret Key for JWT
- Flask-JWT-Extended uses `JWT_SECRET_KEY` for signing tokens, not `SECRET_KEY`.
- **Solution:** Always decode tokens with `JWT_SECRET_KEY` and ensure both creation and validation use the same key.

### 3. Algorithm Mismatch
- The default algorithm is `HS256`, but if you override it, you must specify the same in both token creation and decoding.
- **Solution:** Set `JWT_ALGORITHM = 'HS256'` in your config and use it everywhere.

### 4. Custom Decorators vs Flask-JWT-Extended
- If you use custom decorators (e.g., `token_required`), make sure they decode tokens using the correct secret and algorithm, and handle the `sub` claim as a string.
- **Solution:** Align custom logic with Flask-JWT-Extended's defaults. Prefer using `@jwt_required()` if possible.

### 5. In-Memory SQLite and Contexts
- When testing with SQLite in-memory, all DB setup, user creation, login, and API calls must happen in the same app context. Otherwise, the DB state will not persist.
- **Solution:** Wrap the entire test in `with app.app_context(): ...`.

### 6. Test Payload Schema Mismatch
- API tests must send all required fields as per the actual endpoint schema. Missing or extra fields cause 400 errors.
- **Solution:** Always check the API schema and update test payloads accordingly.

### 7. Legacy SQLAlchemy Warnings
- `Query.get()` is deprecated in SQLAlchemy 2.x. Use `Session.get()` instead.
- **Solution:** Update ORM calls to avoid warnings in future upgrades.

---

**Following these practices will save hours of debugging for both humans and AI!**
   - Log sufficient debug information
</file>

<file path="docs/testingContext.md">
# Testing Context

## Authentication Testing

### Test Coverage
1. Registration Tests (`/api/auth/register`)
   - Successful registration
   - Missing required fields
   - Invalid email format
   - Duplicate email registration

2. Login Tests (`/api/auth/login`)
   - Successful login
   - Incorrect password
   - Nonexistent email
   - Missing fields
   - Inactive user login attempt

### Test Fixtures Used
- `client`: Flask test client
- `db_session`: Database session for test isolation
- `test_users`: Pre-configured user accounts
  - CSR user
  - LST user
  - Inactive user

### Test File Structure
```
tests/
├── conftest.py         # Test fixtures and configuration
├── test_auth.py        # Authentication endpoint tests
├── test_routes.py      # Other route tests
├── test_models.py      # Model tests
└── __init__.py
```

### Running Tests
```bash
# Inside backend container
pytest tests/test_auth.py -v  # Run auth tests with verbose output
pytest                       # Run all tests
pytest -k "test_register"    # Run specific test pattern
```

### Test Implementation Details
1. Registration Tests
   - Verify response status codes
   - Check response message format
   - Validate user creation in database
   - Test password hashing
   - Verify default role assignment

2. Login Tests
   - Verify JWT token generation
   - Check error message format
   - Test authentication failures
   - Validate inactive user handling

### Next Steps
1. Add token validation tests
2. Implement password complexity tests
3. Add rate limiting tests
4. Test token refresh functionality
5. Add session management tests
</file>

<file path="fbo_launchpad_backend.egg-info/dependency_links.txt">

</file>

<file path="fbo_launchpad_backend.egg-info/PKG-INFO">
Metadata-Version: 2.4
Name: fbo-launchpad-backend
Version: 0.1.0
Requires-Dist: flask
Requires-Dist: flask-sqlalchemy
Requires-Dist: flask-migrate
Requires-Dist: psycopg2-binary
Requires-Dist: python-dotenv
Requires-Dist: apispec
Requires-Dist: apispec-webframeworks
Requires-Dist: marshmallow
Dynamic: requires-dist
</file>

<file path="fbo_launchpad_backend.egg-info/requires.txt">
flask
flask-sqlalchemy
flask-migrate
psycopg2-binary
python-dotenv
apispec
apispec-webframeworks
marshmallow
</file>

<file path="fbo_launchpad_backend.egg-info/SOURCES.txt">
setup.py
fbo_launchpad_backend.egg-info/PKG-INFO
fbo_launchpad_backend.egg-info/SOURCES.txt
fbo_launchpad_backend.egg-info/dependency_links.txt
fbo_launchpad_backend.egg-info/requires.txt
fbo_launchpad_backend.egg-info/top_level.txt
src/__init__.py
src/app.py
src/config.py
src/extensions.py
src/models/__init__.py
src/models/aircraft.py
src/models/customer.py
src/models/fuel_order.py
src/models/fuel_truck.py
src/models/user.py
src/routes/__init__.py
src/routes/auth_routes.py
src/routes/fuel_order_routes.py
src/schemas/__init__.py
src/schemas/auth_schemas.py
src/services/__init__.py
src/services/auth_service.py
src/services/fuel_order_service.py
src/utils/__init__.py
src/utils/decorators.py
tests/__init__.py
</file>

<file path="fbo_launchpad_backend.egg-info/top_level.txt">
src
tests
</file>

<file path="migrations/versions/05eadf8716a5_implement_pbac_models_permission_role_.py">
"""Implement PBAC models (Permission, Role, User roles relationship)

Revision ID: 05eadf8716a5
Revises: f1d4eec2dff2
Create Date: 2025-04-28 17:28:08.692228

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '05eadf8716a5'
down_revision = 'f1d4eec2dff2'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('permissions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )

    # Define permissions table for bulk insert
    permissions_table = sa.sql.table('permissions',
        sa.sql.column('name', sa.String),
        sa.sql.column('description', sa.Text),
        sa.sql.column('created_at', sa.DateTime),
        sa.sql.column('updated_at', sa.DateTime)
    )
    from datetime import datetime
    now = datetime.utcnow()
    all_permissions = [
        {'name': 'CREATE_ORDER', 'description': 'Allows creating new fuel orders', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_ASSIGNED_ORDERS', 'description': 'Allows viewing orders assigned to self', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_ALL_ORDERS', 'description': 'Allows viewing all fuel orders', 'created_at': now, 'updated_at': now},
        {'name': 'UPDATE_OWN_ORDER_STATUS', 'description': 'Allows LST to update status of own orders', 'created_at': now, 'updated_at': now},
        {'name': 'COMPLETE_OWN_ORDER', 'description': 'Allows LST to complete own orders', 'created_at': now, 'updated_at': now},
        {'name': 'REVIEW_ORDERS', 'description': 'Allows CSR/Admin to mark orders as reviewed', 'created_at': now, 'updated_at': now},
        {'name': 'EXPORT_ORDERS_CSV', 'description': 'Allows exporting order data to CSV', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_ORDER_STATS', 'description': 'Allows viewing order statistics', 'created_at': now, 'updated_at': now},
        {'name': 'EDIT_FUEL_ORDER', 'description': 'Allows editing fuel order details (Admin?)', 'created_at': now, 'updated_at': now},
        {'name': 'DELETE_FUEL_ORDER', 'description': 'Allows deleting fuel orders (Admin?)', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_USERS', 'description': 'Allows viewing user list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_USERS', 'description': 'Allows creating, updating, deleting users and assigning roles', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_TRUCKS', 'description': 'Allows viewing fuel truck list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_TRUCKS', 'description': 'Allows creating, updating, deleting fuel trucks', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_AIRCRAFT', 'description': 'Allows viewing aircraft list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_AIRCRAFT', 'description': 'Allows creating, updating, deleting aircraft', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_CUSTOMERS', 'description': 'Allows viewing customer list', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_CUSTOMERS', 'description': 'Allows creating, updating, deleting customers', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_ROLES', 'description': 'Allows managing roles and their permissions', 'created_at': now, 'updated_at': now},
        {'name': 'VIEW_PERMISSIONS', 'description': 'Allows viewing available system permissions', 'created_at': now, 'updated_at': now},
        {'name': 'MANAGE_SETTINGS', 'description': 'Allows managing global application settings', 'created_at': now, 'updated_at': now},
    ]
    op.bulk_insert(permissions_table, all_permissions)

    with op.batch_alter_table('permissions', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_permissions_name'), ['name'], unique=True)

    op.create_table('roles',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=80), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('roles', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_roles_name'), ['name'], unique=True)

    op.create_table('role_permissions',
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.Column('permission_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['permission_id'], ['permissions.id'], ),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.PrimaryKeyConstraint('role_id', 'permission_id')
    )
    op.create_table('user_roles',
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('role_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('user_id', 'role_id')
    )
    # Initialize session for data migration and seeding
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)
    permissions_table_id = sa.sql.table('permissions',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String)
    )
    roles_table_id = sa.sql.table('roles',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String)
    )
    # --- PBAC Step 6: Migrate existing users to new roles ---
    users_table = sa.sql.table('users',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('role', sa.String)
    )
    user_roles_table = sa.sql.table('user_roles',
        sa.sql.column('user_id', sa.Integer),
        sa.sql.column('role_id', sa.Integer)
    )
    old_role_to_new_role_name = {
        'ADMIN': 'System Administrator',
        'CSR': 'Customer Service Representative',
        'LST': 'Line Service Technician'
    }
    # Fetch IDs of the NEW default roles
    role_results = session.execute(sa.select(roles_table_id.c.id, roles_table_id.c.name).where(roles_table_id.c.name.in_(old_role_to_new_role_name.values()))).fetchall()
    new_role_name_to_id_map = {name: id for id, name in role_results}
    # Fetch existing users and their OLD roles
    user_results = session.execute(sa.select(users_table.c.id, users_table.c.role)).fetchall()
    user_role_assignments = []
    for user_id, old_role_value in user_results:
        if old_role_value is None:
            continue
        new_role_name = old_role_to_new_role_name.get(str(old_role_value).upper())
        if new_role_name:
            new_role_id = new_role_name_to_id_map.get(new_role_name)
            if new_role_id:
                user_role_assignments.append({'user_id': user_id, 'role_id': new_role_id})
    if user_role_assignments:
        op.bulk_insert(user_roles_table, user_role_assignments)
    session.commit()
    # --- End PBAC Step 6 ---

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_column('role')

    # --- PBAC Step 5: Seed default roles and assign permissions ---
    roles_table = sa.sql.table('roles',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String),
        sa.sql.column('description', sa.Text),
        sa.sql.column('created_at', sa.DateTime),
        sa.sql.column('updated_at', sa.DateTime)
    )
    role_permissions_table = sa.sql.table('role_permissions',
        sa.sql.column('role_id', sa.Integer),
        sa.sql.column('permission_id', sa.Integer)
    )
    # Default roles
    default_roles = [
        {'name': 'System Administrator', 'description': 'Full system access', 'created_at': now, 'updated_at': now},
        {'name': 'Customer Service Representative', 'description': 'Manages orders, customers, basic data', 'created_at': now, 'updated_at': now},
        {'name': 'Line Service Technician', 'description': 'Handles assigned fuel orders on the ramp', 'created_at': now, 'updated_at': now}
    ]
    op.bulk_insert(roles_table, default_roles)

    # Permission mapping for each role
    role_permission_mapping = {
        'System Administrator': [p['name'] for p in all_permissions],
        'Customer Service Representative': [
            'CREATE_ORDER', 'VIEW_ALL_ORDERS', 'REVIEW_ORDERS', 'EXPORT_ORDERS_CSV',
            'VIEW_ORDER_STATS', 'EDIT_FUEL_ORDER',
            'VIEW_USERS', 'VIEW_TRUCKS', 'VIEW_AIRCRAFT', 'VIEW_CUSTOMERS',
            'MANAGE_AIRCRAFT', 'MANAGE_CUSTOMERS',
            'VIEW_PERMISSIONS'
        ],
        'Line Service Technician': [
            'VIEW_ASSIGNED_ORDERS', 'UPDATE_OWN_ORDER_STATUS', 'COMPLETE_OWN_ORDER',
            'VIEW_ORDER_STATS'
        ]
    }
    # Fetch IDs for permissions and roles
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)
    perm_results = session.execute(sa.select(permissions_table_id.c.id, permissions_table_id.c.name)).fetchall()
    permission_map = {name: id for id, name in perm_results}
    role_results = session.execute(sa.select(roles_table_id.c.id, roles_table_id.c.name).where(roles_table_id.c.name.in_(role_permission_mapping.keys()))).fetchall()
    role_map = {name: id for id, name in role_results}
    role_permissions_data = []
    for role_name, permission_names in role_permission_mapping.items():
        role_id = role_map.get(role_name)
        if role_id:
            for perm_name in permission_names:
                permission_id = permission_map.get(perm_name)
                if permission_id:
                    role_permissions_data.append({'role_id': role_id, 'permission_id': permission_id})
    if role_permissions_data:
        op.bulk_insert(role_permissions_table, role_permissions_data)
    session.commit()
    # --- End PBAC Step 5 ---

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('role', postgresql.ENUM('LST', 'CSR', 'ADMIN', name='userrole'), autoincrement=False, nullable=False))

    # --- PBAC Step 6: Remove all user-role links ---
    op.execute('DELETE FROM user_roles')
    # --- End PBAC Step 6 ---

    op.drop_table('user_roles')
    op.drop_table('role_permissions')
    with op.batch_alter_table('roles', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_roles_name'))

    op.drop_table('roles')
    with op.batch_alter_table('permissions', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_permissions_name'))

    # Remove seeded permissions before dropping table
    permissions_table = sa.sql.table('permissions',
        sa.sql.column('name', sa.String)
    )
    permission_names = [
        'CREATE_ORDER',
        'VIEW_ASSIGNED_ORDERS',
        'VIEW_ALL_ORDERS',
        'UPDATE_OWN_ORDER_STATUS',
        'COMPLETE_OWN_ORDER',
        'REVIEW_ORDERS',
        'EXPORT_ORDERS_CSV',
        'VIEW_ORDER_STATS',
        'EDIT_FUEL_ORDER',
        'DELETE_FUEL_ORDER',
        'VIEW_USERS',
        'MANAGE_USERS',
        'VIEW_TRUCKS',
        'MANAGE_TRUCKS',
        'VIEW_AIRCRAFT',
        'MANAGE_AIRCRAFT',
        'VIEW_CUSTOMERS',
        'MANAGE_CUSTOMERS',
        'MANAGE_ROLES',
        'VIEW_PERMISSIONS',
        'MANAGE_SETTINGS',
    ]
    op.execute(
        permissions_table.delete().where(permissions_table.c.name.in_(permission_names))
    )

    op.drop_table('permissions')

    # --- PBAC Step 5: Remove seeded role-permissions and roles ---
    role_permissions_table = sa.sql.table('role_permissions',
        sa.sql.column('role_id', sa.Integer),
        sa.sql.column('permission_id', sa.Integer)
    )
    roles_table = sa.sql.table('roles',
        sa.sql.column('id', sa.Integer),
        sa.sql.column('name', sa.String)
    )
    # Remove role-permission links for default roles
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)
    default_role_names = [
        'System Administrator',
        'Customer Service Representative',
        'Line Service Technician'
    ]
    # Get role IDs for default roles
    role_results = session.execute(sa.select(roles_table.c.id, roles_table.c.name).where(roles_table.c.name.in_(default_role_names))).fetchall()
    role_ids = [id for id, name in role_results]
    if role_ids:
        op.execute(role_permissions_table.delete().where(role_permissions_table.c.role_id.in_(role_ids)))
    # Remove default roles
    op.execute(roles_table.delete().where(roles_table.c.name.in_(default_role_names)))
    session.commit()
    # --- End PBAC Step 5 ---

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/1a764e4d3fa2_add_fuel_truck_customer_aircraft_fuel_.py">
"""Add fuel truck, customer, aircraft, fuel order tables

Revision ID: 1a764e4d3fa2
Revises: 1ba38c67c062
Create Date: 2025-04-23 02:31:11.923838

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '1a764e4d3fa2'
down_revision = '1ba38c67c062'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('customers',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=150), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('fuel_trucks',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('aircraft',
    sa.Column('tail_number', sa.String(length=20), nullable=False),
    sa.Column('customer_id', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ),
    sa.PrimaryKeyConstraint('tail_number')
    )
    op.create_table('fuel_orders',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('status', sa.Enum('DISPATCHED', 'ACKNOWLEDGED', 'EN_ROUTE', 'FUELING', 'COMPLETED', 'REVIEWED', 'CANCELLED', name='fuelorderstatus'), nullable=False),
    sa.Column('tail_number', sa.String(length=20), nullable=False),
    sa.Column('customer_id', sa.Integer(), nullable=True),
    sa.Column('fuel_type', sa.String(length=50), nullable=False),
    sa.Column('additive_requested', sa.Boolean(), nullable=True),
    sa.Column('requested_amount', sa.Numeric(precision=10, scale=2), nullable=True),
    sa.Column('assigned_lst_user_id', sa.Integer(), nullable=True),
    sa.Column('assigned_truck_id', sa.Integer(), nullable=True),
    sa.Column('location_on_ramp', sa.String(length=100), nullable=True),
    sa.Column('csr_notes', sa.Text(), nullable=True),
    sa.Column('lst_notes', sa.Text(), nullable=True),
    sa.Column('start_meter_reading', sa.Numeric(precision=12, scale=2), nullable=True),
    sa.Column('end_meter_reading', sa.Numeric(precision=12, scale=2), nullable=True),
    sa.Column('calculated_gallons_dispensed', sa.Numeric(precision=10, scale=2), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('dispatch_timestamp', sa.DateTime(), nullable=True),
    sa.Column('acknowledge_timestamp', sa.DateTime(), nullable=True),
    sa.Column('en_route_timestamp', sa.DateTime(), nullable=True),
    sa.Column('fueling_start_timestamp', sa.DateTime(), nullable=True),
    sa.Column('completion_timestamp', sa.DateTime(), nullable=True),
    sa.Column('reviewed_timestamp', sa.DateTime(), nullable=True),
    sa.Column('reviewed_by_csr_user_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['assigned_lst_user_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['assigned_truck_id'], ['fuel_trucks.id'], ),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ),
    sa.ForeignKeyConstraint(['reviewed_by_csr_user_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['tail_number'], ['aircraft.tail_number'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_fuel_orders_assigned_lst_user_id'), ['assigned_lst_user_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_assigned_truck_id'), ['assigned_truck_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_status'), ['status'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_tail_number'), ['tail_number'], unique=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_fuel_orders_tail_number'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_status'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_assigned_truck_id'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_assigned_lst_user_id'))

    op.drop_table('fuel_orders')
    op.drop_table('aircraft')
    op.drop_table('fuel_trucks')
    op.drop_table('customers')
    # ### end Alembic commands ###
</file>

<file path="migrations/versions/1ba38c67c062_create_user_table.py">
"""Create user table

Revision ID: 1ba38c67c062
Revises: 
Create Date: 2025-04-23 01:51:39.793455

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '1ba38c67c062'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.Column('role', sa.Enum('LST', 'CSR', 'ADMIN', name='userrole'), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_users_email'), ['email'], unique=True)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_users_email'))

    op.drop_table('users')
    # ### end Alembic commands ###
</file>

<file path="migrations/versions/ae3b7293103c_add_aircraft_type_column_to_aircraft_.py">
"""add aircraft_type column to aircraft table

Revision ID: ae3b7293103c
Revises: 1a764e4d3fa2
Create Date: 2025-04-23 13:31:37.962120

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'ae3b7293103c'
down_revision = '1a764e4d3fa2'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('aircraft', schema=None) as batch_op:
        batch_op.add_column(sa.Column('aircraft_type', sa.String(length=50), nullable=False))
        batch_op.drop_constraint('aircraft_customer_id_fkey', type_='foreignkey')
        batch_op.drop_column('customer_id')

    with op.batch_alter_table('customers', schema=None) as batch_op:
        batch_op.add_column(sa.Column('email', sa.String(length=120), nullable=False))
        batch_op.add_column(sa.Column('phone', sa.String(length=20), nullable=True))
        batch_op.alter_column('name',
               existing_type=sa.VARCHAR(length=150),
               type_=sa.String(length=100),
               existing_nullable=False)
        batch_op.create_index(batch_op.f('ix_customers_email'), ['email'], unique=True)

    with op.batch_alter_table('fuel_trucks', schema=None) as batch_op:
        batch_op.add_column(sa.Column('truck_number', sa.String(length=20), nullable=False))
        batch_op.add_column(sa.Column('fuel_type', sa.String(length=50), nullable=False))
        batch_op.add_column(sa.Column('capacity', sa.Numeric(precision=10, scale=2), nullable=False))
        batch_op.add_column(sa.Column('current_meter_reading', sa.Numeric(precision=12, scale=2), nullable=False))
        batch_op.drop_constraint('fuel_trucks_name_key', type_='unique')
        batch_op.create_unique_constraint(None, ['truck_number'])
        batch_op.drop_column('name')

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('username', sa.String(length=64), nullable=False))
        batch_op.add_column(sa.Column('password_hash', sa.String(length=128), nullable=True))
        batch_op.create_index(batch_op.f('ix_users_username'), ['username'], unique=True)
        batch_op.drop_column('hashed_password')
        batch_op.drop_column('name')
        batch_op.drop_column('is_active')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=False))
        batch_op.add_column(sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
        batch_op.add_column(sa.Column('hashed_password', sa.VARCHAR(length=255), autoincrement=False, nullable=False))
        batch_op.drop_index(batch_op.f('ix_users_username'))
        batch_op.drop_column('password_hash')
        batch_op.drop_column('username')

    with op.batch_alter_table('fuel_trucks', schema=None) as batch_op:
        batch_op.add_column(sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False))
        batch_op.drop_constraint(None, type_='unique')
        batch_op.create_unique_constraint('fuel_trucks_name_key', ['name'])
        batch_op.drop_column('current_meter_reading')
        batch_op.drop_column('capacity')
        batch_op.drop_column('fuel_type')
        batch_op.drop_column('truck_number')

    with op.batch_alter_table('customers', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_customers_email'))
        batch_op.alter_column('name',
               existing_type=sa.String(length=100),
               type_=sa.VARCHAR(length=150),
               existing_nullable=False)
        batch_op.drop_column('phone')
        batch_op.drop_column('email')

    with op.batch_alter_table('aircraft', schema=None) as batch_op:
        batch_op.add_column(sa.Column('customer_id', sa.INTEGER(), autoincrement=False, nullable=True))
        batch_op.create_foreign_key('aircraft_customer_id_fkey', 'customers', ['customer_id'], ['id'])
        batch_op.drop_column('aircraft_type')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/f1d4eec2dff2_add_is_active_column_back_to_users_table.py">
"""add is_active column back to users table

Revision ID: f1d4eec2dff2
Revises: ae3b7293103c
Create Date: 2025-04-24 21:09:13.565962

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'f1d4eec2dff2'
down_revision = 'ae3b7293103c'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.add_column(sa.Column('updated_at', sa.DateTime(), nullable=False))
        batch_op.drop_column('calculated_gallons_dispensed')

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('is_active', sa.Boolean(), nullable=False))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_column('is_active')

    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.add_column(sa.Column('calculated_gallons_dispensed', sa.NUMERIC(precision=10, scale=2), autoincrement=False, nullable=True))
        batch_op.drop_column('updated_at')

    # ### end Alembic commands ###
</file>

<file path="migrations/alembic.ini">
# A generic, single database configuration.

[alembic]
# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false


# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic,flask_migrate

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[logger_flask_migrate]
level = INFO
handlers =
qualname = flask_migrate

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="migrations/env.py">
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="migrations/README">
Single-database configuration for Flask.
</file>

<file path="migrations/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}
</file>

<file path="src/models/__init__.py">
from .base import Base
from .permission import Permission
from .role import Role
from .role_permission import role_permissions, user_roles
from .user import User, UserRole
from .aircraft import Aircraft
from .customer import Customer
from .fuel_truck import FuelTruck
from .fuel_order import FuelOrder, FuelOrderStatus

__all__ = [
    'Base',
    'Permission',
    'Role',
    'role_permissions',
    'user_roles',
    'User',
    'UserRole',
    'Aircraft',
    'Customer',
    'FuelTruck',
    'FuelOrder',
    'FuelOrderStatus'
]
</file>

<file path="src/models/aircraft.py">
from datetime import datetime
from ..extensions import db

class Aircraft(db.Model):
    """Aircraft model representing an aircraft in the system."""
    __tablename__ = 'aircraft'

    # Primary key - using tail number as per MVP requirements
    tail_number = db.Column(db.String(20), primary_key=True)
    
    # New column for aircraft type
    aircraft_type = db.Column(db.String(50), nullable=False)

    # New column for fuel type
    fuel_type = db.Column(db.String(20), nullable=False)

    # Timestamps
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'tail_number': self.tail_number,
            'aircraft_type': self.aircraft_type,
            'fuel_type': self.fuel_type,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

    def __repr__(self):
        """Return string representation of the aircraft."""
        return f'<Aircraft {self.tail_number}>'
</file>

<file path="src/models/base.py">
from src.extensions import db

Base = db.Model
</file>

<file path="src/models/customer.py">
from datetime import datetime
from ..extensions import db


class Customer(db.Model):
    """Model representing a customer in the system (MVP version).
    Note: This is a simplified version for MVP and will be expanded significantly in the CRM module."""
    
    __tablename__ = 'customers'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    phone = db.Column(db.String(20))
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'phone': self.phone,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

    def __repr__(self):
        return f'<Customer {self.name}>'
</file>

<file path="src/models/fuel_order.py">
import enum
from datetime import datetime
from sqlalchemy import Integer, String, Boolean, DateTime, Enum, Text, Numeric, ForeignKey
from sqlalchemy.ext.hybrid import hybrid_property
from ..extensions import db

class FuelOrderStatus(enum.Enum):
    DISPATCHED = 'Dispatched'
    ACKNOWLEDGED = 'Acknowledged'
    EN_ROUTE = 'En Route'
    FUELING = 'Fueling'
    COMPLETED = 'Completed'
    REVIEWED = 'Reviewed'
    CANCELLED = 'Cancelled'

class FuelOrder(db.Model):
    __tablename__ = 'fuel_orders'

    # Primary Key
    id = db.Column(db.Integer, primary_key=True)

    # Status and Core Fields
    status = db.Column(db.Enum(FuelOrderStatus), nullable=False, default=FuelOrderStatus.DISPATCHED, index=True)
    tail_number = db.Column(db.String(20), db.ForeignKey('aircraft.tail_number'), nullable=False, index=True)
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True)
    fuel_type = db.Column(db.String(50), nullable=False)
    additive_requested = db.Column(db.Boolean, default=False)
    requested_amount = db.Column(db.Numeric(10, 2), nullable=True)

    # Assignment Fields
    assigned_lst_user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True, index=True)
    assigned_truck_id = db.Column(db.Integer, db.ForeignKey('fuel_trucks.id'), nullable=True, index=True)
    location_on_ramp = db.Column(db.String(100), nullable=True)
    
    # Notes Fields
    csr_notes = db.Column(db.Text, nullable=True)
    lst_notes = db.Column(db.Text, nullable=True)

    # Metering Fields
    start_meter_reading = db.Column(db.Numeric(12, 2), nullable=True)
    end_meter_reading = db.Column(db.Numeric(12, 2), nullable=True)

    # Timestamps
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    dispatch_timestamp = db.Column(db.DateTime, nullable=True)
    acknowledge_timestamp = db.Column(db.DateTime, nullable=True)
    en_route_timestamp = db.Column(db.DateTime, nullable=True)
    fueling_start_timestamp = db.Column(db.DateTime, nullable=True)
    completion_timestamp = db.Column(db.DateTime, nullable=True)
    reviewed_timestamp = db.Column(db.DateTime, nullable=True)
    
    # Review Fields
    reviewed_by_csr_user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)

    # Relationships
    aircraft = db.relationship('Aircraft', backref=db.backref('fuel_orders', lazy='dynamic'))
    customer = db.relationship('Customer', backref=db.backref('fuel_orders', lazy='dynamic'))
    assigned_lst = db.relationship('User', foreign_keys=[assigned_lst_user_id], 
                                 backref=db.backref('assigned_fuel_orders', lazy='dynamic'))
    assigned_truck = db.relationship('FuelTruck', backref=db.backref('fuel_orders', lazy='dynamic'))
    reviewed_by_csr = db.relationship('User', foreign_keys=[reviewed_by_csr_user_id], 
                                    backref=db.backref('reviewed_fuel_orders', lazy='dynamic'))

    @hybrid_property
    def calculated_gallons_dispensed(self):
        if self.start_meter_reading is not None and self.end_meter_reading is not None:
            return float(self.end_meter_reading - self.start_meter_reading)
        return None

    def __repr__(self):
        return f'<FuelOrder {self.id} - {self.tail_number}>'
</file>

<file path="src/models/fuel_truck.py">
from datetime import datetime
from ..extensions import db


class FuelTruck(db.Model):
    """Model representing a fuel truck in the system."""
    
    __tablename__ = 'fuel_trucks'

    id = db.Column(db.Integer, primary_key=True)
    truck_number = db.Column(db.String(20), unique=True, nullable=False)
    fuel_type = db.Column(db.String(50), nullable=False)
    capacity = db.Column(db.Numeric(10, 2), nullable=False)
    current_meter_reading = db.Column(db.Numeric(12, 2), nullable=False, default=0)
    is_active = db.Column(db.Boolean, nullable=False, default=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'truck_number': self.truck_number,
            'fuel_type': self.fuel_type,
            'capacity': float(self.capacity),
            'current_meter_reading': float(self.current_meter_reading),
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

    def __repr__(self):
        return f'<FuelTruck {self.truck_number}>'
</file>

<file path="src/models/permission.py">
from src.extensions import db
from sqlalchemy import Integer, String, Text, DateTime
from datetime import datetime

class Permission(db.Model):
    __tablename__ = 'permissions'

    id = db.Column(Integer, primary_key=True)
    name = db.Column(String(100), unique=True, nullable=False, index=True)
    description = db.Column(Text, nullable=True)
    created_at = db.Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    def __repr__(self):
        return f'<Permission {self.name}>'
</file>

<file path="src/models/role_permission.py">
from src.extensions import db
from sqlalchemy import Integer, ForeignKey

role_permissions = db.Table('role_permissions',
    db.Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    db.Column('permission_id', Integer, ForeignKey('permissions.id'), primary_key=True)
)

user_roles = db.Table('user_roles',
    db.Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    db.Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True)
)
</file>

<file path="src/models/role.py">
from datetime import datetime
from sqlalchemy import Integer, String, Text, DateTime
from ..extensions import db
from .role_permission import role_permissions

class Role(db.Model):
    __tablename__ = 'roles'

    id = db.Column(Integer, primary_key=True)
    name = db.Column(String(80), unique=True, nullable=False, index=True)
    description = db.Column(Text, nullable=True)
    created_at = db.Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    permissions = db.relationship(
        'Permission',
        secondary=role_permissions,
        backref=db.backref('roles', lazy='dynamic'),
        lazy='dynamic'
    )

    def __repr__(self):
        return f'<Role {self.name}>'
</file>

<file path="src/models/settings.py">
# settings.py
# Deprecated: The Setting model and settings table are no longer used. All code removed as of April 2025.
</file>

<file path="src/models/user.py">
from datetime import datetime, timedelta
from enum import Enum
from flask import current_app, g, has_request_context
from sqlalchemy import exists
from sqlalchemy.orm import joinedload
from werkzeug.security import generate_password_hash, check_password_hash
import jwt

from ..extensions import db
from ..models.permission import Permission
from ..models.role import Role
from ..models.role_permission import role_permissions, user_roles

class UserRole(Enum):
    """
    Enumeration of user roles for backward compatibility with role-based decorators.
    """
    ADMIN = "ADMIN"
    CSR = "CSR"
    LST = "LST"

class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    name = db.Column(db.String(120), nullable=True)
    password_hash = db.Column(db.String(128))
    is_active = db.Column(db.Boolean, nullable=False, default=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    roles = db.relationship(
        'Role',
        secondary=user_roles,
        backref=db.backref('users', lazy='dynamic'),
        lazy='dynamic'
    )

    def set_password(self, password):
        self.password_hash = generate_password_hash(password, method='pbkdf2:sha256')

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def to_dict(self):
        """Convert user object to dictionary."""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'name': self.name,
            'roles': [role.name for role in self.roles.all()],
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat()
        }

    @property
    def role_list(self):
        """Get list of roles for this user."""
        return self.roles.all()

    def __repr__(self):
        return f'<User {self.username}>'

    def has_permission(self, permission_name: str) -> bool:
        """
        Check if the user has a specific permission through any of their assigned roles.
        
        Args:
            permission_name (str): The name of the permission to check for.
            
        Returns:
            bool: True if the user has the permission through any role, False otherwise.
            
        Note:
            This method uses SQLAlchemy's EXISTS subquery for efficient permission checking
            and caches results for the duration of the request.
        """
        if not self.is_active:
            return False
            
        # Use request-level caching if available
        if has_request_context():
            # Initialize permission cache if it doesn't exist
            if not hasattr(g, '_permission_cache'):
                g._permission_cache = {}
            
            cache_key = f'user_{self.id}_perm_{permission_name}'
            if cache_key in g._permission_cache:
                return g._permission_cache[cache_key]
            
            # Check permission and cache result
            result = db.session.query(exists().where(
                db.and_(
                    User.id == self.id,
                    User.roles.any(Role.permissions.any(Permission.name == permission_name))
                )
            )).scalar()
            
            g._permission_cache[cache_key] = result
            return result
            
        # If no request context, perform check without caching
        return db.session.query(exists().where(
            db.and_(
                User.id == self.id,
                User.roles.any(Role.permissions.any(Permission.name == permission_name))
            )
        )).scalar()

    def generate_token(self, expires_in=3600):
        """
        Generate a JWT token for the user.
        
        Args:
            expires_in (int): Token expiration time in seconds (default: 1 hour)
            
        Returns:
            str: The generated JWT token
            
        Note:
            The token includes user ID, roles, and expiration time.
            Uses the app's JWT_SECRET_KEY for signing.
        """
        now = datetime.utcnow()
        payload = {
            'user_id': self.id,
            'username': self.username,
            'roles': [role.name for role in self.roles],
            'is_active': self.is_active,
            'exp': now + timedelta(seconds=expires_in),
            'iat': now
        }
        return jwt.encode(
            payload,
            current_app.config['JWT_SECRET_KEY'],
            algorithm='HS256'
        )

    @staticmethod
    def verify_token(token):
        """Verify a JWT token and return the user."""
        try:
            payload = jwt.decode(
                token,
                current_app.config['JWT_SECRET_KEY'],
                algorithms=['HS256']
            )
            user_id = payload['user_id']
            return User.query.get(user_id)
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
</file>

<file path="src/routes/admin/aircraft_admin_routes.py">
from flask import Blueprint, request, jsonify
from ...services.aircraft_service import AircraftService
from ...services.customer_service import CustomerService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas.admin_schemas import AdminAircraftSchema, AdminAircraftListResponseSchema, ErrorResponseSchema
from src.extensions import apispec

aircraft_admin_bp = Blueprint('aircraft_admin_bp', __name__, url_prefix='/api/admin/aircraft')

@aircraft_admin_bp.route('/', methods=['GET'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def list_aircraft():
    """
    ---
    get:
      summary: List all aircraft (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      responses:
        200:
          description: List of aircraft
          content:
            application/json:
              schema: AdminAircraftListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    aircraft_list, msg, status = AircraftService.get_all_aircraft(request.args)
    schema = AdminAircraftSchema(many=True)
    return jsonify({"aircraft": schema.dump(aircraft_list)}), status

@aircraft_admin_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def create_aircraft():
    """
    ---
    post:
      summary: Create a new aircraft (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminAircraftSchema
      responses:
        201:
          description: Aircraft created
          content:
            application/json:
              schema: AdminAircraftSchema
        400:
          description: Bad request
        409:
          description: Conflict
    """
    data = request.get_json()
    aircraft, msg, status = AircraftService.create_aircraft(data)
    if not aircraft:
        return jsonify({"error": msg}), status
    schema = AdminAircraftSchema()
    return jsonify(schema.dump(aircraft)), status

@aircraft_admin_bp.route('/<string:tail_number>', methods=['GET'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def get_aircraft(tail_number):
    """
    ---
    get:
      summary: Get an aircraft by tail number (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      parameters:
        - in: path
          name: tail_number
          schema:
            type: string
          required: true
      responses:
        200:
          description: Aircraft details
          content:
            application/json:
              schema: AdminAircraftSchema
        404:
          description: Not found
    """
    aircraft, msg, status = AircraftService.get_aircraft_by_tail(tail_number)
    if not aircraft:
        return jsonify({"error": msg}), status
    schema = AdminAircraftSchema()
    return jsonify(schema.dump(aircraft)), status

@aircraft_admin_bp.route('/<string:tail_number>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def update_aircraft(tail_number):
    """
    ---
    patch:
      summary: Update an aircraft by tail number (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      parameters:
        - in: path
          name: tail_number
          schema:
            type: string
          required: true
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminAircraftSchema
      responses:
        200:
          description: Aircraft updated
          content:
            application/json:
              schema: AdminAircraftSchema
        400:
          description: Bad request
        404:
          description: Not found
    """
    data = request.get_json()
    aircraft, msg, status = AircraftService.update_aircraft(tail_number, data)
    if not aircraft:
        return jsonify({"error": msg}), status
    schema = AdminAircraftSchema()
    return jsonify(schema.dump(aircraft)), status

@aircraft_admin_bp.route('/<string:tail_number>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def delete_aircraft(tail_number):
    """
    ---
    delete:
      summary: Delete an aircraft by tail number (admin, MANAGE_AIRCRAFT permission required)
      tags:
        - Admin - Aircraft
      parameters:
        - in: path
          name: tail_number
          schema:
            type: string
          required: true
      responses:
        204:
          description: Aircraft deleted
        404:
          description: Not found
        409:
          description: Conflict (referenced by other records)
    """
    deleted, msg, status = AircraftService.delete_aircraft(tail_number)
    if not deleted:
        return jsonify({"error": msg}), status
    return '', 204
</file>

<file path="src/routes/admin/assignment_settings_routes.py">
# assignment_settings_routes.py
# Deprecated: Global auto-assign setting is no longer used. All logic removed as of April 2025.
</file>

<file path="src/routes/admin/customer_admin_routes.py">
from flask import Blueprint, request, jsonify
from ...services.customer_service import CustomerService
from src.utils.decorators import token_required, require_permission
from ...models.user import UserRole
from ...schemas.admin_schemas import AdminCustomerSchema, AdminCustomerListResponseSchema, ErrorResponseSchema
from src.extensions import apispec

customer_admin_bp = Blueprint('customer_admin_bp', __name__, url_prefix='/api/admin/customers')

@customer_admin_bp.route('/', methods=['GET'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def list_customers():
    """
    ---
    get:
      summary: List all customers (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      responses:
        200:
          description: List of customers
          content:
            application/json:
              schema: AdminCustomerListResponseSchema
        401:
          description: Unauthorized
        403:
          description: Forbidden (missing permission)
    """
    customers, msg, status = CustomerService.get_all_customers(request.args)
    schema = AdminCustomerSchema(many=True)
    return jsonify({"customers": schema.dump(customers)}), status

@customer_admin_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def create_customer():
    """
    ---
    post:
      summary: Create a new customer (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminCustomerSchema
      responses:
        201:
          description: Customer created
          content:
            application/json:
              schema: AdminCustomerSchema
        400:
          description: Bad request
    """
    data = request.get_json()
    customer, msg, status = CustomerService.create_customer(data)
    if not customer:
        return jsonify({"error": msg}), status
    schema = AdminCustomerSchema()
    return jsonify(schema.dump(customer)), status

@customer_admin_bp.route('/<int:customer_id>', methods=['GET'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def get_customer(customer_id):
    """
    ---
    get:
      summary: Get a customer by ID (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      parameters:
        - in: path
          name: customer_id
          schema:
            type: integer
          required: true
      responses:
        200:
          description: Customer details
          content:
            application/json:
              schema: AdminCustomerSchema
        404:
          description: Not found
    """
    customer, msg, status = CustomerService.get_customer_by_id(customer_id)
    if not customer:
        return jsonify({"error": msg}), status
    schema = AdminCustomerSchema()
    return jsonify(schema.dump(customer)), status

@customer_admin_bp.route('/<int:customer_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def update_customer(customer_id):
    """
    ---
    patch:
      summary: Update a customer by ID (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      parameters:
        - in: path
          name: customer_id
          schema:
            type: integer
          required: true
      requestBody:
        required: true
        content:
          application/json:
            schema: AdminCustomerSchema
      responses:
        200:
          description: Customer updated
          content:
            application/json:
              schema: AdminCustomerSchema
        400:
          description: Bad request
        404:
          description: Not found
    """
    data = request.get_json()
    customer, msg, status = CustomerService.update_customer(customer_id, data)
    if not customer:
        return jsonify({"error": msg}), status
    schema = AdminCustomerSchema()
    return jsonify(schema.dump(customer)), status

@customer_admin_bp.route('/<int:customer_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def delete_customer(customer_id):
    """
    ---
    delete:
      summary: Delete a customer by ID (admin, MANAGE_CUSTOMERS permission required)
      tags:
        - Admin - Customers
      parameters:
        - in: path
          name: customer_id
          schema:
            type: integer
          required: true
      responses:
        204:
          description: Customer deleted
        404:
          description: Not found
        409:
          description: Conflict (referenced by other records)
    """
    deleted, msg, status = CustomerService.delete_customer(customer_id)
    if not deleted:
        return jsonify({"error": msg}), status
    return '', 204
</file>

<file path="src/routes/admin/permission_admin_routes.py">
from flask import Blueprint, jsonify, g
from ...services import PermissionService
from ...utils.decorators import token_required, require_permission
from ...schemas import PermissionSchema, ErrorResponseSchema
from marshmallow import Schema, fields

# Define PermissionListResponseSchema since it doesn't exist yet
class PermissionListResponseSchema(Schema):
    """Schema for permission list responses."""
    message = fields.String(required=True)
    permissions = fields.Nested(PermissionSchema, many=True, required=True)

permission_admin_bp = Blueprint('permission_admin_bp', __name__, url_prefix='/api/admin/permissions')

@permission_admin_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_PERMISSIONS')
def get_permissions():
    """Get a list of all available system permissions.
    Requires VIEW_PERMISSIONS permission.
    ---
    tags:
      - Admin - Permissions
    security:
      - bearerAuth: []
    responses:
      200:
        description: List of permissions retrieved successfully
        content:
          application/json:
            schema: PermissionListResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    permissions, message, status_code = PermissionService.get_all_permissions()

    if permissions is not None:
        # Use Marshmallow schema for serialization
        result = PermissionListResponseSchema().dump({
            "message": message,
            "permissions": permissions
        })
        return jsonify(result), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="src/routes/admin/role_admin_routes.py">
from flask import Blueprint, request, jsonify
from ...services.role_service import RoleService
from ...services.permission_service import PermissionService
from src.utils.decorators import token_required, require_permission
from ...schemas.role_schemas import (
    RoleSchema,
    RoleListResponseSchema,
    RoleCreateRequestSchema,
    RoleUpdateRequestSchema,
    RoleAssignPermissionRequestSchema
)
from ...schemas.permission_schemas import PermissionSchema
from ...schemas import ErrorResponseSchema
from marshmallow import ValidationError

role_admin_bp = Blueprint('role_admin_bp', __name__, url_prefix='/api/admin/roles')

@role_admin_bp.route('/', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_roles():
    """Get all roles.
    Requires MANAGE_ROLES permission.
    ---
    get:
      summary: List all roles (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      responses:
        200:
          description: List of roles
          content:
            application/json:
              schema: RoleListResponseSchema
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    roles, message, status_code = RoleService.get_all_roles()
    if roles is not None:
        schema = RoleSchema(many=True)
        return jsonify({
            "message": message,
            "roles": schema.dump(roles)
        }), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_ROLES')
def create_role():
    """Create a new role.
    Requires MANAGE_ROLES permission.
    ---
    post:
      summary: Create a new role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema: RoleCreateRequestSchema
      responses:
        201:
          description: Role created
          content:
            application/json:
              schema: RoleSchema
        400:
          description: Bad request
          content:
            application/json:
              schema: ErrorResponseSchema
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        409:
          description: Conflict (role name already exists)
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    try:
        schema = RoleCreateRequestSchema()
        data = schema.load(request.get_json())
    except ValidationError as e:
        return jsonify({
            "error": "Validation error",
            "details": e.messages
        }), 400

    role, message, status_code = RoleService.create_role(data)
    if role is not None:
        return jsonify({
            "message": message,
            "role": RoleSchema().dump(role)
        }), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/<int:role_id>', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_role(role_id):
    """Get a role by ID.
    Requires MANAGE_ROLES permission.
    ---
    get:
      summary: Get a role by ID (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role to retrieve
      responses:
        200:
          description: Role details
          content:
            application/json:
              schema: RoleSchema
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    role, message, status_code = RoleService.get_role_by_id(role_id)
    if role is not None:
        return jsonify({
            "message": message,
            "role": RoleSchema().dump(role)
        }), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/<int:role_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_ROLES')
def update_role(role_id):
    """Update a role.
    Requires MANAGE_ROLES permission.
    ---
    patch:
      summary: Update a role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role to update
      requestBody:
        required: true
        content:
          application/json:
            schema: RoleUpdateRequestSchema
      responses:
        200:
          description: Role updated
          content:
            application/json:
              schema: RoleSchema
        400:
          description: Bad request
          content:
            application/json:
              schema: ErrorResponseSchema
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Not found
          content:
            application/json:
              schema: ErrorResponseSchema
        409:
          description: Conflict (role name already exists)
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    try:
        schema = RoleUpdateRequestSchema()
        data = schema.load(request.get_json())
    except ValidationError as e:
        return jsonify({
            "error": "Validation error",
            "details": e.messages
        }), 400

    role, message, status_code = RoleService.update_role(role_id, data)
    if role is not None:
        return jsonify({
            "message": message,
            "role": RoleSchema().dump(role)
        }), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/<int:role_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_ROLES')
def delete_role(role_id):
    """Delete a role.
    Requires MANAGE_ROLES permission.
    ---
    delete:
      summary: Delete a role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role to delete
      responses:
        200:
          description: Role deleted
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Not found
          content:
            application/json:
              schema: ErrorResponseSchema
        409:
          description: Conflict (role has assigned users)
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    success, message, status_code = RoleService.delete_role(role_id)
    if success:
        return jsonify({"message": message}), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/<int:role_id>/permissions', methods=['GET'])
@token_required
@require_permission('MANAGE_ROLES')
def get_role_permissions(role_id):
    """Get all permissions assigned to a role.
    Requires MANAGE_ROLES permission.
    ---
    get:
      summary: Get role permissions (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role
      responses:
        200:
          description: List of permissions
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                  permissions:
                    type: array
                    items:
                      $ref: '#/components/schemas/PermissionSchema'
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Role not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    permissions, message, status_code = RoleService.get_role_permissions(role_id)
    if permissions is not None:
        return jsonify({
            "message": message,
            "permissions": PermissionSchema(many=True).dump(permissions)
        }), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/<int:role_id>/permissions', methods=['POST'])
@token_required
@require_permission('MANAGE_ROLES')
def assign_permission(role_id):
    """Assign a permission to a role.
    Requires MANAGE_ROLES permission.
    ---
    post:
      summary: Assign permission to role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role
      requestBody:
        required: true
        content:
          application/json:
            schema: RoleAssignPermissionRequestSchema
      responses:
        200:
          description: Permission assigned
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        400:
          description: Bad request
          content:
            application/json:
              schema: ErrorResponseSchema
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Role or permission not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    try:
        schema = RoleAssignPermissionRequestSchema()
        data = schema.load(request.get_json())
    except ValidationError as e:
        return jsonify({
            "error": "Validation error",
            "details": e.messages
        }), 400

    role, message, status_code = RoleService.assign_permission_to_role(role_id, data['permission_id'])
    if role is not None:
        return jsonify({"message": message}), status_code
    return jsonify({"error": message}), status_code

@role_admin_bp.route('/<int:role_id>/permissions/<int:permission_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_ROLES')
def remove_permission(role_id, permission_id):
    """Remove a permission from a role.
    Requires MANAGE_ROLES permission.
    ---
    delete:
      summary: Remove permission from role (admin, MANAGE_ROLES permission required)
      tags:
        - Admin - Roles
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: role_id
          schema:
            type: integer
          required: true
          description: ID of the role
        - in: path
          name: permission_id
          schema:
            type: integer
          required: true
          description: ID of the permission to remove
      responses:
        200:
          description: Permission removed
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        401:
          description: Unauthorized
          content:
            application/json:
              schema: ErrorResponseSchema
        403:
          description: Forbidden (missing permission)
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: Role or permission not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    role, message, status_code = RoleService.remove_permission_from_role(role_id, permission_id)
    if role is not None:
        return jsonify({"message": message}), status_code
    return jsonify({"error": message}), status_code
</file>

<file path="src/routes/admin/user_admin_routes.py">
from flask import Blueprint, request, jsonify, g
from marshmallow import ValidationError

from ...utils.decorators import token_required, require_permission
from ...services.user_service import UserService
from ...schemas.user_schemas import (
    UserCreateRequestSchema,
    UserUpdateRequestSchema,
    UserListResponseSchema,
    UserDetailSchema,
    ErrorResponseSchema
)

user_admin_bp = Blueprint('user_admin', __name__)

@user_admin_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_USERS')
def get_users():
    """Get list of users with optional filters.
    ---
    get:
      summary: Get list of users
      description: Retrieve list of users with optional filters for active status
      parameters:
        - in: query
          name: is_active
          schema:
            type: boolean
          description: Filter by user active status
      responses:
        200:
          description: List of users retrieved successfully
          content:
            application/json:
              schema: UserListResponseSchema
        500:
          description: Internal server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    filters = {}
    if 'is_active' in request.args:
        filters['is_active'] = request.args.get('is_active')

    users, message, status_code = UserService.get_users(filters)
    
    if status_code != 200:
        return jsonify({"error": message}), status_code
    
    result = UserListResponseSchema().dump({"message": message, "users": users})
    return jsonify(result), 200

@user_admin_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_USERS')
def create_user():
    """Create a new user.
    ---
    post:
      summary: Create new user
      description: Create a new user with specified roles
      requestBody:
        required: true
        content:
          application/json:
            schema: UserCreateRequestSchema
      responses:
        201:
          description: User created successfully
          content:
            application/json:
              schema: UserDetailSchema
        400:
          description: Invalid request data
          content:
            application/json:
              schema: ErrorResponseSchema
        409:
          description: Email already exists
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Internal server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    try:
        data = UserCreateRequestSchema().load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "details": err.messages}), 400

    user, message, status_code = UserService.create_user(data)
    
    if status_code != 201:
        return jsonify({"error": message}), status_code
    
    result = {"message": message, "user": UserDetailSchema().dump(user)}
    return jsonify(result), 201

@user_admin_bp.route('/<int:user_id>', methods=['GET'])
@token_required
@require_permission('VIEW_USERS')
def get_user(user_id):
    """Get user details by ID.
    ---
    get:
      summary: Get user details
      description: Retrieve detailed information about a specific user
      parameters:
        - in: path
          name: user_id
          required: true
          schema:
            type: integer
          description: ID of the user to retrieve
      responses:
        200:
          description: User details retrieved successfully
          content:
            application/json:
              schema: UserDetailSchema
        404:
          description: User not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Internal server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    user, message, status_code = UserService.get_user_by_id(user_id)
    
    if status_code != 200:
        return jsonify({"error": message}), status_code
    
    result = {"message": message, "user": UserDetailSchema().dump(user)}
    return jsonify(result), 200

@user_admin_bp.route('/<int:user_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_USERS')
def update_user(user_id):
    """Update user details.
    ---
    patch:
      summary: Update user details
      description: Update specific fields of a user
      parameters:
        - in: path
          name: user_id
          required: true
          schema:
            type: integer
          description: ID of the user to update
      requestBody:
        required: true
        content:
          application/json:
            schema: UserUpdateRequestSchema
      responses:
        200:
          description: User updated successfully
          content:
            application/json:
              schema: UserDetailSchema
        400:
          description: Invalid request data
          content:
            application/json:
              schema: ErrorResponseSchema
        404:
          description: User not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Internal server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    try:
        data = UserUpdateRequestSchema().load(request.json)
    except ValidationError as err:
        return jsonify({"error": "Validation error", "details": err.messages}), 400

    user, message, status_code = UserService.update_user(user_id, data)
    
    if status_code != 200:
        return jsonify({"error": message}), status_code
    
    result = {"message": message, "user": UserDetailSchema().dump(user)}
    return jsonify(result), 200

@user_admin_bp.route('/<int:user_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_USERS')
def delete_user(user_id):
    """Delete (deactivate) a user.
    ---
    delete:
      summary: Delete user
      description: Soft delete a user by setting is_active to False
      parameters:
        - in: path
          name: user_id
          required: true
          schema:
            type: integer
          description: ID of the user to delete
      responses:
        200:
          description: User deleted successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        404:
          description: User not found
          content:
            application/json:
              schema: ErrorResponseSchema
        500:
          description: Internal server error
          content:
            application/json:
              schema: ErrorResponseSchema
    """
    success, message, status_code = UserService.delete_user(user_id)
    
    if not success:
        return jsonify({"error": message}), status_code
    
    return jsonify({"message": message}), 200
</file>

<file path="src/routes/auth/auth_routes.py">
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from datetime import datetime, timezone
from src.models.user import User
from src.utils.password import check_password

auth_bp = Blueprint('auth_bp', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    
    if not data or 'email' not in data or 'password' not in data:
        return jsonify({'error': 'Missing email or password'}), 400
        
    user = User.query.filter_by(email=data['email']).first()
    
    if not user or not check_password(data['password'], user.password):
        return jsonify({'error': 'Invalid email or password'}), 401
    
    # Create the JWT token with standardized claims
    token_payload = {
        'sub': user.id,
        'email': user.email,
        'role': user.role,
        'iat': datetime.now(timezone.utc)
    }
    
    access_token = create_access_token(
        identity=token_payload,
        expires_delta=current_app.config['JWT_ACCESS_TOKEN_EXPIRES']
    )
    
    return jsonify({
        'access_token': access_token,
        'token_type': current_app.config['JWT_HEADER_TYPE']
    }), 200
</file>

<file path="src/routes/__init__.py">
from .fuel_order_routes import fuel_order_bp
from .auth_routes import auth_bp
from .user_routes import user_bp
from .fuel_truck_routes import truck_bp

__all__ = ['fuel_order_bp', 'auth_bp', 'user_bp', 'truck_bp']
</file>

<file path="src/routes/aircraft_routes.py">
from flask import Blueprint, request, jsonify
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services.aircraft_service import AircraftService
from ..schemas.aircraft_schemas import (
    AircraftCreateSchema,
    AircraftUpdateSchema,
    AircraftResponseSchema,
    AircraftListSchema,
    ErrorResponseSchema
)

aircraft_bp = Blueprint('aircraft_bp', __name__, url_prefix='/api/aircraft')

@aircraft_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_AIRCRAFT')
def list_aircraft():
    """Get all aircraft (VIEW_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    responses:
      200:
        description: Aircraft list
        content:
          application/json:
            schema: AircraftListSchema
    """
    filters = {}
    if 'customer_id' in request.args:
        filters['customer_id'] = request.args.get('customer_id', type=int)
    aircraft, message, status_code = AircraftService.get_all_aircraft(filters)
    return jsonify({
        "message": message,
        "aircraft": [AircraftResponseSchema().dump(a) for a in aircraft]
    }), status_code

@aircraft_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def create_aircraft():
    """Create an aircraft (MANAGE_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: AircraftCreateSchema
    responses:
      201:
        description: Aircraft created
        content:
          application/json:
            schema: AircraftResponseSchema
    """
    schema = AircraftCreateSchema()
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    aircraft, message, status_code = AircraftService.create_aircraft(data)
    if aircraft:
        return jsonify({"message": message, "aircraft": AircraftResponseSchema().dump(aircraft)}), status_code
    else:
        return jsonify({"error": message}), status_code

@aircraft_bp.route('/<string:tail_number>', methods=['GET'])
@token_required
@require_permission('VIEW_AIRCRAFT')
def get_aircraft(tail_number):
    """Get an aircraft by tail number (VIEW_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: tail_number
        schema:
          type: string
        required: true
        description: Tail number
    responses:
      200:
        description: Aircraft found
        content:
          application/json:
            schema: AircraftResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    aircraft, message, status_code = AircraftService.get_aircraft_by_tail(tail_number)
    if aircraft:
        return jsonify({"message": message, "aircraft": AircraftResponseSchema().dump(aircraft)}), status_code
    else:
        return jsonify({"error": message}), status_code

@aircraft_bp.route('/<string:tail_number>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def update_aircraft(tail_number):
    """Update an aircraft (MANAGE_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: tail_number
        schema:
          type: string
        required: true
        description: Tail number
    requestBody:
      required: true
      content:
        application/json:
          schema: AircraftUpdateSchema
    responses:
      200:
        description: Aircraft updated
        content:
          application/json:
            schema: AircraftResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = AircraftUpdateSchema(partial=True)
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    aircraft, message, status_code = AircraftService.update_aircraft(tail_number, data)
    if aircraft:
        return jsonify({"message": message, "aircraft": AircraftResponseSchema().dump(aircraft)}), status_code
    else:
        return jsonify({"error": message}), status_code

@aircraft_bp.route('/<string:tail_number>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_AIRCRAFT')
def delete_aircraft(tail_number):
    """Delete an aircraft (MANAGE_AIRCRAFT permission required).
    ---
    tags:
      - Aircraft
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: tail_number
        schema:
          type: string
        required: true
        description: Tail number
    responses:
      200:
        description: Aircraft deleted
        content:
          application/json:
            schema:
              type: object
              properties:
                message:
                  type: string
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    success, message, status_code = AircraftService.delete_aircraft(tail_number)
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="src/routes/auth_routes.py">
from flask import Blueprint, request, jsonify, current_app
from ..services.auth_service import AuthService
from flask_jwt_extended import create_access_token
from ..schemas import (
    RegisterRequestSchema,
    RegisterResponseSchema,
    LoginRequestSchema,
    LoginSuccessResponseSchema,
    ErrorResponseSchema
)
from ..models.user import User
from ..models.role import Role
from ..extensions import db, jwt
from marshmallow import ValidationError
from functools import wraps
import time
from datetime import datetime, timedelta
import jwt as pyjwt
from src.utils.rate_limiting import rate_limit

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

# Rate limiting state
login_attempts = {}
RATE_LIMIT = 5  # attempts
RATE_WINDOW = 300  # seconds (5 minutes)

def reset_rate_limits():
    """Reset rate limiting state (for testing)."""
    global login_attempts
    login_attempts = {}

@auth_bp.route('/register', methods=['POST'])
def register():
    """Register a new user.
    ---
    tags:
      - Authentication
    requestBody:
      required: true
      content:
        application/json:
          schema: RegisterRequestSchema
    responses:
      201:
        description: User registered successfully
        content:
          application/json:
            schema: RegisterResponseSchema
      400:
        description: Bad Request (e.g., missing fields, invalid email/password format)
        content:
          application/json:
            schema: ErrorResponseSchema
      409:
        description: Conflict (e.g., email already registered)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = RegisterRequestSchema()
    try:
        data = schema.load(request.json)
    except:
        return jsonify({'error': 'Invalid request data'}), 400

    if User.query.filter_by(email=data['email']).first():
        return jsonify({'error': 'Email already registered'}), 409

    user = User(
        username=data['username'],
        email=data['email'],
        name=data['name'],
        is_active=True
    )
    user.set_password(data['password'])

    db.session.add(user)
    db.session.commit()

    return jsonify({
        'message': 'User registered successfully',
        'user': {
            'id': user.id,
            'email': user.email,
            'name': user.name
        }
    }), 201

@auth_bp.route('/login', methods=['POST'])
@rate_limit(RATE_LIMIT, RATE_WINDOW)
def login():
    """Login a user."""
    schema = LoginRequestSchema()
    try:
        data = schema.load(request.json)
    except:
        return jsonify({'error': 'Invalid request data'}), 400

    user = User.query.filter_by(email=data['email']).first()
    if not user or not user.check_password(data['password']):
        return jsonify({'error': 'Invalid credentials'}), 401

    if not user.is_active:
        return jsonify({'error': 'Account is inactive'}), 403

    # Generate JWT token
    access_token = create_access_token(
        identity=user.id,
        additional_claims={
            'username': user.username,
            'roles': [role.name for role in user.roles],
            'is_active': user.is_active
        }
    )

    return jsonify({
        'access_token': access_token,
        'token_type': 'Bearer'
    }), 200

@auth_bp.route('/login', methods=['POST'])
@rate_limit(endpoint='login')
def login_old():
    """Login endpoint that returns a JWT token on successful authentication"""
    try:
        # Validate request data
        schema = LoginRequestSchema()
        data = request.get_json()
        
        if not data:
            return jsonify({
                'error': 'Missing required fields',
                'details': 'Request body is empty'
            }), 400
            
        try:
            data = schema.load(data)
        except ValidationError as err:
            return jsonify({
                'error': 'Missing required fields',
                'details': err.messages
            }), 400
        
        print(f"Authenticating user with email: {data['email']}")
        
        # Find user by email
        user = User.query.filter_by(email=data['email']).first()
        print(f"Found user: {user}")
        
        if not user:
            return jsonify({'error': 'Invalid email or password'}), 401
            
        if not user.is_active:
            return jsonify({'error': 'User account is inactive'}), 401
            
        # Check password
        if not user.check_password(data['password']):
            print("Password check failed")
            return jsonify({'error': 'Invalid email or password'}), 401
            
        # Generate access token
        access_token = create_access_token(identity=user.id)
        
        # Generate response
        response_schema = LoginSuccessResponseSchema()
        return response_schema.dump({
            'user': user.to_dict(),
            'token': access_token
        }), 200
        
    except Exception as e:
        import traceback
        tb = traceback.format_exc()
        print(f"[LOGIN ERROR] {str(e)}\nTraceback:\n{tb}")
        return jsonify({
            'error': 'Internal server error',
            'details': str(e)
        }), 500
</file>

<file path="src/routes/customer_routes.py">
from flask import Blueprint, request, jsonify
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services.customer_service import CustomerService
from ..schemas.customer_schemas import (
    CustomerCreateSchema,
    CustomerUpdateSchema,
    CustomerResponseSchema,
    CustomerListSchema,
    ErrorResponseSchema
)

customer_bp = Blueprint('customer_bp', __name__, url_prefix='/api/customers')

@customer_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_CUSTOMERS')
def list_customers():
    """Get all customers (VIEW_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    responses:
      200:
        description: Customer list
        content:
          application/json:
            schema: CustomerListSchema
    """
    customers, message, status_code = CustomerService.get_all_customers()
    return jsonify({
        "message": message,
        "customers": [CustomerResponseSchema().dump(c) for c in customers]
    }), status_code

@customer_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def create_customer():
    """Create a customer (MANAGE_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: CustomerCreateSchema
    responses:
      201:
        description: Customer created
        content:
          application/json:
            schema: CustomerResponseSchema
    """
    schema = CustomerCreateSchema()
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    customer, message, status_code = CustomerService.create_customer(data)
    if customer:
        return jsonify({"message": message, "customer": CustomerResponseSchema().dump(customer)}), status_code
    else:
        return jsonify({"error": message}), status_code

@customer_bp.route('/<int:customer_id>', methods=['GET'])
@token_required
@require_permission('VIEW_CUSTOMERS')
def get_customer(customer_id):
    """Get a customer by ID (VIEW_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: customer_id
        schema:
          type: integer
        required: true
        description: Customer ID
    responses:
      200:
        description: Customer found
        content:
          application/json:
            schema: CustomerResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    customer, message, status_code = CustomerService.get_customer_by_id(customer_id)
    if customer:
        return jsonify({"message": message, "customer": CustomerResponseSchema().dump(customer)}), status_code
    else:
        return jsonify({"error": message}), status_code

@customer_bp.route('/<int:customer_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def update_customer(customer_id):
    """Update a customer (MANAGE_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: customer_id
        schema:
          type: integer
        required: true
        description: Customer ID
    requestBody:
      required: true
      content:
        application/json:
          schema: CustomerUpdateSchema
    responses:
      200:
        description: Customer updated
        content:
          application/json:
            schema: CustomerResponseSchema
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = CustomerUpdateSchema(partial=True)
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    customer, message, status_code = CustomerService.update_customer(customer_id, data)
    if customer:
        return jsonify({"message": message, "customer": CustomerResponseSchema().dump(customer)}), status_code
    else:
        return jsonify({"error": message}), status_code

@customer_bp.route('/<int:customer_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_CUSTOMERS')
def delete_customer(customer_id):
    """Delete a customer (MANAGE_CUSTOMERS permission required).
    ---
    tags:
      - Customers
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: customer_id
        schema:
          type: integer
        required: true
        description: Customer ID
    responses:
      200:
        description: Customer deleted
        content:
          application/json:
            schema:
              type: object
              properties:
                message:
                  type: string
      404:
        description: Not found
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    success, message, status_code = CustomerService.delete_customer(customer_id)
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="src/routes/fuel_order_queue_routes.py">
from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from src.extensions import db
from src.models.fuel_order import FuelOrder
from src.models.user import User
from sqlalchemy import and_
from datetime import datetime

bp = Blueprint('fuel_order_queue', __name__, url_prefix='/api/orders')

# GET /api/orders/unassigned - List all unassigned fuel orders (for LST queue)
@bp.route('/unassigned', methods=['GET'])
@jwt_required()
def get_unassigned_orders():
    # Optionally check LST role
    # user_id = get_jwt_identity()
    orders = FuelOrder.query.filter(
        FuelOrder.assigned_lst_user_id.is_(None)
    ).order_by(FuelOrder.created_at.asc()).all()
    return jsonify({
        'orders': [
            {
                'id': o.id,
                'tail_number': o.tail_number,
                'requested_amount': float(o.requested_amount) if o.requested_amount else None,
                'location_on_ramp': o.location_on_ramp,
                'created_at': o.created_at.isoformat(),
                'fuel_type': o.fuel_type,
                'csr_notes': o.csr_notes,
                'status': o.status.value,
            } for o in orders
        ]
    })

# POST /api/orders/<order_id>/accept - LST claims an order
@bp.route('/<int:order_id>/accept', methods=['POST'])
@jwt_required()
def accept_order(order_id):
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    if not user or user.role != 'LST':
        return jsonify({'error': 'Unauthorized'}), 403
    order = FuelOrder.query.get(order_id)
    if not order:
        return jsonify({'error': 'Order not found'}), 404
    if order.assigned_lst_user_id is not None:
        return jsonify({'error': 'Order already assigned'}), 409
    # Atomically assign
    order.assigned_lst_user_id = user_id
    order.status = 'ACKNOWLEDGED'
    order.acknowledge_timestamp = datetime.utcnow()
    db.session.commit()
    return jsonify({'success': True, 'order_id': order.id, 'assigned_lst_user_id': user_id})
</file>

<file path="src/routes/fuel_order_routes.py">
from flask import Blueprint, request, jsonify, g, Response
from decimal import Decimal
from datetime import datetime
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..models.fuel_order import FuelOrder, FuelOrderStatus
from ..services.fuel_order_service import FuelOrderService
from ..schemas import OrderStatusCountsResponseSchema, ErrorResponseSchema
from ..extensions import db

# Create the blueprint for fuel order routes
fuel_order_bp = Blueprint('fuel_order_bp', __name__)

# Special value for auto-assigning LST
AUTO_ASSIGN_LST_ID = -1  # If this value is provided, backend will auto-select least busy LST

@fuel_order_bp.route('/stats/status-counts', methods=['GET'])
@token_required
@require_permission('VIEW_ORDER_STATS')
def get_status_counts():
    """Get counts of fuel orders by status groups.
    Requires VIEW_ORDER_STATS permission. Returns counts for Pending, In Progress, Completed.
    ---
    tags:
      - Fuel Orders Stats
    security:
      - bearerAuth: []
    responses:
      200:
        description: Status counts retrieved successfully
        content:
          application/json:
            schema: OrderStatusCountsResponseSchema
      401:
        description: Unauthorized
      403:
        description: Forbidden
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    counts, message, status_code = FuelOrderService.get_status_counts(current_user=g.current_user)
    if counts is not None:
        return jsonify({"message": message, "counts": counts}), status_code
    else:
        return jsonify({"error": message}), status_code


@fuel_order_bp.route('/', methods=['POST'])
@token_required
@require_permission('CREATE_ORDER')
def create_fuel_order():
    import logging
    logger = logging.getLogger(__name__)
    from flask import current_app
    logger.info('[DEBUG] JWT_SECRET_KEY in create_fuel_order: %s', current_app.config.get('JWT_SECRET_KEY'))
    logger.info('[DEBUG] JWT_ALGORITHM in create_fuel_order: %s', current_app.config.get('JWT_ALGORITHM', 'HS256'))
    logger.info('Entered create_fuel_order')
    logger.info('Request data: %s', request.get_json())
    """Create a new fuel order.
    Requires CREATE_ORDER permission. If assigned_lst_user_id is -1, the backend will auto-assign the least busy active LST.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelOrderCreateRequestSchema
    responses:
      201:
        description: Fuel order created successfully
        content:
          application/json:
            schema: FuelOrderCreateResponseSchema
      400:
        description: Bad Request (e.g., missing fields, validation error, invalid related IDs)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    data = request.get_json()
    
    # Check if data exists and is a dictionary
    if not data or not isinstance(data, dict):
        return jsonify({"error": "Invalid request data"}), 400
    
    # Required fields validation
    required_fields = {
        'tail_number': str,
        'fuel_type': str,
        'assigned_lst_user_id': int,
        'assigned_truck_id': int,
        'requested_amount': float,
        'location_on_ramp': str
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            logger.error('Step 2.1: Missing required field: %s', field)
            return jsonify({"error": f"Missing required field: {field}"}), 400
        # Type check (allow -1 for assigned_lst_user_id)
        if field == 'assigned_lst_user_id':
            try:
                data[field] = int(data[field])
            except Exception:
                return jsonify({"error": f"Invalid type for field: {field} (must be integer or -1)"}), 400
        else:
            if not isinstance(data[field], field_type):
                return jsonify({"error": f"Invalid type for field: {field}"}), 400
        try:
            from src.services.user_service import UserService
            from src.models.user import UserRole
            # Get all active LST users
            lst_users, _, _ = UserService.get_users({'role': UserRole.LST, 'is_active': True})
            if not lst_users:
                logger.error('No active LST users found for auto-assignment')
                return jsonify({"error": "No active LST users available for auto-assignment"}), 400
            # Find the LST with the fewest active/in-progress orders
            from src.models.fuel_order import FuelOrderStatus, FuelOrder
            least_busy = None
            min_orders = None
            for lst in lst_users:
                count = FuelOrder.query.filter(
                    FuelOrder.assigned_lst_user_id == lst.id,
                    FuelOrder.status.in_([
                        FuelOrderStatus.DISPATCHED,
                        FuelOrderStatus.ACKNOWLEDGED,
                        FuelOrderStatus.EN_ROUTE,
                        FuelOrderStatus.FUELING
                    ])
                ).count()
                if min_orders is None or count < min_orders:
                    min_orders = count
                    least_busy = lst
            if not least_busy:
                logger.error('Auto-assign logic failed to select an LST')
                return jsonify({"error": "Auto-assign failed to select an LST"}), 400
            data['assigned_lst_user_id'] = least_busy.id
            logger.info(f"Auto-assigned LST user_id {least_busy.id} (username={least_busy.username}) with {min_orders} active orders.")
        except Exception as e:
            logger.error(f"Error during auto-assignment of LST: {str(e)}")
            return jsonify({"error": f"Error during auto-assignment of LST: {str(e)}"}), 500
    # --- END AUTO-ASSIGN ---

    # Optional fields validation
    optional_fields = {
        'customer_id': int,
        'additive_requested': bool,
        'csr_notes': str
    }
    
    for field, field_type in optional_fields.items():
        if field in data:
            try:
                # Convert to expected type if necessary
                if field_type == int:
                    data[field] = int(data[field])
                elif field_type == bool and not isinstance(data[field], bool):
                    data[field] = bool(data[field])
                elif field_type == str and not isinstance(data[field], str):
                    data[field] = str(data[field])
            except (ValueError, TypeError):
                logger.error('Step 3.1: Invalid type for optional field %s. Value: %s', field, data[field])
                return jsonify({"error": f"Invalid type for field {field}. Expected {field_type.__name__}"}), 400
    logger.info('Step 3: Passed optional fields validation')
    
    # Create the fuel order
    try:
        logger.info('Step 4: Creating FuelOrder with data: %s', data)
        fuel_order = FuelOrder(
            tail_number=data['tail_number'],
            customer_id=data.get('customer_id'),
            fuel_type=data['fuel_type'],
            additive_requested=data.get('additive_requested', False),
            requested_amount=data['requested_amount'],
            assigned_lst_user_id=data['assigned_lst_user_id'],
            assigned_truck_id=data['assigned_truck_id'],
            location_on_ramp=data['location_on_ramp'],
            csr_notes=data.get('csr_notes')
        )
        logger.info('Step 5: FuelOrder object created')
        db.session.add(fuel_order)
        logger.info('Step 6: FuelOrder added to session')
        db.session.commit()
        logger.info('Step 7: FuelOrder committed')
        return jsonify({
            'id': fuel_order.id,
            'tail_number': fuel_order.tail_number,
            'customer_id': fuel_order.customer_id,
            'fuel_type': fuel_order.fuel_type,
            'additive_requested': fuel_order.additive_requested,
            'requested_amount': fuel_order.requested_amount,
            'assigned_lst_user_id': fuel_order.assigned_lst_user_id,
            'assigned_truck_id': fuel_order.assigned_truck_id,
            'location_on_ramp': fuel_order.location_on_ramp,
            'csr_notes': fuel_order.csr_notes,
            'status': fuel_order.status.value,
            'created_at': fuel_order.created_at.isoformat()
        }), 201
    except Exception as e:
        db.session.rollback()
        logger.exception("Exception in create_fuel_order")
        return jsonify({"error": f"Error creating fuel order: {str(e)}"}), 500

@fuel_order_bp.route('/', methods=['GET'])
@token_required
def get_fuel_orders():
    """Get a list of fuel orders.
    LSTs see only their assigned orders. CSRs/Admins see all. Supports filtering and pagination.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: query
        name: status
        schema:
          type: string
          enum: [DISPATCHED, ACKNOWLEDGED, EN_ROUTE, FUELING, COMPLETED, REVIEWED, CANCELLED]
        required: false
        description: Filter orders by status (case-insensitive)
      - in: query
        name: page
        schema:
          type: integer
          default: 1
        required: false
        description: Page number for pagination
      - in: query
        name: per_page
        schema:
          type: integer
          default: 20
        required: false
        description: Number of items per page (max 100)
    responses:
      200:
        description: List of fuel orders retrieved successfully
        content:
          application/json:
            schema: FuelOrderListResponseSchema
      400:
        description: Bad Request (e.g., invalid status filter value)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Extract and validate filter/pagination parameters
    filters = {
        'status': request.args.get('status', None, type=str),
        'page': request.args.get('page', 1, type=int),
        'per_page': request.args.get('per_page', 20, type=int)
        # Add other potential filters here later (e.g., date_from, date_to, tail_number)
    }

    # Basic validation/sanitization
    if filters['page'] < 1: filters['page'] = 1
    if filters['per_page'] < 1: filters['per_page'] = 1
    if filters['per_page'] > 100: filters['per_page'] = 100  # Match service limit

    # Call service method with current user and filters
    paginated_result, message = FuelOrderService.get_fuel_orders(
        current_user=g.current_user,
        filters=filters
    )

    # Handle the result
    if paginated_result is not None:
        # Serialize the orders
        orders_list = []
        for order in paginated_result.items:
            orders_list.append({
                "id": order.id,
                "status": order.status.value,
                "tail_number": order.tail_number,
                "customer_id": order.customer_id,
                "fuel_type": order.fuel_type,
                "additive_requested": order.additive_requested,
                "requested_amount": str(order.requested_amount) if order.requested_amount else None,
                "assigned_lst_user_id": order.assigned_lst_user_id,
                "assigned_truck_id": order.assigned_truck_id,
                "location_on_ramp": order.location_on_ramp,
                "start_meter_reading": str(order.start_meter_reading) if order.start_meter_reading else None,
                "end_meter_reading": str(order.end_meter_reading) if order.end_meter_reading else None,
                "calculated_gallons_dispensed": str(order.calculated_gallons_dispensed) if order.calculated_gallons_dispensed else None,
                "created_at": order.created_at.isoformat(),
                "dispatch_timestamp": order.dispatch_timestamp.isoformat() if order.dispatch_timestamp else None,
                "acknowledge_timestamp": order.acknowledge_timestamp.isoformat() if order.acknowledge_timestamp else None,
                "en_route_timestamp": order.en_route_timestamp.isoformat() if order.en_route_timestamp else None,
                "fueling_start_timestamp": order.fueling_start_timestamp.isoformat() if order.fueling_start_timestamp else None,
                "completion_timestamp": order.completion_timestamp.isoformat() if order.completion_timestamp else None,
                "reviewed_timestamp": order.reviewed_timestamp.isoformat() if order.reviewed_timestamp else None,
                "reviewed_by_csr_user_id": order.reviewed_by_csr_user_id
            })

        # Construct response with orders and pagination metadata
        response = {
            "message": message,
            "fuel_orders": orders_list,
            "pagination": {
                "page": paginated_result.page,
                "per_page": paginated_result.per_page,
                "total_pages": paginated_result.pages,
                "total_items": paginated_result.total,
                "has_next": paginated_result.has_next,
                "has_prev": paginated_result.has_prev
            }
        }
        return jsonify(response), 200
    else:
        # Handle error cases
        status_code = 500 if "Database error" in message else (403 if "Forbidden" in message else 400)
        return jsonify({"error": message}), status_code 

@fuel_order_bp.route('/<int:order_id>', methods=['GET'])
@token_required
def get_fuel_order(order_id):
    """Get details of a specific fuel order.
    LST must be assigned to the order. CSR/Admin can view any.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order to retrieve
    responses:
      200:
        description: Fuel order details retrieved successfully
        content:
          application/json:
            schema: FuelOrderResponseSchema # Use full schema here
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (user not allowed to view this order)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Not Found (fuel order with the given ID does not exist)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Call service method to get the fuel order
    order, message, status_code = FuelOrderService.get_fuel_order_by_id(
        order_id=order_id,
        current_user=g.current_user
    )

    # Handle the result based on whether the order was found
    if order is not None:
        # Serialize the full order details
        order_details = {
            "id": order.id,
            "status": order.status.value,
            "tail_number": order.tail_number,
            "customer_id": order.customer_id,  # Consider joining/fetching customer name later
            "fuel_type": order.fuel_type,
            "additive_requested": order.additive_requested,
            "requested_amount": str(order.requested_amount) if order.requested_amount else None,
            "assigned_lst_user_id": order.assigned_lst_user_id,  # Consider joining/fetching LST name later
            "assigned_truck_id": order.assigned_truck_id,  # Consider joining/fetching truck name later
            "location_on_ramp": order.location_on_ramp,
            "csr_notes": order.csr_notes,
            "start_meter_reading": str(order.start_meter_reading) if order.start_meter_reading else None,
            "end_meter_reading": str(order.end_meter_reading) if order.end_meter_reading else None,
            "calculated_gallons_dispensed": str(order.calculated_gallons_dispensed) if order.calculated_gallons_dispensed else None,
            "lst_notes": order.lst_notes,
            "created_at": order.created_at.isoformat(),
            "dispatch_timestamp": order.dispatch_timestamp.isoformat() if order.dispatch_timestamp else None,
            "acknowledge_timestamp": order.acknowledge_timestamp.isoformat() if order.acknowledge_timestamp else None,
            "en_route_timestamp": order.en_route_timestamp.isoformat() if order.en_route_timestamp else None,
            "fueling_start_timestamp": order.fueling_start_timestamp.isoformat() if order.fueling_start_timestamp else None,
            "completion_timestamp": order.completion_timestamp.isoformat() if order.completion_timestamp else None,
            "reviewed_timestamp": order.reviewed_timestamp.isoformat() if order.reviewed_timestamp else None,
            "reviewed_by_csr_user_id": order.reviewed_by_csr_user_id  # Consider joining/fetching CSR name later
        }
        return jsonify({"message": message, "fuel_order": order_details}), status_code
    else:
        # Return error message and status code from service
        return jsonify({"error": message}), status_code

@fuel_order_bp.route('/<int:order_id>/status', methods=['PATCH'])
@token_required
def update_fuel_order_status(order_id):
    """Update a fuel order's status.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order to update
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelOrderUpdateRequestSchema
    responses:
      200:
        description: Fuel order updated successfully
        content:
          application/json:
            schema: FuelOrderUpdateResponseSchema
      400:
        description: Bad Request (e.g., invalid status)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel order not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    data = request.get_json()
    
    # Check if data exists and is a dictionary
    if not data or not isinstance(data, dict):
        return jsonify({"error": "Invalid request data"}), 400
    
    # Required fields validation
    required_fields = {
        'status': str,
        'assigned_truck_id': int
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400
        try:
            # Convert to expected type if necessary
            if field_type == int:
                data[field] = int(data[field])
            elif field_type == str and not isinstance(data[field], str):
                data[field] = str(data[field])
            
            # Additional validation for specific fields
            if field_type == str and not data[field].strip():
                return jsonify({"error": f"Field {field} cannot be empty"}), 400
        except (ValueError, TypeError):
            return jsonify({"error": f"Invalid type for field {field}. Expected {field_type.__name__}"}), 400
    
    # Get the fuel order
    fuel_order = FuelOrder.query.get(order_id)
    if not fuel_order:
        return jsonify({"error": "Fuel order not found"}), 404
    
    # Update the fuel order
    try:
        # Convert status to uppercase for enum lookup
        status_value = data['status'].upper()
        print(f"Attempting to update status to: {status_value}")
        if status_value not in FuelOrderStatus.__members__:
            print(f"Invalid status value: {data['status']}")
            print(f"Valid status values: {list(FuelOrderStatus.__members__.keys())}")
            return jsonify({"error": f"Invalid status value: {data['status']}"}), 400
            
        fuel_order.status = FuelOrderStatus[status_value]
        fuel_order.assigned_truck_id = data['assigned_truck_id']
        db.session.commit()
        
        return jsonify({
            'id': fuel_order.id,
            'tail_number': fuel_order.tail_number,
            'customer_id': fuel_order.customer_id,
            'fuel_type': fuel_order.fuel_type,
            'additive_requested': fuel_order.additive_requested,
            'requested_amount': fuel_order.requested_amount,
            'assigned_lst_user_id': fuel_order.assigned_lst_user_id,
            'assigned_truck_id': fuel_order.assigned_truck_id,
            'location_on_ramp': fuel_order.location_on_ramp,
            'csr_notes': fuel_order.csr_notes,
            'status': fuel_order.status.value,
            'updated_at': fuel_order.updated_at.isoformat()
        }), 200
    except Exception as e:
        db.session.rollback()
        print(f"Error updating fuel order: {str(e)}")
        print(f"Data: {data}")
        print(f"Status value: {data['status']}")
        return jsonify({"error": f"Error updating fuel order: {str(e)}"}), 500

@fuel_order_bp.route('/<int:order_id>/submit-data', methods=['PUT'])
@token_required
@require_permission('COMPLETE_ORDER')
def submit_fuel_data(order_id):
    """Submit fuel meter readings and notes for a fuel order.
    Requires COMPLETE_ORDER permission. Order must be in FUELING status.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelOrderCompleteRequestSchema
    responses:
      200:
        description: Fuel data submitted successfully
        content:
          application/json:
            schema: FuelOrderUpdateResponseSchema
      400:
        description: Bad Request (e.g., invalid meter readings, validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission or not assigned to order)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel order not found
        content:
          application/json:
            schema: ErrorResponseSchema
      422:
        description: Order not in correct status
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Get the fuel order
    fuel_order = FuelOrder.query.get_or_404(order_id)
    
    # Verify the LST is assigned to this order
    if fuel_order.assigned_lst_user_id != g.current_user.id:
        return jsonify({
            "error": "You are not authorized to submit data for this fuel order"
        }), 403
    
    # Verify order is in FUELING status
    if fuel_order.status != FuelOrderStatus.FUELING:
        return jsonify({
            "error": "Fuel order must be in FUELING status to submit meter readings"
        }), 422
    
    # Get and validate request data
    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400
        
    # Validate required fields
    required_fields = {
        'start_meter_reading': float,
        'end_meter_reading': float
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400
        try:
            value = field_type(data[field])
            if value < 0:
                return jsonify({"error": f"{field} cannot be negative"}), 400
            data[field] = value
        except (ValueError, TypeError):
            return jsonify({"error": f"Invalid type for field {field}. Expected {field_type.__name__}"}), 400
            
    # Validate meter readings
    if data['end_meter_reading'] <= data['start_meter_reading']:
        return jsonify({
            "error": "End meter reading must be greater than start meter reading"
        }), 400
    
    try:
        # Update the fuel order
        fuel_order.start_meter_reading = data['start_meter_reading']
        fuel_order.end_meter_reading = data['end_meter_reading']
        fuel_order.lst_notes = data.get('lst_notes')  # Optional field
        fuel_order.status = FuelOrderStatus.COMPLETED
        fuel_order.completion_timestamp = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            "message": "Fuel data submitted successfully",
            "fuel_order": {
                "id": fuel_order.id,
                "status": fuel_order.status.value,
                "tail_number": fuel_order.tail_number,
                "start_meter_reading": str(fuel_order.start_meter_reading),
                "end_meter_reading": str(fuel_order.end_meter_reading),
                "calculated_gallons_dispensed": str(fuel_order.calculated_gallons_dispensed),
                "lst_notes": fuel_order.lst_notes,
                "completion_timestamp": fuel_order.completion_timestamp.isoformat()
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": f"Error submitting fuel data: {str(e)}"}), 500

@fuel_order_bp.route('/<int:order_id>/review', methods=['PATCH'])
@token_required
@require_permission('REVIEW_ORDERS')
def review_fuel_order(order_id):
    """Mark a completed fuel order as reviewed.
    Requires REVIEW_ORDERS permission. Order must be in COMPLETED state.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order to review
    responses:
      200:
        description: Fuel order marked as reviewed successfully
        content:
          application/json:
            schema: FuelOrderUpdateResponseSchema # Use schema that returns updated order
      400:
        description: Bad Request (order not in COMPLETED state)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Not Found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Call service method to review the order
    reviewed_order, message, status_code = FuelOrderService.review_fuel_order(
        order_id=order_id,
        reviewer_user=g.current_user
    )
    
    # Handle the result from the service
    if reviewed_order is not None:
        # Serialize the reviewed order details for the response
        order_details = {
            "id": reviewed_order.id,
            "status": reviewed_order.status.value,  # Should be REVIEWED
            "reviewed_by_csr_user_id": reviewed_order.reviewed_by_csr_user_id,
            "reviewed_timestamp": reviewed_order.reviewed_timestamp.isoformat() if reviewed_order.reviewed_timestamp else None
        }
        return jsonify({"message": message, "fuel_order": order_details}), status_code  # Use status_code from service (should be 200)
    else:
        return jsonify({"error": message}), status_code  # Use status_code from service (e.g., 400, 404, 500) 

@fuel_order_bp.route('/export', methods=['GET'])
@token_required
@require_permission('EXPORT_ORDERS_CSV')
def export_fuel_orders_csv():
    """Export fuel orders to a CSV file.
    Requires EXPORT_ORDERS_CSV permission.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    responses:
      200:
        description: CSV file exported successfully
      401:
        description: Unauthorized
      403:
        description: Forbidden (missing permission)
      500:
        description: Server error
    """
    # Extract filter parameters from request.args
    filters = {
        'status': request.args.get('status', None, type=str)
        # TODO: Add date_from, date_to filters later
    }

    # Call service method to generate CSV data
    csv_data, message, status_code = FuelOrderService.export_fuel_orders_to_csv(
        current_user=g.current_user,
        filters=filters
    )

    # Handle the result from the service
    if csv_data is not None and status_code == 200:
        # Check if we got an empty list (no data found)
        if isinstance(csv_data, list) and len(csv_data) == 0:
            return jsonify({"message": message}), 200

        # Generate dynamic filename with timestamp
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        filename = f"fuel_orders_export_{timestamp}.csv"

        # Create response with CSV data and appropriate headers
        response = Response(
            csv_data,
            mimetype='text/csv',
            headers={
                "Content-Disposition": f"attachment; filename={filename}"
            }
        )
        return response
    else:
        # Return error message and status code from service
        return jsonify({"error": message}), status_code
</file>

<file path="src/routes/fuel_truck_routes.py">
from flask import Blueprint, request, jsonify, g
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services import FuelTruckService
from ..schemas import (
    FuelTruckListResponseSchema,
    FuelTruckCreateRequestSchema,
    FuelTruckCreateResponseSchema,
    FuelTruckSchema,
    ErrorResponseSchema
)

# Create the blueprint for fuel truck routes
truck_bp = Blueprint('truck_bp', __name__, url_prefix='/api/fuel-trucks')

@truck_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_TRUCKS')
def get_fuel_trucks():
    """Get a list of fuel trucks.
    Requires VIEW_TRUCKS permission. Supports filtering by active status.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: query
        name: is_active
        schema:
          type: string
          enum: ['true', 'false']
        required: false
        description: Filter trucks by active status ('true' or 'false')
    responses:
      200:
        description: List of fuel trucks retrieved successfully
        content:
          application/json:
            schema: FuelTruckListResponseSchema
      400:
        description: Bad Request (e.g., invalid filter value)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Extract filter parameters from request.args
    filters = {
        'is_active': request.args.get('is_active', None, type=str)
    }
    filters = {k: v for k, v in filters.items() if v is not None}

    # Call FuelTruckService to get trucks with filters
    trucks, message, status_code = FuelTruckService.get_trucks(filters=filters)

    if trucks is not None:
        trucks_list = [truck.to_dict() for truck in trucks]
        response = {
            "message": message,
            "fuel_trucks": trucks_list
        }
        return jsonify(response), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_TRUCKS')
def create_fuel_truck():
    """Create a new fuel truck.
    Requires MANAGE_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelTruckCreateRequestSchema
    responses:
      201:
        description: Fuel truck created successfully
        content:
          application/json:
            schema: FuelTruckCreateResponseSchema
      400:
        description: Bad Request (e.g., validation error, duplicate truck number)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Validate request data
    schema = FuelTruckCreateRequestSchema()
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400

    # Call service to create truck
    truck, message, status_code = FuelTruckService.create_truck(data)

    if truck is not None:
        response = {
            "message": message,
            "fuel_truck": FuelTruckSchema().dump(truck)
        }
        return jsonify(response), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/<int:truck_id>', methods=['GET'])
@token_required
@require_permission('VIEW_TRUCKS')
def get_fuel_truck(truck_id):
    """Get a fuel truck by ID.
    Requires VIEW_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: truck_id
        schema:
          type: integer
        required: true
        description: ID of the fuel truck to retrieve
    responses:
      200:
        description: Fuel truck retrieved successfully
        content:
          application/json:
            schema: FuelTruckSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel truck not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    truck, message, status_code = FuelTruckService.get_truck_by_id(truck_id)
    if truck is not None:
        return jsonify({
            "message": message,
            "fuel_truck": FuelTruckSchema().dump(truck)
        }), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/<int:truck_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_TRUCKS')
def update_fuel_truck(truck_id):
    """Update a fuel truck.
    Requires MANAGE_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: truck_id
        schema:
          type: integer
        required: true
        description: ID of the fuel truck to update
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelTruckCreateRequestSchema  # Reuse for simplicity
    responses:
      200:
        description: Fuel truck updated successfully
        content:
          application/json:
            schema: FuelTruckSchema
      400:
        description: Bad Request (validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel truck not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = FuelTruckCreateRequestSchema(partial=True)
    try:
        data = schema.load(request.get_json())
    except Exception as e:
        return jsonify({"error": str(e)}), 400
    truck, message, status_code = FuelTruckService.update_truck(truck_id, data)
    if truck is not None:
        return jsonify({
            "message": message,
            "fuel_truck": FuelTruckSchema().dump(truck)
        }), status_code
    else:
        return jsonify({"error": message}), status_code

@truck_bp.route('/<int:truck_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_TRUCKS')
def delete_fuel_truck(truck_id):
    """Delete a fuel truck by ID.
    Requires MANAGE_TRUCKS permission.
    ---
    tags:
      - Fuel Trucks
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: truck_id
        schema:
          type: integer
        required: true
        description: ID of the fuel truck to delete
    responses:
      200:
        description: Fuel truck deleted successfully
      401:
        description: Unauthorized
      403:
        description: Forbidden (missing permission)
      404:
        description: Fuel truck not found
      500:
        description: Server error
    """
    success, message, status_code = FuelTruckService.delete_truck(truck_id)
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="src/routes/user_routes.py">
from flask import Blueprint, request, jsonify, g
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..services.user_service import UserService
from marshmallow import ValidationError
from ..schemas import (
    UserCreateRequestSchema,
    UserUpdateRequestSchema,
    UserResponseSchema,
    UserListResponseSchema,
    ErrorResponseSchema
)

# Create blueprint for user routes
user_bp = Blueprint('user_bp', __name__, url_prefix='/api/users')

@user_bp.route('/', methods=['GET'])
@token_required
@require_permission('VIEW_USERS')
def get_users():
    """Get a list of users.
    Requires VIEW_USERS permission. Supports filtering by 'role' and 'is_active'.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: query
        name: role
        schema:
          type: string
          enum: [ADMIN, CSR, LST]
        required: false
        description: Filter users by role (case-insensitive)
      - in: query
        name: is_active
        schema:
          type: string
          enum: ['true', 'false']
        required: false
        description: Filter users by active status ('true' or 'false')
    responses:
      200:
        description: List of users retrieved successfully
        content:
          application/json:
            schema: UserListResponseSchema
      400:
        description: Bad Request (e.g., invalid filter value)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Extract filter parameters from request.args
    filters = {
        'role': request.args.get('role', None, type=str),
        'is_active': request.args.get('is_active', None, type=str)  # Keep as string, service handles conversion
    }
    # Remove None values so service doesn't process empty filters unnecessarily
    filters = {k: v for k, v in filters.items() if v is not None}
    
    # Call the service method
    users, message, status_code = UserService.get_users(filters=filters)
    
    # Handle the response
    if users is not None:
        # Serialize the list of user objects, excluding sensitive fields
        users_list = []
        for user in users:
            users_list.append({
                "id": user.id,
                "name": user.username,
                "email": user.email,
                "role": user.role.value,  # Use enum value
                "is_active": user.is_active,
                "created_at": user.created_at.isoformat()
                # DO NOT INCLUDE user.hashed_password
            })
        
        # Construct the final JSON response
        response = {
            "message": message,
            "users": users_list
        }
        return jsonify(response), status_code  # Use status_code from service (should be 200)
    else:
        # Return the error message and status code provided by the service
        return jsonify({"error": message}), status_code  # Use status_code from service (e.g., 400, 500)

@user_bp.route('/', methods=['POST'])
@token_required
@require_permission('MANAGE_USERS')
def create_user():
    """Create a new user.
    Requires MANAGE_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: UserCreateRequestSchema
    responses:
      201:
        description: User created successfully
        content:
          application/json:
            schema: UserResponseSchema
      400:
        description: Bad Request (e.g., missing fields, validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      409:
        description: Conflict (e.g., email already exists)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    try:
        # Load and validate request data
        schema = UserCreateRequestSchema()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
            
        try:
            data = schema.load(data)
        except ValidationError as e:
            return jsonify({
                "error": "Validation error",
                "details": e.messages
            }), 400
        
        # Create user
        user, message, status_code = UserService.create_user(data)
        
        if user is not None:
            # Return serialized user data
            return jsonify({
                "message": message,
                "user": {
                    "id": user.id,
                    "name": user.username,
                    "email": user.email,
                    "role": user.role.value,
                    "is_active": user.is_active,
                    "created_at": user.created_at.isoformat()
                }
            }), status_code
        else:
            return jsonify({"error": message}), status_code
            
    except Exception as e:
        return jsonify({
            "error": "Internal server error",
            "details": str(e)
        }), 500

@user_bp.route('/<int:user_id>', methods=['PATCH'])
@token_required
@require_permission('MANAGE_USERS')
def update_user(user_id):
    """Update a user.
    Requires MANAGE_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: user_id
        schema:
          type: integer
        required: true
        description: ID of user to update
    requestBody:
      required: true
      content:
        application/json:
          schema: UserUpdateRequestSchema
    responses:
      200:
        description: User updated successfully
        content:
          application/json:
            schema: UserResponseSchema
      400:
        description: Bad Request (e.g., validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: User not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    try:
        # Load and validate request data
        schema = UserUpdateRequestSchema()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
            
        try:
            data = schema.load(data)
        except ValidationError as e:
            return jsonify({
                "error": "Validation error",
                "details": e.messages
            }), 400
        
        # Update user
        user, message, status_code = UserService.update_user(user_id, data)
        
        if user is not None:
            # Return serialized user data
            return jsonify({
                "message": message,
                "user": {
                    "id": user.id,
                    "name": user.username,
                    "email": user.email,
                    "role": user.role.value,
                    "is_active": user.is_active,
                    "created_at": user.created_at.isoformat()
                }
            }), status_code
        else:
            return jsonify({"error": message}), status_code
            
    except Exception as e:
        return jsonify({
            "error": "Internal server error",
            "details": str(e)
        }), 500

@user_bp.route('/<int:user_id>', methods=['DELETE'])
@token_required
@require_permission('MANAGE_USERS')
def delete_user(user_id):
    """Delete a user.
    Requires MANAGE_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: user_id
        schema:
          type: integer
        required: true
        description: ID of user to delete
    responses:
      200:
        description: User deleted successfully
      401:
        description: Unauthorized
      403:
        description: Forbidden (missing permission)
      404:
        description: User not found
      500:
        description: Server error
    """
    # Call service to delete user
    success, message, status_code = UserService.delete_user(user_id)
    
    if success:
        return jsonify({"message": message}), status_code
    else:
        return jsonify({"error": message}), status_code

@user_bp.route('/<int:user_id>', methods=['GET'])
@token_required
@require_permission('VIEW_USERS')
def get_user(user_id):
    """Get a user by ID.
    Requires VIEW_USERS permission.
    ---
    tags:
      - Users
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: user_id
        schema:
          type: integer
        required: true
        description: ID of user to retrieve
    responses:
      200:
        description: User retrieved successfully
        content:
          application/json:
            schema: UserResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: User not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Call service to get user
    user, message, status_code = UserService.get_user_by_id(user_id)
    
    if user is not None:
        return jsonify({
            "message": message,
            "user": {
                "id": user.id,
                "name": user.username,
                "email": user.email,
                "role": user.role.value,
                "is_active": user.is_active,
                "created_at": user.created_at.isoformat()
            }
        }), status_code
    else:
        return jsonify({"error": message}), status_code
</file>

<file path="src/schemas/__init__.py">
from .auth_schemas import (
    RegisterRequestSchema, UserResponseSchema, RegisterResponseSchema,
    LoginRequestSchema, LoginSuccessResponseSchema, ErrorResponseSchema
)

from .fuel_order_schemas import (
    FuelOrderCreateRequestSchema, FuelOrderStatusUpdateRequestSchema,
    FuelOrderCompleteRequestSchema, FuelOrderResponseSchema,
    FuelOrderBriefResponseSchema, FuelOrderCreateResponseSchema,
    FuelOrderUpdateResponseSchema, PaginationSchema, FuelOrderListResponseSchema,
    OrderStatusCountsSchema, OrderStatusCountsResponseSchema
) # Ensure all schemas are imported

from .fuel_truck_schemas import (
    FuelTruckSchema, FuelTruckListResponseSchema,
    FuelTruckCreateRequestSchema, FuelTruckCreateResponseSchema
)

from .admin_schemas import (
    AdminAircraftSchema, AdminAircraftListResponseSchema,
    AdminCustomerSchema, AdminCustomerListResponseSchema
)

from .role_schemas import (
    RoleSchema, RoleListResponseSchema,
    RoleCreateRequestSchema, RoleUpdateRequestSchema,
    RoleAssignPermissionRequestSchema
)

from .permission_schemas import PermissionSchema

from marshmallow import Schema, fields, validate

class ErrorResponseSchema(Schema):
    error = fields.String(required=True)
    details = fields.Dict(keys=fields.String(), values=fields.List(fields.String()), required=False)

class UserBaseSchema(Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=False)
    email = fields.Email(required=True)
    role = fields.String(required=True, validate=validate.OneOf(['ADMIN', 'CSR', 'LST']))
    is_active = fields.Boolean(dump_only=True)
    created_at = fields.DateTime(dump_only=True)

class UserCreateRequestSchema(UserBaseSchema):
    password = fields.String(required=True, load_only=True)
    is_active = fields.Boolean(required=False, load_only=True)

class UserUpdateRequestSchema(Schema):
    name = fields.String(required=False)
    role = fields.String(required=False, validate=validate.OneOf(['ADMIN', 'CSR', 'LST']))
    is_active = fields.Boolean(required=False)
    password = fields.String(required=False, load_only=True)

class UserResponseSchema(Schema):
    message = fields.String(required=True)
    user = fields.Nested(UserBaseSchema)

class UserListResponseSchema(Schema):
    message = fields.String(required=True)
    users = fields.List(fields.Nested(UserBaseSchema), required=True)

__all__ = [
    'RegisterRequestSchema', 'UserResponseSchema', 'RegisterResponseSchema',
    'LoginRequestSchema', 'LoginSuccessResponseSchema', 'ErrorResponseSchema',
    'FuelOrderCreateRequestSchema', 'FuelOrderStatusUpdateRequestSchema',
    'FuelOrderCompleteRequestSchema', 'FuelOrderResponseSchema',
    'FuelOrderBriefResponseSchema', 'FuelOrderCreateResponseSchema',
    'FuelOrderUpdateResponseSchema', 'PaginationSchema', 'FuelOrderListResponseSchema',
    'FuelTruckSchema', 'FuelTruckListResponseSchema',
    'FuelTruckCreateRequestSchema',
    'FuelTruckCreateResponseSchema',
    'UserBaseSchema',
    'UserCreateRequestSchema',
    'UserUpdateRequestSchema',
    'UserListResponseSchema',
    'OrderStatusCountsSchema', 'OrderStatusCountsResponseSchema',
    'AdminAircraftSchema', 'AdminAircraftListResponseSchema',
    'AdminCustomerSchema', 'AdminCustomerListResponseSchema',
    'RoleSchema', 'RoleListResponseSchema',
    'RoleCreateRequestSchema', 'RoleUpdateRequestSchema',
    'RoleAssignPermissionRequestSchema',
    'PermissionSchema'
] # Ensure schemas are exported
</file>

<file path="src/schemas/admin_schemas.py">
from marshmallow import Schema, fields

class AdminAircraftSchema(Schema):
    tail_number = fields.String(required=True)
    aircraft_type = fields.String()
    customer_id = fields.Integer(allow_none=True)

class AdminAircraftListResponseSchema(Schema):
    aircraft = fields.List(fields.Nested(AdminAircraftSchema))

class AdminCustomerSchema(Schema):
    id = fields.Integer(required=True)
    name = fields.String(required=True)

class AdminCustomerListResponseSchema(Schema):
    customers = fields.List(fields.Nested(AdminCustomerSchema))

class ErrorResponseSchema(Schema):
    message = fields.String(required=True)
    code = fields.Integer()
</file>

<file path="src/schemas/aircraft_schemas.py">
from marshmallow import Schema, fields

class AircraftCreateSchema(Schema):
    tail_number = fields.String(required=True)
    aircraft_type = fields.String(required=False)
    customer_id = fields.Integer(required=False, allow_none=True)

class AircraftUpdateSchema(Schema):
    aircraft_type = fields.String(required=False)
    customer_id = fields.Integer(required=False, allow_none=True)

class AircraftResponseSchema(Schema):
    tail_number = fields.String()
    aircraft_type = fields.String()
    customer_id = fields.Integer(allow_none=True)

class AircraftListSchema(Schema):
    message = fields.String()
    aircraft = fields.List(fields.Nested(AircraftResponseSchema))

class ErrorResponseSchema(Schema):
    error = fields.String()
    details = fields.Raw(required=False)
</file>

<file path="src/schemas/auth_schema.py">
from marshmallow import Schema, fields, validate

class LoginRequestSchema(Schema):
    """Schema for login request validation"""
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=validate.Length(min=8))

class RegisterRequestSchema(Schema):
    """Schema for user registration request validation"""
    name = fields.Str(required=True, validate=validate.Length(min=1))
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=validate.Length(min=8))
</file>

<file path="src/schemas/auth_schemas.py">
from marshmallow import Schema, fields, validate

class RegisterRequestSchema(Schema):
    """Schema for user registration request"""
    email = fields.Email(required=True)
    password = fields.String(required=True, validate=validate.Length(min=8))
    name = fields.String(required=False)  # Optional name field
    username = fields.String(required=False)  # Optional username field

class UserResponseSchema(Schema):
    id = fields.Int(dump_only=True)
    username = fields.Str(dump_only=True)
    email = fields.Email(dump_only=True)
    role = fields.Str(dump_only=True)
    is_active = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)

class RegisterResponseSchema(Schema):
    """Schema for user registration response"""
    message = fields.String(required=True)
    user = fields.Dict(keys=fields.String(), values=fields.Raw(), required=True)

class LoginRequestSchema(Schema):
    """Schema for login request"""
    email = fields.Email(required=True)
    password = fields.String(required=True)

class LoginSuccessResponseSchema(Schema):
    """Schema for successful login response"""
    token = fields.String(required=True)
    message = fields.String(required=True)

class ErrorResponseSchema(Schema):
    """Schema for error responses"""
    error = fields.String(required=True)
    details = fields.Dict(keys=fields.String(), values=fields.Raw(), required=False)
</file>

<file path="src/schemas/customer_schemas.py">
from marshmallow import Schema, fields

class CustomerCreateSchema(Schema):
    name = fields.String(required=True)

class CustomerUpdateSchema(Schema):
    name = fields.String(required=False)

class CustomerResponseSchema(Schema):
    id = fields.Integer()
    name = fields.String()

class CustomerListSchema(Schema):
    message = fields.String()
    customers = fields.List(fields.Nested(CustomerResponseSchema))

class ErrorResponseSchema(Schema):
    error = fields.String()
    details = fields.Raw(required=False)
</file>

<file path="src/schemas/fuel_order_schemas.py">
from marshmallow import Schema, fields, validate, pre_load
from ..models.fuel_order import FuelOrderStatus
from .auth_schemas import ErrorResponseSchema

# --- Schemas for Payloads ---

class FuelOrderBaseSchema(Schema):
    # Common fields, adjust required/optional based on context
    tail_number = fields.Str(required=True, validate=validate.Length(max=20))
    customer_id = fields.Int(required=False, allow_none=True)
    fuel_type = fields.Str(required=True, validate=validate.Length(max=50))
    additive_requested = fields.Bool(load_default=False)
    requested_amount = fields.Decimal(required=False, allow_none=True, places=2)
    assigned_lst_user_id = fields.Int(required=True)
    assigned_truck_id = fields.Int(required=True)
    location_on_ramp = fields.Str(required=False, allow_none=True, validate=validate.Length(max=100))
    csr_notes = fields.Str(required=False, allow_none=True)

class FuelOrderCreateRequestSchema(FuelOrderBaseSchema):
    """
    Request schema for creating a fuel order. Allows assigned_lst_user_id to be -1 for auto-assign (the backend will select the least busy active LST).
    """
    assigned_lst_user_id = fields.Int(required=True, metadata={"description": "Set to -1 to auto-assign the least busy LST."})

class FuelOrderUpdateRequestSchema(Schema): # For potential future PUT/PATCH
     # Define fields allowed for update, likely optional
     pass

class FuelOrderStatusUpdateRequestSchema(Schema):
    status = fields.Str(required=True, validate=validate.OneOf([s.name for s in FuelOrderStatus]))

    # Convert incoming status string to uppercase before validation/loading
    @pre_load
    def uppercase_status(self, data, **kwargs):
        if 'status' in data and isinstance(data['status'], str):
            data['status'] = data['status'].upper()
        return data

class FuelOrderCompleteRequestSchema(Schema):
    start_meter_reading = fields.Decimal(required=True, places=2)
    end_meter_reading = fields.Decimal(required=True, places=2)
    lst_notes = fields.Str(required=False, allow_none=True)

# --- Schemas for Responses ---

class OrderStatusCountsSchema(Schema):
    pending = fields.Int(dump_only=True)
    in_progress = fields.Int(dump_only=True)
    completed = fields.Int(dump_only=True)

class OrderStatusCountsResponseSchema(Schema):
    """
    Response schema for fuel order status counts endpoint.
    """
    message = fields.Str(dump_only=True)
    counts = fields.Nested(OrderStatusCountsSchema, dump_only=True)


class FuelOrderResponseSchema(Schema):
    # Full representation of a FuelOrder
    id = fields.Int(dump_only=True)
    status = fields.Enum(FuelOrderStatus, by_value=True, dump_only=True) # Dump enum value
    tail_number = fields.Str(dump_only=True)
    customer_id = fields.Int(dump_only=True, allow_none=True)
    fuel_type = fields.Str(dump_only=True)
    additive_requested = fields.Bool(dump_only=True)
    requested_amount = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True) # Dump Decimal as string
    assigned_lst_user_id = fields.Int(dump_only=True, allow_none=True)
    assigned_truck_id = fields.Int(dump_only=True, allow_none=True)
    location_on_ramp = fields.Str(dump_only=True, allow_none=True)
    csr_notes = fields.Str(dump_only=True, allow_none=True)
    start_meter_reading = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True)
    end_meter_reading = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True)
    calculated_gallons_dispensed = fields.Decimal(dump_only=True, places=2, as_string=True, allow_none=True)
    lst_notes = fields.Str(dump_only=True, allow_none=True)
    created_at = fields.DateTime(dump_only=True)
    dispatch_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    acknowledge_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    en_route_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    fueling_start_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    completion_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    reviewed_timestamp = fields.DateTime(dump_only=True, allow_none=True)
    reviewed_by_csr_user_id = fields.Int(dump_only=True, allow_none=True)

class FuelOrderBriefResponseSchema(Schema): # For list view
    # Subset of fields for list responses
    id = fields.Int(dump_only=True)
    status = fields.Enum(FuelOrderStatus, by_value=True, dump_only=True)
    tail_number = fields.Str(dump_only=True)
    assigned_lst_user_id = fields.Int(dump_only=True, allow_none=True)
    assigned_truck_id = fields.Int(dump_only=True, allow_none=True)
    created_at = fields.DateTime(dump_only=True)

class FuelOrderCreateResponseSchema(Schema):
    message = fields.Str(dump_only=True)
    fuel_order = fields.Nested(FuelOrderResponseSchema, dump_only=True) # Return full details on create

class FuelOrderUpdateResponseSchema(Schema): # For status, complete, review
    message = fields.Str(dump_only=True)
    fuel_order = fields.Nested(FuelOrderResponseSchema, dump_only=True) # Return updated details

class PaginationSchema(Schema):
    page = fields.Int(dump_only=True)
    per_page = fields.Int(dump_only=True)
    total_pages = fields.Int(dump_only=True)
    total_items = fields.Int(dump_only=True)
    has_next = fields.Bool(dump_only=True)
    has_prev = fields.Bool(dump_only=True)

class FuelOrderListResponseSchema(Schema):
    message = fields.Str(dump_only=True)
    fuel_orders = fields.List(fields.Nested(FuelOrderBriefResponseSchema), dump_only=True) # Use brief schema for list
    pagination = fields.Nested(PaginationSchema, dump_only=True)
</file>

<file path="src/schemas/fuel_truck_schemas.py">
from marshmallow import Schema, fields

class FuelTruckSchema(Schema):
    """Schema for serializing FuelTruck model instances."""
    id = fields.Int(dump_only=True)
    truck_number = fields.Str(required=True)
    fuel_type = fields.Str(required=True)
    capacity = fields.Decimal(required=True, places=2)
    current_meter_reading = fields.Decimal(required=True, places=2)
    is_active = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

class FuelTruckCreateRequestSchema(Schema):
    """Schema for validating fuel truck creation requests."""
    truck_number = fields.Str(required=True)
    fuel_type = fields.Str(required=True)
    capacity = fields.Decimal(required=True, places=2)
    current_meter_reading = fields.Decimal(required=False, places=2, load_default=0)

class FuelTruckUpdateRequestSchema(Schema):
    """Schema for validating fuel truck update requests (PATCH). All fields optional."""
    truck_number = fields.Str(required=False)
    fuel_type = fields.Str(required=False)
    capacity = fields.Decimal(required=False, places=2)
    current_meter_reading = fields.Decimal(required=False, places=2)
    is_active = fields.Bool(required=False)

class FuelTruckCreateResponseSchema(Schema):
    """Schema for the fuel truck creation response."""
    message = fields.Str(dump_only=True)
    fuel_truck = fields.Nested(FuelTruckSchema, dump_only=True)

class FuelTruckListResponseSchema(Schema):
    """Schema for the fuel trucks list endpoint response."""
    message = fields.Str(dump_only=True)
    fuel_trucks = fields.List(fields.Nested(FuelTruckSchema), dump_only=True)
</file>

<file path="src/schemas/permission_schemas.py">
from marshmallow import Schema, fields

class PermissionSchema(Schema):
    """Schema for permission responses."""
    id = fields.Integer(dump_only=True)
    name = fields.String(dump_only=True)
    description = fields.String(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="src/schemas/role_schemas.py">
from marshmallow import Schema, fields

class RoleSchema(Schema):
    """Schema for role responses."""
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True)
    description = fields.String(required=False, allow_none=True)
    created_at = fields.DateTime(dump_only=True)

class RoleCreateRequestSchema(Schema):
    """Schema for role creation requests."""
    name = fields.String(required=True)
    description = fields.String(required=False, allow_none=True)

class RoleUpdateRequestSchema(Schema):
    """Schema for role update requests."""
    name = fields.String(required=False)
    description = fields.String(required=False, allow_none=True)

class RoleListResponseSchema(Schema):
    """Schema for role list responses."""
    message = fields.String(required=True)
    roles = fields.Nested(RoleSchema, many=True, required=True)

class RoleAssignPermissionRequestSchema(Schema):
    """Schema for assigning a permission to a role."""
    permission_id = fields.Integer(required=True)
</file>

<file path="src/schemas/user_schemas.py">
from marshmallow import Schema, fields, validate

class RoleBriefSchema(Schema):
    """Brief schema for role information in user responses."""
    id = fields.Integer()
    name = fields.String()

class UserCreateRequestSchema(Schema):
    """Schema for user creation requests."""
    email = fields.Email(required=True)
    password = fields.String(required=True, load_only=True, validate=validate.Length(min=8))
    role_ids = fields.List(fields.Integer(), required=True)
    name = fields.String(required=False)
    is_active = fields.Boolean(required=False)

class UserUpdateRequestSchema(Schema):
    """Schema for user update requests."""
    name = fields.String(required=False)
    role_ids = fields.List(fields.Integer(), required=False)
    is_active = fields.Boolean(required=False)
    password = fields.String(required=False, load_only=True, validate=validate.Length(min=8))

class UserBriefSchema(Schema):
    """Brief schema for user information in list responses."""
    id = fields.Integer()
    name = fields.String(attribute="username")
    email = fields.Email()
    roles = fields.List(fields.Nested(RoleBriefSchema))
    is_active = fields.Boolean()
    created_at = fields.DateTime()

class UserDetailSchema(Schema):
    """Detailed schema for single user responses."""
    id = fields.Integer()
    name = fields.String(attribute="username")
    email = fields.Email()
    roles = fields.List(fields.Nested(RoleBriefSchema))
    is_active = fields.Boolean()
    created_at = fields.DateTime()
    updated_at = fields.DateTime()

class UserListResponseSchema(Schema):
    """Schema for list of users response."""
    message = fields.String()
    users = fields.List(fields.Nested(UserBriefSchema))

class ErrorResponseSchema(Schema):
    """Schema for error responses."""
    error = fields.String()
    details = fields.Raw(required=False)
</file>

<file path="src/services/__init__.py">
from .auth_service import AuthService
from .aircraft_service import AircraftService
from .customer_service import CustomerService
from .fuel_order_service import FuelOrderService
from .user_service import UserService
from .fuel_truck_service import FuelTruckService
from .role_service import RoleService
from .permission_service import PermissionService

__all__ = ['AuthService', 'AircraftService', 'CustomerService', 'FuelOrderService', 'UserService', 'FuelTruckService', 'RoleService', 'PermissionService']
</file>

<file path="src/services/aircraft_service.py">
from typing import Tuple, List, Optional, Dict, Any
from ..models.aircraft import Aircraft
from ..app import db

class AircraftService:
    @staticmethod
    def create_aircraft(data: Dict[str, Any]) -> Tuple[Optional[Aircraft], str, int]:
        if 'tail_number' not in data:
            return None, "Missing required field: tail_number", 400
        if Aircraft.query.filter_by(tail_number=data['tail_number']).first():
            return None, "Aircraft with this tail number already exists", 409
        try:
            aircraft = Aircraft(
                tail_number=data['tail_number'],
                aircraft_type=data.get('aircraft_type'),
                customer_id=data.get('customer_id')
            )
            db.session.add(aircraft)
            db.session.commit()
            return aircraft, "Aircraft created successfully", 201
        except Exception as e:
            db.session.rollback()
            return None, f"Error creating aircraft: {str(e)}", 500

    @staticmethod
    def get_aircraft_by_tail(tail_number: str) -> Tuple[Optional[Aircraft], str, int]:
        try:
            aircraft = Aircraft.query.get(tail_number)
            if not aircraft:
                return None, f"Aircraft with tail number {tail_number} not found", 404
            return aircraft, "Aircraft retrieved successfully", 200
        except Exception as e:
            return None, f"Error retrieving aircraft: {str(e)}", 500

    @staticmethod
    def get_all_aircraft(filters: Optional[Dict[str, Any]] = None) -> Tuple[List[Aircraft], str, int]:
        query = Aircraft.query
        if filters and 'customer_id' in filters:
            query = query.filter_by(customer_id=filters['customer_id'])
        try:
            aircraft_list = query.order_by(Aircraft.tail_number.asc()).all()
            return aircraft_list, "Aircraft list retrieved successfully", 200
        except Exception as e:
            return [], f"Error retrieving aircraft: {str(e)}", 500

    @staticmethod
    def update_aircraft(tail_number: str, update_data: Dict[str, Any]) -> Tuple[Optional[Aircraft], str, int]:
        try:
            aircraft = Aircraft.query.get(tail_number)
            if not aircraft:
                return None, f"Aircraft with tail number {tail_number} not found", 404
            if 'aircraft_type' in update_data:
                aircraft.aircraft_type = update_data['aircraft_type']
            if 'customer_id' in update_data:
                aircraft.customer_id = update_data['customer_id']
            db.session.commit()
            return aircraft, "Aircraft updated successfully", 200
        except Exception as e:
            db.session.rollback()
            return None, f"Error updating aircraft: {str(e)}", 500

    @staticmethod
    def delete_aircraft(tail_number: str) -> Tuple[bool, str, int]:
        try:
            aircraft = Aircraft.query.get(tail_number)
            if not aircraft:
                return False, f"Aircraft with tail number {tail_number} not found", 404
            db.session.delete(aircraft)
            db.session.commit()
            return True, "Aircraft deleted successfully", 200
        except Exception as e:
            db.session.rollback()
            return False, f"Error deleting aircraft: {str(e)}", 500
</file>

<file path="src/services/auth_service.py">
from typing import Union, Tuple
from ..models.user import User, UserRole
from ..extensions import db
from datetime import datetime, timedelta
import jwt
from flask import current_app

class AuthService:
    @classmethod
    def register_user(cls, email: str, password: str) -> User:
        """
        Register a new user if the email is not already taken.
        
        Args:
            email (str): The user's email address
            password (str): The user's password (will be hashed before storage)
            
        Returns:
            User: The newly created user object
            
        Raises:
            ValueError: If email already exists
        """
        print(f"Registering user with email: {email}")
        
        # Check if user already exists with this email
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            print(f"User with email {email} already exists")
            raise ValueError("Email already registered")
            
        # Generate username from email (part before @)
        username = email.split('@')[0]
        print(f"Generated username: {username}")
        
        # If username exists, append a number
        base_username = username
        counter = 1
        while User.query.filter_by(username=username).first():
            username = f"{base_username}{counter}"
            counter += 1
            print(f"Username {base_username} exists, trying {username}")
            
        try:
            # Create new user instance with default role LST
            new_user = User(
                username=username,
                email=email,
                role=UserRole.LST,
                is_active=True
            )
            print(f"Created user object: {new_user}")
            
            # Set password (will be automatically hashed by the User model)
            new_user.set_password(password)
            print("Set password hash")
            
            # Add user to database and commit transaction
            db.session.add(new_user)
            print("Added user to session")
            db.session.commit()
            print("Committed transaction")
            return new_user
        except Exception as e:
            db.session.rollback()
            print(f"Error registering user: {str(e)}")
            # In a production environment, you would want to log the error here
            raise Exception(f"Database error: {str(e)}")

    @classmethod
    def authenticate_user(cls, email: str, password: str) -> str:
        """
        Authenticate a user with their email and password.
        
        Args:
            email (str): The user's email
            password (str): The user's password
            
        Returns:
            str: JWT token string if authentication successful
            
        Raises:
            ValueError: If credentials are invalid or account is inactive
            Exception: If there's a server error
        """
        # Find user by email
        user = User.query.filter_by(email=email).first()
        print(f"Authenticating user with email: {email}")
        print(f"Found user: {user}")
        
        # Check if user exists and password is correct
        if not user:
            print("User not found")
            raise ValueError("Invalid email or password")
            
        if not user.check_password(password):
            print("Password check failed")
            raise ValueError("Invalid email or password")
            
        # Check if user account is active
        if not user.is_active:
            print("User account is inactive")
            raise ValueError("User account is inactive")
            
        # Return user object for token creation in route
        return user
</file>

<file path="src/services/customer_service.py">
from typing import Tuple, List, Optional, Dict, Any
from ..models.customer import Customer
from ..app import db

class CustomerService:
    @staticmethod
    def create_customer(data: Dict[str, Any]) -> Tuple[Optional[Customer], str, int]:
        if 'name' not in data:
            return None, "Missing required field: name", 400
        if Customer.query.filter_by(name=data['name']).first():
            return None, "Customer with this name already exists", 409
        try:
            customer = Customer(
                name=data['name']
            )
            db.session.add(customer)
            db.session.commit()
            return customer, "Customer created successfully", 201
        except Exception as e:
            db.session.rollback()
            return None, f"Error creating customer: {str(e)}", 500

    @staticmethod
    def get_customer_by_id(customer_id: int) -> Tuple[Optional[Customer], str, int]:
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None, f"Customer with ID {customer_id} not found", 404
            return customer, "Customer retrieved successfully", 200
        except Exception as e:
            return None, f"Error retrieving customer: {str(e)}", 500

    @staticmethod
    def get_all_customers(filters: Optional[Dict[str, Any]] = None) -> Tuple[List[Customer], str, int]:
        query = Customer.query
        try:
            customers = query.order_by(Customer.name.asc()).all()
            return customers, "Customer list retrieved successfully", 200
        except Exception as e:
            return [], f"Error retrieving customers: {str(e)}", 500

    @staticmethod
    def update_customer(customer_id: int, update_data: Dict[str, Any]) -> Tuple[Optional[Customer], str, int]:
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None, f"Customer with ID {customer_id} not found", 404
            if 'name' in update_data:
                # Check for uniqueness
                existing = Customer.query.filter_by(name=update_data['name']).first()
                if existing and existing.id != customer_id:
                    return None, f"Customer name {update_data['name']} already exists", 400
                customer.name = update_data['name']
            db.session.commit()
            return customer, "Customer updated successfully", 200
        except Exception as e:
            db.session.rollback()
            return None, f"Error updating customer: {str(e)}", 500

    @staticmethod
    def delete_customer(customer_id: int) -> Tuple[bool, str, int]:
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return False, f"Customer with ID {customer_id} not found", 404
            db.session.delete(customer)
            db.session.commit()
            return True, "Customer deleted successfully", 200
        except Exception as e:
            db.session.rollback()
            return False, f"Error deleting customer: {str(e)}", 500
</file>

<file path="src/services/fuel_order_service.py">
from datetime import datetime
from decimal import Decimal
import csv
import io
from src.models import (
    FuelOrder,
    FuelOrderStatus,
    Aircraft,
    User,
    UserRole,
    FuelTruck,
    Customer
)
from src.extensions import db
from flask import current_app
from typing import Optional, Tuple, List, Dict, Any, Union

class FuelOrderService:
    @classmethod
    def get_order_status_counts(cls, current_user):
        """
        Calculate and return counts of fuel orders by status groups for dashboard cards.
        CSR, ADMIN, and LST roles are allowed (global counts).
        Returns: (dict, message, status_code)
        """
        from src.models import FuelOrderStatus, UserRole, FuelOrder
        from sqlalchemy import func, case
        from src.extensions import db
        if current_user.role not in [UserRole.CSR, UserRole.ADMIN, UserRole.LST]:
            return None, "Forbidden: Insufficient permissions for status counts.", 403
        try:
            pending_statuses = [FuelOrderStatus.DISPATCHED]
            in_progress_statuses = [FuelOrderStatus.ACKNOWLEDGED, FuelOrderStatus.EN_ROUTE, FuelOrderStatus.FUELING]
            completed_statuses = [FuelOrderStatus.COMPLETED]
            counts = db.session.query(
                func.count(case((FuelOrder.status.in_(pending_statuses), FuelOrder.id))).label('pending'),
                func.count(case((FuelOrder.status.in_(in_progress_statuses), FuelOrder.id))).label('in_progress'),
                func.count(case((FuelOrder.status.in_(completed_statuses), FuelOrder.id))).label('completed')
            ).one_or_none()
            result_counts = {
                'pending': counts[0] if counts else 0,
                'in_progress': counts[1] if counts else 0,
                'completed': counts[2] if counts else 0,
            }
            return result_counts, "Status counts retrieved successfully.", 200
        except Exception as e:
            db.session.rollback()
            from flask import current_app
            current_app.logger.error(f"Error retrieving fuel order status counts: {str(e)}")
            return None, f"Database error retrieving status counts: {str(e)}", 500

    @classmethod
    def get_status_counts(cls, current_user):
        """
        Calculate and return counts of fuel orders by status groups for dashboard cards.
        CSR, ADMIN, and LST roles are allowed (global counts).
        Returns: (dict, message, status_code)
        """
        return cls.get_order_status_counts(current_user)

    @classmethod
    def create_fuel_order(cls, order_data: dict) -> Tuple[Union[FuelOrder, None], Union[str, None]]:
        from src.models import User, UserRole, FuelOrder, FuelOrderStatus
        from src.extensions import db
        import logging
        logger = logging.getLogger(__name__)

        # --- NEW: Check if any users exist ---
        user_count = User.query.count()
        if user_count == 0:
            return (
                None,
                "No users exist in the system. Please create an ADMIN user via the CLI or database to access the admin panel and create LST users.",
                400
            )

        """
        Create a new fuel order after validating all required entities exist and are valid.

        - If assigned_lst_user_id == -1, auto-assign the least busy active LST.
        - Otherwise, validate the provided LST ID.
        - Truck assignment logic is unchanged.

        Args:
            order_data (dict): Dictionary containing the validated order data from the route handler
                Required keys:
                - tail_number (str): Aircraft tail number
                - fuel_type (str): Type of fuel to be dispensed
                - assigned_lst_user_id (int): ID of the LST user assigned to the order (or -1 for auto-assign)
                - assigned_truck_id (int): ID of the fuel truck assigned to the order
                Optional keys:
                - customer_id (int): ID of the customer if applicable
                - additive_requested (bool): Whether fuel additive was requested
                - requested_amount (float): Amount of fuel requested
                - location_on_ramp (str): Location of the aircraft on the ramp
                - csr_notes (str): Notes from the CSR
        Returns:
            tuple[FuelOrder | None, str | None]: Returns either:
                - (FuelOrder, None) on success
                - (None, error_message) on failure
        """
        from src.models import User, UserRole, FuelOrder, FuelOrderStatus
        from src.extensions import db
        import logging
        logger = logging.getLogger(__name__)
        tail_number = order_data.get('tail_number')
        fuel_type = order_data.get('fuel_type')
        assigned_lst_user_id = order_data.get('assigned_lst_user_id')
        assigned_truck_id = order_data.get('assigned_truck_id')
        customer_id = order_data.get('customer_id')

        # Check for required fields
        if not all([tail_number, fuel_type, assigned_lst_user_id is not None, assigned_truck_id is not None]):
            return None, "Missing required fields."

        # --- LST Assignment Logic ---
        if assigned_lst_user_id == -1:
            # Auto-assign the least busy active LST
            active_lsts = User.query.filter(User.role == UserRole.LST, User.is_active == True).all()
            logger.debug(f"[DEBUG] Found {len(active_lsts)} active LST users: {[{'id': u.id, 'username': u.username, 'role': u.role, 'is_active': u.is_active} for u in active_lsts]}")
            if not active_lsts:
                all_lsts = User.query.filter(User.role == UserRole.LST).all()
                logger.debug(f"[DEBUG] All LST users (regardless of active): {[{'id': u.id, 'username': u.username, 'role': u.role, 'is_active': u.is_active} for u in all_lsts]}")
                logger.debug(f"[DEBUG] All users: {[{'id': u.id, 'username': u.username, 'role': u.role, 'is_active': u.is_active} for u in User.query.all()]}")
                return None, "No available LST found for auto-assignment.", 400
            min_count = None
            chosen_lst = None
            active_statuses = [
                FuelOrderStatus.DISPATCHED,
                FuelOrderStatus.ACKNOWLEDGED,
                FuelOrderStatus.EN_ROUTE,
                FuelOrderStatus.FUELING
            ]
            for lst in active_lsts:
                count = FuelOrder.query.filter(
                    FuelOrder.assigned_lst_user_id == lst.id,
                    FuelOrder.status.in_(active_statuses)
                ).count()
                if min_count is None or count < min_count:
                    min_count = count
                    chosen_lst = lst
            if not chosen_lst:
                return None, "No available LST found for auto-assignment.", 400
            logger.info(f"Auto-assigned LST user: {chosen_lst.id} (Active orders: {min_count})")
            assigned_lst_user_id = chosen_lst.id
            order_data['assigned_lst_user_id'] = assigned_lst_user_id
        else:
            # Manual assignment: validate LST exists, is LST, and active
            lst_user = User.query.filter_by(id=assigned_lst_user_id, role=UserRole.LST, is_active=True).first()
            if not lst_user:
                return None, f"Assigned LST user {assigned_lst_user_id} does not exist, is not active, or is not an LST.", 400

        # Truck assignment logic (unchanged)
        # ... (existing validation for truck)

        # Create the FuelOrder (existing logic)
        try:
            new_order = FuelOrder(
                tail_number=tail_number,
                fuel_type=fuel_type,
                assigned_lst_user_id=assigned_lst_user_id,
                assigned_truck_id=assigned_truck_id,
                customer_id=customer_id,
                additive_requested=order_data.get('additive_requested', False),
                requested_amount=order_data.get('requested_amount'),
                location_on_ramp=order_data.get('location_on_ramp'),
                csr_notes=order_data.get('csr_notes'),
                status=FuelOrderStatus.DISPATCHED
            )
            db.session.add(new_order)
            db.session.commit()
            return new_order, None
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error creating fuel order: {str(e)}")
            return None, f"Database error creating fuel order: {str(e)}"
            return None, "Missing required fields: tail_number, fuel_type, assigned_lst_user_id, and assigned_truck_id are required"

        # Check if aircraft exists
        aircraft = Aircraft.query.get(tail_number)
        if not aircraft:
            return None, f"Aircraft with tail number {tail_number} not found"

        # Check if LST user exists and is valid
        lst_user = User.query.get(assigned_lst_user_id)
        if not lst_user:
            return None, f"User with ID {assigned_lst_user_id} not found"
        if lst_user.role != UserRole.LST:
            return None, f"User {assigned_lst_user_id} is not an LST"
        if not lst_user.is_active:
            return None, f"LST user {assigned_lst_user_id} is not active"

        # Check if fuel truck exists and is active
        truck = FuelTruck.query.get(assigned_truck_id)
        if not truck:
            return None, f"Fuel truck with ID {assigned_truck_id} not found"
        if not truck.is_active:
            return None, f"Fuel truck {assigned_truck_id} is not active"

        # Check customer if provided
        if customer_id:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None, f"Customer with ID {customer_id} not found"

        # Create new FuelOrder instance
        try:
            new_order = FuelOrder(
                tail_number=tail_number,
                fuel_type=fuel_type,
                assigned_lst_user_id=assigned_lst_user_id,
                assigned_truck_id=assigned_truck_id,
                customer_id=customer_id,  # This is optional, will be None if not provided
                additive_requested=order_data.get('additive_requested', False),
                requested_amount=order_data.get('requested_amount'),
                location_on_ramp=order_data.get('location_on_ramp'),
                csr_notes=order_data.get('csr_notes'),
                # Set initial status and timestamps
                status=FuelOrderStatus.DISPATCHED,
                dispatch_timestamp=datetime.utcnow()
                # created_at will be set automatically by model default
            )

            # Add and commit to database
            db.session.add(new_order)
            db.session.commit()
            
            return new_order, None  # Return the created order with no error message
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating fuel order: {str(e)}")
            return None, f"Database error while creating fuel order: {str(e)}"

    @classmethod
    def get_fuel_orders(
        cls,
        current_user: User,
        filters: Optional[Dict[str, Any]] = None
    ) -> Tuple[Optional[Any], str]:
        """
        Retrieve paginated fuel orders based on user role and optional filters.
        
        Args:
            current_user (User): The authenticated user making the request
            filters (Optional[Dict[str, Any]]): Optional dictionary containing filter parameters
                - status (str): Filter by order status
                - page (int): Page number (default: 1)
                - per_page (int): Items per page (default: 20, max: 100)
                - Other filters can be added as needed
        
        Returns:
            Tuple[Optional[Any], str]: A tuple containing:
                - Pagination object if successful (contains items, page metadata), None if error
                - Success/error message
        """
        # Initialize base query
        query = FuelOrder.query

        # Apply role-based filtering
        if current_user.role == UserRole.LST:
            # LSTs can only see orders assigned to them
            query = query.filter(FuelOrder.assigned_lst_user_id == current_user.id)
        elif current_user.role in [UserRole.CSR, UserRole.ADMIN]:
            # CSRs and Admins can see all orders
            pass
        else:
            current_app.logger.error(f"Unexpected user role encountered: {current_user.role}")
            return None, "Forbidden: User role cannot access orders"
        
        # Apply filtering based on request parameters
        if filters:
            # Filter by status
            status_filter = filters.get('status')
            if status_filter:
                try:
                    # Convert string status from filter to FuelOrderStatus enum member
                    status_enum = FuelOrderStatus[status_filter.upper()]
                    query = query.filter(FuelOrder.status == status_enum)
                except KeyError:
                    # Invalid status string provided in filter
                    return None, f"Invalid status value provided: {status_filter}"

            # TODO: Add other filters here (e.g., date range, tail_number)

        # Extract and validate pagination parameters
        try:
            page = int(filters.get('page', 1))
            per_page = int(filters.get('per_page', 20))
            
            # Validate pagination parameters
            if page < 1:
                page = 1
            if per_page < 1:
                per_page = 20
            if per_page > 100:  # Maximum limit to prevent abuse
                per_page = 100
                
        except (ValueError, TypeError):
            # Handle invalid pagination parameters
            page = 1
            per_page = 20

        try:
            # Apply default sorting and pagination
            paginated_orders = query.order_by(FuelOrder.created_at.desc()).paginate(
                page=page,
                per_page=per_page,
                error_out=False
            )
            return paginated_orders, "Orders retrieved successfully"
            
        except Exception as e:
            current_app.logger.error(f"Error retrieving fuel orders: {str(e)}")
            return None, f"Database error while retrieving orders: {str(e)}"

    @classmethod
    def get_fuel_order_by_id(
        cls,
        order_id: int,
        current_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Retrieve a specific fuel order by ID after performing authorization checks.
        
        Args:
            order_id (int): The ID of the order to retrieve
            current_user (User): The authenticated user making the request
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 403, 404)
        """
        # Basic fetch for now. Add joinedload/selectinload options later for optimization if needed.
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Perform Authorization Check
        if current_user.role == UserRole.LST:
            # LST can only view orders assigned to them
            if order.assigned_lst_user_id != current_user.id:
                return None, "Forbidden: You are not assigned to this fuel order.", 403  # Forbidden
        elif current_user.role in [UserRole.CSR, UserRole.ADMIN]:
            # CSRs and Admins can view any order
            pass  # No additional check needed for these roles
        else:
            # Should not happen due to auth middleware, but let's be thorough
            return None, "Forbidden: Invalid user role.", 403

        # Return the order object
        return order, "Fuel order retrieved successfully.", 200  # OK

    @classmethod
    def update_order_status(
        cls,
        order_id: int,
        new_status: FuelOrderStatus,
        current_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Update the status of a fuel order after performing authorization checks.
        
        Args:
            order_id (int): The ID of the order to update
            new_status (FuelOrderStatus): The target status to update to
            current_user (User): The authenticated user performing the action
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The updated FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 403, 404)
        """
        # Fetch the fuel order by ID
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Check if the user is the assigned LST for this order
        if current_user.role == UserRole.LST:
            if order.assigned_lst_user_id != current_user.id:
                return None, "Forbidden: You are not assigned to this fuel order.", 403  # Forbidden
        elif current_user.role in [UserRole.CSR, UserRole.ADMIN]:
            # Restrict status changes strictly to LSTs for MVP workflow
            return None, "Forbidden: Only the assigned LST can update the status via this method.", 403
        else:
            # Should not happen due to auth middleware, but let's be thorough
            return None, "Forbidden: Invalid user role.", 403

        # Define allowed transitions for LST updates via this endpoint
        allowed_transitions = {
            FuelOrderStatus.DISPATCHED: [FuelOrderStatus.ACKNOWLEDGED],
            FuelOrderStatus.ACKNOWLEDGED: [FuelOrderStatus.EN_ROUTE],
            FuelOrderStatus.EN_ROUTE: [FuelOrderStatus.FUELING]
            # Note: Fueling -> Completed will be handled by a separate 'complete_order' endpoint
            # Note: Cancellation will be handled by a separate endpoint with different permissions
        }

        # Validate the requested transition
        if order.status not in allowed_transitions or new_status not in allowed_transitions[order.status]:
            return None, f"Invalid status transition from {order.status.value} to {new_status.value}.", 400  # Bad Request

        try:
            # Update the order status
            order.status = new_status

            # Update corresponding timestamp field based on the new status
            if new_status == FuelOrderStatus.ACKNOWLEDGED:
                order.acknowledge_timestamp = datetime.utcnow()
            elif new_status == FuelOrderStatus.EN_ROUTE:
                order.en_route_timestamp = datetime.utcnow()
            elif new_status == FuelOrderStatus.FUELING:
                order.fueling_start_timestamp = datetime.utcnow()

            # Commit the changes
            db.session.commit()

            return order, f"Order status successfully updated to {new_status.value}.", 200  # OK

        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating fuel order status: {str(e)}")
            return None, f"Database error while updating order status: {str(e)}", 500  # Internal Server Error

    @classmethod
    def complete_fuel_order(
        cls,
        order_id: int,
        completion_data: Dict[str, Any],
        current_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Complete a fuel order by updating its status and recording completion details.
        
        Args:
            order_id (int): The ID of the order to complete
            completion_data (Dict[str, Any]): Dictionary containing completion details
                Required keys:
                - start_meter_reading (str/Decimal): Starting meter reading
                - end_meter_reading (str/Decimal): Ending meter reading
                Optional keys:
                - lst_notes (str): Additional notes from the LST
            current_user (User): The authenticated user performing the action
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The updated FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 400, 403, 404)
        """
        # Fetch the fuel order by ID
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Perform Authorization Check: Ensure the user is the assigned LST
        if not (current_user.role == UserRole.LST and order.assigned_lst_user_id == current_user.id):
            # Also allow Admin/CSR maybe? For MVP, let's stick to LST.
            return None, "Forbidden: Only the assigned LST can complete this fuel order.", 403  # Forbidden

        # Perform Status Check: Ensure the order is in a state ready for completion
        if order.status != FuelOrderStatus.FUELING:
            # We could allow completion from other states like EN_ROUTE, ACKNOWLEDGED
            # but requiring FUELING enforces the workflow more strictly.
            return None, f"Order cannot be completed from its current status ({order.status.value}). Must be 'Fueling'.", 400  # Bad Request

        # Extract and validate meter readings
        try:
            start_meter = Decimal(completion_data['start_meter_reading'])
            end_meter = Decimal(completion_data['end_meter_reading'])
            if end_meter < start_meter:
                return None, "End meter reading cannot be less than start meter reading.", 400  # Bad Request
            # Add checks for negative values if necessary
            if start_meter < 0 or end_meter < 0:
                return None, "Meter readings cannot be negative.", 400
        except (KeyError, ValueError, TypeError):
            return None, "Invalid or missing meter reading values.", 400

        lst_notes = completion_data.get('lst_notes')  # Optional notes

        # Calculate gallons dispensed
        gallons_dispensed = end_meter - start_meter

        # Update order fields
        order.start_meter_reading = start_meter
        order.end_meter_reading = end_meter
        order.calculated_gallons_dispensed = gallons_dispensed
        order.lst_notes = lst_notes  # Update notes (will be None if not provided)
        order.status = FuelOrderStatus.COMPLETED  # Set status to Completed
        order.completion_timestamp = datetime.utcnow()  # Record completion time

        try:
            db.session.commit()
            return order, "Fuel order completed successfully.", 200  # OK
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error completing fuel order: {str(e)}")
            return None, f"Database error while completing order: {str(e)}", 500  # Internal Server Error

    @classmethod
    def review_fuel_order(
        cls,
        order_id: int,
        reviewer_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Review a completed fuel order.
        
        Args:
            order_id (int): The ID of the order to review
            reviewer_user (User): The authenticated CSR or Admin user performing the review
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The updated FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 400, 404)
        """
        # Fetch the fuel order by ID
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Perform Status Check: Ensure the order is 'COMPLETED' before it can be reviewed
        if order.status != FuelOrderStatus.COMPLETED:
            return None, f"Order cannot be reviewed. Current status is '{order.status.value}', must be 'Completed'.", 400  # Bad Request

        # Update order fields with review information
        order.status = FuelOrderStatus.REVIEWED
        order.reviewed_by_csr_user_id = reviewer_user.id
        order.reviewed_timestamp = datetime.utcnow()

        try:
            db.session.commit()
            return order, "Fuel order marked as reviewed.", 200  # OK
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error reviewing fuel order: {str(e)}")
            return None, f"Database error while marking order as reviewed: {str(e)}", 500  # Internal Server Error

    @classmethod
    def export_fuel_orders_to_csv(
        cls,
        current_user: User,
        filters: Optional[Dict[str, Any]] = None
    ) -> Tuple[Optional[str], str, int]:
        """
        Fetch fuel orders for CSV export based on filters and format them into a CSV string.
        
        Args:
            current_user (User): The authenticated user requesting the export
            filters (Optional[Dict[str, Any]]): Optional dictionary containing filter parameters
                - status (str): Override default REVIEWED status filter
                - date_from (str): Filter orders from this date (TODO)
                - date_to (str): Filter orders until this date (TODO)
                
        Returns:
            Tuple[Optional[str], str, int]: A tuple containing:
                - CSV data string if successful, None if failed
                - A success/error message
                - HTTP status code (200, 400, 500)
        """
        # Authorization check: Only CSR and Admin can export
        if current_user.role not in [UserRole.CSR, UserRole.ADMIN]:
            return None, "Forbidden: Only CSR and Admin users can export fuel orders.", 403

        # Initialize base query
        query = FuelOrder.query

        # Apply default status filter (REVIEWED) or override from filters
        target_status = FuelOrderStatus.REVIEWED  # Default export status
        if filters and filters.get('status'):
            try:
                # Allow overriding default status via filter
                target_status = FuelOrderStatus[filters['status'].upper()]
            except KeyError:
                return None, f"Invalid status value provided for export: {filters['status']}", 400

        query = query.filter(FuelOrder.status == target_status)

        try:
            # Fetch all orders matching the criteria, ordered by review timestamp
            orders_to_export = query.order_by(FuelOrder.reviewed_timestamp.desc()).all()

            if not orders_to_export:
                return [], "No orders found matching the criteria for export.", 200

            # Create in-memory text stream for CSV writing
            output = io.StringIO()
            writer = csv.writer(output)

            # Define and write the header row
            header = [
                'Order ID', 'Status', 'Tail Number', 'Customer ID',
                'Fuel Type', 'Additive Requested', 'Requested Amount',
                'Assigned LST ID', 'Assigned Truck ID',
                'Location on Ramp', 'CSR Notes',
                'Start Meter', 'End Meter', 'Gallons Dispensed', 'LST Notes',
                'Created At (UTC)', 'Dispatch Timestamp (UTC)', 'Acknowledge Timestamp (UTC)',
                'En Route Timestamp (UTC)', 'Fueling Start Timestamp (UTC)',
                'Completion Timestamp (UTC)', 'Reviewed Timestamp (UTC)', 'Reviewed By CSR ID'
            ]
            writer.writerow(header)

            # Helper function to format values safely
            def format_value(value):
                if value is None:
                    return ''
                if isinstance(value, datetime):
                    return value.strftime('%Y-%m-%d %H:%M:%S')  # Consistent UTC format
                if isinstance(value, Decimal):
                    return str(value)  # Convert Decimal to string
                if isinstance(value, bool):
                    return 'Yes' if value else 'No'
                if isinstance(value, FuelOrderStatus):
                    return value.value  # Get enum string value
                return str(value)

            # Write each order as a row in the CSV
            for order in orders_to_export:
                row = [
                    order.id,
                    format_value(order.status),
                    order.tail_number,
                    format_value(order.customer_id),
                    order.fuel_type,
                    format_value(order.additive_requested),
                    format_value(order.requested_amount),
                    format_value(order.assigned_lst_user_id),
                    format_value(order.assigned_truck_id),
                    order.location_on_ramp or '',  # Use empty string for None strings
                    order.csr_notes or '',
                    format_value(order.start_meter_reading),
                    format_value(order.end_meter_reading),
                    format_value(order.calculated_gallons_dispensed),
                    order.lst_notes or '',
                    format_value(order.created_at),
                    format_value(order.dispatch_timestamp),
                    format_value(order.acknowledge_timestamp),
                    format_value(order.en_route_timestamp),
                    format_value(order.fueling_start_timestamp),
                    format_value(order.completion_timestamp),
                    format_value(order.reviewed_timestamp),
                    format_value(order.reviewed_by_csr_user_id)
                ]
                writer.writerow(row)

            # Get the CSV string and close the stream
            csv_data = output.getvalue()
            output.close()

            return csv_data, "CSV data generated successfully.", 200

        except Exception as e:
            current_app.logger.error(f"Error generating CSV export: {str(e)}")
            return None, f"Error generating CSV export: {str(e)}", 500
</file>

<file path="src/services/fuel_truck_service.py">
from typing import Tuple, List, Optional, Dict, Any

from ..models.fuel_truck import FuelTruck
from ..app import db

class FuelTruckService:
    """Service class for managing fuel truck operations."""

    @classmethod
    def get_trucks(cls, filters: Optional[Dict[str, Any]] = None) -> Tuple[Optional[List[FuelTruck]], str, int]:
        # ... (existing code unchanged)
        query = FuelTruck.query
        if filters:
            is_active_filter = filters.get('is_active')
            if is_active_filter is not None:
                is_active_bool = is_active_filter.lower() == 'true'
                query = query.filter(FuelTruck.is_active == is_active_bool)
        try:
            trucks = query.order_by(FuelTruck.truck_number.asc()).all()
            return trucks, "Fuel trucks retrieved successfully", 200
        except Exception as e:
            return None, f"Database error while retrieving fuel trucks: {str(e)}", 500

    @classmethod
    def create_truck(cls, truck_data: Dict[str, Any]) -> Tuple[Optional[FuelTruck], str, int]:
        # ... (existing code unchanged)
        existing_truck = FuelTruck.query.filter_by(truck_number=truck_data['truck_number']).first()
        if existing_truck:
            return None, f"Truck number {truck_data['truck_number']} already exists", 400
        try:
            new_truck = FuelTruck(
                truck_number=truck_data['truck_number'],
                fuel_type=truck_data['fuel_type'],
                capacity=truck_data['capacity'],
                current_meter_reading=truck_data.get('current_meter_reading', 0),
                is_active=True
            )
            db.session.add(new_truck)
            db.session.commit()
            return new_truck, "Fuel truck created successfully", 201
        except Exception as e:
            db.session.rollback()
            return None, f"Database error while creating fuel truck: {str(e)}", 500

    @classmethod
    def get_truck_by_id(cls, truck_id: int) -> Tuple[Optional[FuelTruck], str, int]:
        """Get a fuel truck by its ID."""
        try:
            truck = FuelTruck.query.get(truck_id)
            if not truck:
                return None, f"Fuel truck with ID {truck_id} not found", 404
            return truck, "Fuel truck retrieved successfully", 200
        except Exception as e:
            return None, f"Database error while retrieving fuel truck: {str(e)}", 500

    @classmethod
    def update_truck(cls, truck_id: int, update_data: Dict[str, Any]) -> Tuple[Optional[FuelTruck], str, int]:
        """Update a fuel truck."""
        try:
            truck = FuelTruck.query.get(truck_id)
            if not truck:
                return None, f"Fuel truck with ID {truck_id} not found", 404
            # Update fields if provided
            if 'truck_number' in update_data:
                # Check for uniqueness
                existing = FuelTruck.query.filter_by(truck_number=update_data['truck_number']).first()
                if existing and existing.id != truck_id:
                    return None, f"Truck number {update_data['truck_number']} already exists", 400
                truck.truck_number = update_data['truck_number']
            if 'fuel_type' in update_data:
                truck.fuel_type = update_data['fuel_type']
            if 'capacity' in update_data:
                truck.capacity = update_data['capacity']
            if 'current_meter_reading' in update_data:
                truck.current_meter_reading = update_data['current_meter_reading']
            if 'is_active' in update_data:
                truck.is_active = bool(update_data['is_active'])
            db.session.commit()
            return truck, "Fuel truck updated successfully", 200
        except Exception as e:
            db.session.rollback()
            return None, f"Database error while updating fuel truck: {str(e)}", 500

    @classmethod
    def delete_truck(cls, truck_id: int) -> Tuple[bool, str, int]:
        """Delete a fuel truck by ID."""
        try:
            truck = FuelTruck.query.get(truck_id)
            if not truck:
                return False, f"Fuel truck with ID {truck_id} not found", 404
            db.session.delete(truck)
            db.session.commit()
            return True, "Fuel truck deleted successfully", 200
        except Exception as e:
            db.session.rollback()
            return False, f"Database error while deleting fuel truck: {str(e)}", 500
</file>

<file path="src/services/permission_service.py">
from typing import Tuple, List, Optional
from src.app import db
from src.models import Permission
from sqlalchemy.exc import SQLAlchemyError

class PermissionService:
    """
    Stub service for permission-related operations (Phase 3).
    """

    @classmethod
    def get_all_permissions(cls) -> Tuple[Optional[List[Permission]], str, int]:
        """
        Retrieve all permissions from the database, ordered by name.

        Returns:
            Tuple containing:
            - List[Permission]: List of all Permission objects if successful, None if error
            - str: Success/error message
            - int: HTTP status code (200 for success, 500 for error)
        """
        try:
            permissions = Permission.query.order_by(Permission.name.asc()).all()
            return permissions, "Permissions retrieved successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            error_msg = f"Database error while retrieving permissions: {str(e)}"
            # Log the error here if you have a logger configured
            print(error_msg)  # Basic logging fallback
            return None, error_msg, 500
</file>

<file path="src/services/role_service.py">
from typing import Tuple, Any, List, Optional
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from src.app import db
from src.models import Role, Permission

class RoleService:
    """Service class for managing roles and their permissions."""

    @classmethod
    def get_all_roles(cls) -> Tuple[List[Role], str, int]:
        """Retrieve all roles ordered by name."""
        try:
            roles = Role.query.order_by(Role.name.asc()).all()
            return roles, "Roles retrieved successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return [], f"Database error: {str(e)}", 500

    @classmethod
    def create_role(cls, data: dict) -> Tuple[Optional[Role], str, int]:
        """Create a new role with the provided data."""
        if not data.get('name'):
            return None, "Role name is required", 400

        try:
            # Check for existing role with same name
            existing_role = Role.query.filter_by(name=data['name']).first()
            if existing_role:
                return None, f"Role with name '{data['name']}' already exists", 409

            new_role = Role(
                name=data['name'],
                description=data.get('description')
            )
            db.session.add(new_role)
            db.session.commit()
            return new_role, "Role created successfully", 201
        except IntegrityError:
            db.session.rollback()
            return None, "Role name must be unique", 409
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def get_role_by_id(cls, role_id: int) -> Tuple[Optional[Role], str, int]:
        """Retrieve a role by its ID."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404
            return role, "Role retrieved successfully", 200
        except SQLAlchemyError as e:
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def update_role(cls, role_id: int, data: dict) -> Tuple[Optional[Role], str, int]:
        """Update an existing role's information."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404

            if 'name' in data:
                # Check for duplicate name, excluding current role
                existing_role = Role.query.filter(
                    Role.name == data['name'],
                    Role.id != role_id
                ).first()
                if existing_role:
                    return None, f"Role with name '{data['name']}' already exists", 409
                role.name = data['name']

            if 'description' in data:
                role.description = data['description']

            db.session.commit()
            return role, "Role updated successfully", 200
        except IntegrityError:
            db.session.rollback()
            return None, "Role name must be unique", 409
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def delete_role(cls, role_id: int) -> Tuple[bool, str, int]:
        """Delete a role and its permission assignments."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return False, f"Role with ID {role_id} not found", 404

            # Check if any users are assigned this role
            if role.users.first():
                return False, "Cannot delete role: Users are currently assigned to this role", 409

            # Clear permission assignments
            role.permissions = []
            db.session.delete(role)
            db.session.commit()
            return True, "Role deleted successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return False, f"Database error: {str(e)}", 500

    @classmethod
    def get_role_permissions(cls, role_id: int) -> Tuple[List[Permission], str, int]:
        """Get all permissions assigned to a role."""
        try:
            role = Role.query.options(db.joinedload(Role.permissions)).get(role_id)
            if not role:
                return [], f"Role with ID {role_id} not found", 404
            
            permissions = list(role.permissions)
            return permissions, "Permissions retrieved successfully", 200
        except SQLAlchemyError as e:
            return [], f"Database error: {str(e)}", 500

    @classmethod
    def assign_permission_to_role(cls, role_id: int, permission_id: int) -> Tuple[Optional[Role], str, int]:
        """Assign a permission to a role."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404

            permission = Permission.query.get(permission_id)
            if not permission:
                return None, f"Permission with ID {permission_id} not found", 404

            # Check if permission is already assigned
            if permission in role.permissions:
                return role, "Permission already assigned to role", 200

            role.permissions.append(permission)
            db.session.commit()
            return role, "Permission assigned successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500

    @classmethod
    def remove_permission_from_role(cls, role_id: int, permission_id: int) -> Tuple[Optional[Role], str, int]:
        """Remove a permission from a role."""
        try:
            role = Role.query.get(role_id)
            if not role:
                return None, f"Role with ID {role_id} not found", 404

            permission = Permission.query.get(permission_id)
            if not permission:
                return None, f"Permission with ID {permission_id} not found", 404

            # Check if permission is actually assigned
            if permission not in role.permissions:
                return role, "Permission not assigned to role", 200

            role.permissions.remove(permission)
            db.session.commit()
            return role, "Permission removed successfully", 200
        except SQLAlchemyError as e:
            db.session.rollback()
            return None, f"Database error: {str(e)}", 500
</file>

<file path="src/services/user_service.py">
from typing import Tuple, List, Optional, Dict, Any, Set

from ..models.user import User
from ..models.role import Role
from ..extensions import db


class UserService:
    """Service class for managing user-related operations."""

    @classmethod
    def get_users(cls, filters: Optional[Dict[str, Any]] = None) -> Tuple[Optional[List[User]], str, int]:
        """Retrieve users based on specified filters.

        Args:
            filters (Optional[Dict[str, Any]]): Optional dictionary of filter parameters.
                Supported filters:
                - role_ids (List[int]): Filter by role IDs
                - is_active (bool): Filter by user active status

        Returns:
            Tuple[Optional[List[User]], str, int]: A tuple containing:
                - List of User objects if successful, None if error
                - Message describing the result
                - HTTP status code
        """
        try:
            # Initialize base query with eager loading of roles
            query = User.query.options(db.selectinload(User.roles))

            if filters:
                # Filter by role IDs
                role_ids = filters.get('role_ids')
                if role_ids:
                    if not isinstance(role_ids, list):
                        return None, "Invalid role_ids format, must be a list", 400
                    # Join with roles and filter where role.id is in the provided list
                    query = query.join(User.roles).filter(Role.id.in_(role_ids))

                # Filter by active status
                is_active_filter = filters.get('is_active')
                if is_active_filter is not None:
                    is_active_bool = str(is_active_filter).lower() == 'true'
                    query = query.filter(User.is_active == is_active_bool)

            # Default sort by username ascending
            users = query.order_by(User.username.asc()).all()
            return users, "Users retrieved successfully", 200

        except Exception as e:
            # Log the error here if you have a logger configured
            return None, f"Database error while retrieving users: {str(e)}", 500

    @classmethod
    def create_user(cls, data: Dict[str, Any]) -> Tuple[Optional[User], str, int]:
        """Create a new user.
        
        Args:
            data (Dict[str, Any]): Dictionary containing user data
                Required keys:
                - email (str): User's email address
                - password (str): User's password
                - role_ids (List[int]): List of role IDs to assign
                Optional keys:
                - name (str): User's name
                - is_active (bool): Whether user should be active (defaults to True)
                
        Returns:
            Tuple[Optional[User], str, int]: A tuple containing:
                - Created User object if successful, None if error
                - Message describing the result
                - HTTP status code
        """
        try:
            # Validate required fields
            if not all(key in data for key in ['email', 'password', 'role_ids']):
                return None, "Missing required fields: email, password, and role_ids are required", 400

            # Validate role_ids format
            role_ids = data['role_ids']
            if not isinstance(role_ids, list):
                return None, "Invalid role_ids format, must be a list", 400

            if not role_ids:  # Empty list check
                return None, "At least one role must be assigned", 400

            # Check if email already exists
            if User.query.filter_by(email=data['email']).first():
                return None, "Email already registered", 409

            # Fetch and validate roles
            roles = Role.query.filter(Role.id.in_(role_ids)).all()
            if len(roles) != len(set(role_ids)):
                found_ids = {role.id for role in roles}
                invalid_ids = set(role_ids) - found_ids
                return None, f"Invalid role IDs provided: {list(invalid_ids)}", 400

            # Create new user
            user = User(
                email=data['email'],
                username=data.get('name', data['email'].split('@')[0]),  # Default to email username
                is_active=data.get('is_active', True)  # Default to active
            )
            user.set_password(data['password'])
            user.roles = roles  # Assign roles

            db.session.add(user)
            db.session.commit()

            return user, "User created successfully", 201

        except Exception as e:
            db.session.rollback()
            return None, f"Error creating user: {str(e)}", 500

    @classmethod
    def update_user(cls, user_id: int, data: Dict[str, Any]) -> Tuple[Optional[User], str, int]:
        """Update an existing user.
        
        Args:
            user_id (int): ID of user to update
            data (Dict[str, Any]): Dictionary containing update data
                Supported keys:
                - name (str): User's name
                - role_ids (List[int]): List of role IDs to assign
                - is_active (bool): User's active status
                - password (str): User's new password (optional)
                
        Returns:
            Tuple[Optional[User], str, int]: A tuple containing:
                - Updated User object if successful, None if error
                - Message describing the result
                - HTTP status code
        """
        try:
            user = User.query.options(db.selectinload(User.roles)).get(user_id)
            if not user:
                return None, f"User with ID {user_id} not found", 404

            # Update fields if provided
            if 'name' in data:
                user.username = data['name']

            if 'role_ids' in data:
                role_ids = data['role_ids']
                if not isinstance(role_ids, list):
                    return None, "Invalid role_ids format, must be a list", 400

                if role_ids:  # If list is not empty
                    # Fetch and validate roles
                    roles = Role.query.filter(Role.id.in_(role_ids)).all()
                    if len(roles) != len(set(role_ids)):
                        found_ids = {role.id for role in roles}
                        invalid_ids = set(role_ids) - found_ids
                        return None, f"Invalid role IDs provided: {list(invalid_ids)}", 400
                    user.roles = roles
                else:
                    user.roles = []  # Clear all roles if empty list provided

            if 'is_active' in data:
                user.is_active = bool(data['is_active'])

            if 'password' in data:
                user.set_password(data['password'])

            db.session.commit()
            return user, "User updated successfully", 200

        except Exception as e:
            db.session.rollback()
            return None, f"Error updating user: {str(e)}", 500

    @classmethod
    def delete_user(cls, user_id: int) -> Tuple[bool, str, int]:
        """Soft delete a user by setting is_active to False.
        
        Args:
            user_id (int): ID of user to delete
            
        Returns:
            Tuple[bool, str, int]: A tuple containing:
                - True if successful, False if error
                - Message describing the result
                - HTTP status code
        """
        try:
            user = User.query.get(user_id)
            if not user:
                return False, f"User with ID {user_id} not found", 404

            user.is_active = False
            db.session.commit()
            return True, "User deactivated successfully", 200

        except Exception as e:
            db.session.rollback()
            return False, f"Error deactivating user: {str(e)}", 500

    @classmethod
    def get_user_by_id(cls, user_id: int) -> Tuple[Optional[User], str, int]:
        """Get a user by ID.
        
        Args:
            user_id (int): ID of user to retrieve
            
        Returns:
            Tuple[Optional[User], str, int]: A tuple containing:
                - User object if found, None if not found
                - Message describing the result
                - HTTP status code
        """
        try:
            user = User.query.options(db.selectinload(User.roles)).get(user_id)
            if not user:
                return None, f"User with ID {user_id} not found", 404
            return user, "User retrieved successfully", 200

        except Exception as e:
            return None, f"Error retrieving user: {str(e)}", 500
</file>

<file path="src/utils/__init__.py">
"""
Utility functions and decorators for the FBO LaunchPad backend.
"""
</file>

<file path="src/utils/auth.py">
from functools import wraps
from flask import jsonify, current_app
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity

def admin_required():
    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            verify_jwt_in_request()
            claims = get_jwt_identity()
            
            if claims.get('role') != 'admin':
                return jsonify({'error': 'Admin privileges required'}), 403
                
            return fn(*args, **kwargs)
        return decorator
    return wrapper

def user_required():
    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            verify_jwt_in_request()
            claims = get_jwt_identity()
            
            if not claims.get('role') in ['user', 'admin']:
                return jsonify({'error': 'User privileges required'}), 403
                
            return fn(*args, **kwargs)
        return decorator
    return wrapper
</file>

<file path="src/utils/decorators.py">
"""
Authentication decorators for protecting API routes.
"""
from functools import wraps
from flask import request, jsonify, current_app, g
import jwt
from ..models.user import User, UserRole


def token_required(f):
    """
    A decorator that protects routes by verifying the JWT token in the Authorization header.
    
    The token must be provided in the format: 'Bearer <token>'.
    On successful verification, the authenticated user is stored in g.current_user.
    
    Args:
        f: The route function to be decorated.
        
    Returns:
        decorated_function: The wrapped function that performs token verification.
        
    Raises:
        401 Unauthorized: If the token is missing, invalid, expired, or the user is not found/inactive.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = None
        auth_header = request.headers.get('Authorization')
        
        print(f"Auth header: {auth_header}")
        
        # Check if Authorization header exists and follows Bearer scheme
        if auth_header:
            try:
                # Extract token from "Bearer <token>"
                token_parts = auth_header.split()
                if len(token_parts) == 2 and token_parts[0].lower() == 'bearer':
                    token = token_parts[1]
                print(f"Token parts: {token_parts}")
            except Exception as e:
                print(f"Error parsing auth header: {e}")
                return jsonify({"error": "Invalid Authorization header format"}), 401
        
        if not token:
            return jsonify({"error": "Authentication token is missing!"}), 401
            
        try:
            # Decode and verify the token
            print(f"Decoding token: {token}")
            payload = jwt.decode(
                token,
                current_app.config['JWT_SECRET_KEY'],
                algorithms=[current_app.config.get('JWT_ALGORITHM', 'HS256')]
            )
            print(f"Token payload: {payload}")
            
            # Get user from database
            user_id = payload['sub']
            if not isinstance(user_id, str):
                user_id = str(user_id)
            current_user = User.query.get(int(user_id))
            print(f"Found user: {current_user}")
            
            # Verify user exists and is active
            if not current_user or not current_user.is_active:
                return jsonify({"error": "User not found or inactive"}), 401
                
            # Store user in request context
            g.current_user = current_user
            
        except jwt.ExpiredSignatureError:
            print("Token expired")
            return jsonify({"error": "Token has expired!"}), 401
        except jwt.InvalidTokenError as e:
            print(f"Invalid token: {e}")
            return jsonify({"error": "Invalid token!"}), 401
        except Exception as e:
            print(f"Token processing error: {e}")
            return jsonify({"error": "Token processing error"}), 401
            
        return f(*args, **kwargs)
        
    return decorated_function 

def require_permission(permission_name: str):
    """
    Decorator to ensure the logged-in user has the specified permission.
    Must be applied AFTER @token_required.
    """
    def _decorator(f):
        @wraps(f)
        def _wrapper(*args, **kwargs):
            # 1. Check if user context exists (from @token_required)
            if not hasattr(g, 'current_user') or not g.current_user:
                # Log this internal server error
                print(f"ERROR: g.current_user not found in @require_permission('{permission_name}'). Check decorator order.")
                return jsonify({"error": "Internal Server Error: Authentication context missing"}), 500

            # 2. Check if the user has the required permission
            if not g.current_user.has_permission(permission_name):
                return jsonify({"error": f"Forbidden: Requires permission '{permission_name}'"}), 403

            # 3. Permission granted, proceed to the route function
            return f(*args, **kwargs)
        return _wrapper
    return _decorator
</file>

<file path="src/utils/README.md">
# Authentication Decorators

This module provides authentication decorators for protecting API routes in the FBO LaunchPad backend.

## `@token_required` Decorator

The `@token_required` decorator provides JWT-based authentication for Flask routes. It verifies the presence and validity of a JWT token in the request's Authorization header and makes the authenticated user available to the route handler.

### Configuration

Before using the decorator, ensure your Flask application has the following configuration:

```python
app.config['SECRET_KEY'] = 'your-secure-secret-key'  # Use a strong secret key in production
```

### Usage

Import and apply the decorator to your route handlers:

```python
from src.utils.decorators import token_required

@app.route('/api/protected')
@token_required
def protected_route():
    # Access the authenticated user from Flask's g object
    current_user = g.current_user
    return jsonify({
        "message": f"Hello {current_user.name}!",
        "user_id": current_user.id
    })
```

### Authentication Flow

1. **Token Format**: The client must include the JWT token in the Authorization header using the Bearer scheme:
   ```
   Authorization: Bearer <your-jwt-token>
   ```

2. **Validation Process**:
   - Verifies the presence of the Authorization header
   - Validates the Bearer scheme format
   - Decodes and verifies the JWT signature
   - Checks token expiration
   - Retrieves and validates the user from the database
   - Makes the user object available via `g.current_user`

3. **Error Handling**: The decorator returns appropriate 401 Unauthorized responses for various failure cases:

   | Error Case | Response |
   |------------|----------|
   | Missing Authorization header | `{"error": "Authentication token is missing!"}` |
   | Invalid header format | `{"error": "Invalid Authorization header format"}` |
   | Expired token | `{"error": "Token has expired!"}` |
   | Invalid token signature | `{"error": "Invalid token!"}` |
   | User not found/inactive | `{"error": "User not found or inactive"}` |
   | Other token errors | `{"error": "Token processing error"}` |

### Example Client Usage

```python
import requests

def make_authenticated_request(token, endpoint):
    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    response = requests.get(
        f'https://api.fbolaunchpad.com{endpoint}',
        headers=headers
    )
    return response

# Example usage
token = "your.jwt.token"
response = make_authenticated_request(token, '/api/protected')
if response.status_code == 200:
    print("Success:", response.json())
else:
    print("Error:", response.json())
```

### Security Considerations

1. **Token Storage**: 
   - Store tokens securely on the client side (e.g., HttpOnly cookies for web applications)
   - Never store tokens in localStorage or sessionStorage due to XSS vulnerabilities

2. **Token Expiration**:
   - Use short-lived tokens (e.g., 15-60 minutes)
   - Implement token refresh mechanisms for longer sessions

3. **HTTPS**:
   - Always use HTTPS in production to prevent token interception
   - Consider adding additional security headers (e.g., HSTS)

4. **Error Messages**:
   - The decorator provides generic error messages to avoid leaking sensitive information
   - In development, you may want to enable more detailed error messages

### Dependencies

- Flask
- PyJWT
- SQLAlchemy (via Flask-SQLAlchemy)

### Best Practices

1. **Route Protection**:
   ```python
   # Protect all routes in a Blueprint
   @blueprint.before_request
   @token_required
   def before_request():
       pass
   ```

2. **Role-Based Access**:
   ```python
   from functools import wraps
   from flask import g

   def admin_required(f):
       @wraps(f)
       @token_required
       def decorated(*args, **kwargs):
           if g.current_user.role != UserRole.ADMIN:
               return jsonify({"error": "Admin access required"}), 403
           return f(*args, **kwargs)
       return decorated

   # Usage
   @app.route('/admin/dashboard')
   @admin_required
   def admin_dashboard():
       return jsonify({"message": "Welcome, Admin!"})
   ```

3. **Error Handling**:
   ```python
   from flask import Blueprint
   
   api = Blueprint('api', __name__)
   
   @api.errorhandler(401)
   def handle_unauthorized(error):
       return jsonify({
           "error": "Unauthorized",
           "message": "Please authenticate to access this resource"
       }), 401
   ```

### Testing

When writing tests for protected routes, you'll need to create valid JWT tokens:

```python
import jwt
import datetime

def create_test_token(user_id):
    return jwt.encode(
        {
            'sub': user_id,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=30)
        },
        current_app.config['SECRET_KEY'],
        algorithm='HS256'
    )

def test_protected_route(client, test_user):
    token = create_test_token(test_user.id)
    headers = {'Authorization': f'Bearer {token}'}
    response = client.get('/api/protected', headers=headers)
    assert response.status_code == 200
```
</file>

<file path="src/__init__.py">
"""
FBO LaunchPad Backend Package
"""

from flask import Flask
from .extensions import db, migrate
from flask_jwt_extended import JWTManager
from datetime import timedelta
import os

jwt = JWTManager()

def create_app(config_name='default'):
    app = Flask(__name__)
    
    # Load config
    if config_name == 'testing':
        from config import TestingConfig
        app.config.from_object(TestingConfig)
        TestingConfig.init_app(app)
    elif config_name == 'production':
        from config import ProductionConfig
        app.config.from_object(ProductionConfig)
        ProductionConfig.init_app(app)
    else:
        from config import DevelopmentConfig
        app.config.from_object(DevelopmentConfig)
        DevelopmentConfig.init_app(app)
        
    # Initialize extensions with app
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    
    # Import models to ensure they are registered with SQLAlchemy
    from .models.user import User
    from .models.aircraft import Aircraft
    from .models.customer import Customer
    from .models.fuel_truck import FuelTruck
    from .models.fuel_order import FuelOrder
    
    # Register blueprints
    from .routes.auth_routes import auth_bp
    from .routes.user_routes import user_bp
    from .routes.fuel_order_routes import fuel_order_bp
    from .routes.fuel_truck_routes import truck_bp
    from .routes.aircraft_routes import aircraft_bp
    from .routes.customer_routes import customer_bp
    
    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(user_bp, url_prefix='/api/users')
    app.register_blueprint(fuel_order_bp, url_prefix='/api/fuel-orders')
    app.register_blueprint(truck_bp, url_prefix='/api/fuel-trucks')
    app.register_blueprint(aircraft_bp, url_prefix='/api/aircraft')
    app.register_blueprint(customer_bp, url_prefix='/api/customers')
    
    return app
</file>

<file path="src/app.py">
import os
from flask import Flask, jsonify, current_app
from flask_migrate import Migrate
from apispec import APISpec
from apispec.ext.marshmallow import MarshmallowPlugin
from apispec_webframeworks.flask import FlaskPlugin
from flask_cors import CORS
from flask_jwt_extended import JWTManager

from src.config import config
from src.extensions import db, migrate
from src.cli import init_app as init_cli  # Import CLI initialization
from src.schemas import (
    RegisterRequestSchema,
    UserResponseSchema,
    RegisterResponseSchema,
    LoginRequestSchema,
    LoginSuccessResponseSchema,
    ErrorResponseSchema,
    FuelOrderCreateRequestSchema,
    FuelOrderStatusUpdateRequestSchema,
    FuelOrderCompleteRequestSchema,
    FuelOrderResponseSchema,
    FuelOrderBriefResponseSchema,
    FuelOrderCreateResponseSchema,
    FuelOrderUpdateResponseSchema,
    PaginationSchema,
    FuelOrderListResponseSchema,
    FuelTruckSchema,
    FuelTruckListResponseSchema,
    FuelTruckCreateRequestSchema,
    FuelTruckCreateResponseSchema,
    OrderStatusCountsSchema,
    OrderStatusCountsResponseSchema
)

def create_app(config_name=None):
    """Application factory function."""
    if config_name is None:
        config_name = os.getenv('FLASK_ENV', 'development')

    # Create Flask app instance
    app = Flask(__name__)

    # TROUBLESHOOTING: Allow all origins and headers to isolate CORS issues
    CORS(
        app,
        origins="*",
        allow_headers="*",
        expose_headers="*",
        methods=["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
        supports_credentials=True
    )

    # Load config
    app.config.from_object(config[config_name])

    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    JWTManager(app)
    init_cli(app)

    # Initialize API documentation with apispec
    spec = APISpec(
        title="FBO LaunchPad API",
        version="1.0.0",
        openapi_version="3.0.2",
        plugins=[FlaskPlugin(), MarshmallowPlugin()],
    )

    # Add security scheme for JWT
    spec.components.security_scheme(
        "bearerAuth",
        {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    )

    # Import blueprints here to avoid circular imports
    from src.routes.auth_routes import auth_bp
    from src.routes.fuel_order_routes import fuel_order_bp
    from src.routes.user_routes import user_bp
    from src.routes.fuel_truck_routes import truck_bp
    from src.routes.aircraft_routes import aircraft_bp
    from src.routes.customer_routes import customer_bp
    from src.routes.admin.aircraft_admin_routes import aircraft_admin_bp
    from src.routes.admin.customer_admin_routes import customer_admin_bp
    from src.routes.admin.permission_admin_routes import permission_admin_bp
    from src.routes.admin.user_admin_routes import user_admin_bp
    from src.models import User  # Import User model here after extensions are initialized

    # Register blueprints
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(fuel_order_bp, url_prefix='/api/fuel-orders')
    app.register_blueprint(user_bp, url_prefix='/api/users')
    app.register_blueprint(truck_bp, url_prefix='/api/trucks')
    app.register_blueprint(aircraft_bp, url_prefix='/api/aircraft')
    app.register_blueprint(customer_bp, url_prefix='/api/customers')
    app.register_blueprint(aircraft_admin_bp, url_prefix='/api/admin/aircraft')
    app.register_blueprint(customer_admin_bp, url_prefix='/api/admin/customers')
    app.register_blueprint(permission_admin_bp, url_prefix='/api/admin/permissions')
    app.register_blueprint(user_admin_bp, url_prefix='/api/admin/users')
    

    # Register schemas and paths with apispec
    with app.app_context():
        # Attach spec to app for use in other modules
        app.spec = spec

        # Register Auth Schemas
        spec.components.schema("RegisterRequestSchema", schema=RegisterRequestSchema)
        spec.components.schema("UserResponseSchema", schema=UserResponseSchema)
        spec.components.schema("RegisterResponseSchema", schema=RegisterResponseSchema)
        spec.components.schema("LoginRequestSchema", schema=LoginRequestSchema)
        spec.components.schema("LoginSuccessResponseSchema", schema=LoginSuccessResponseSchema)
        spec.components.schema("ErrorResponseSchema", schema=ErrorResponseSchema)

        # Register User Admin Schemas
        from src.schemas.user_schemas import (
            UserCreateRequestSchema, UserUpdateRequestSchema,
            UserDetailSchema, UserListResponseSchema, UserBriefSchema,
            RoleBriefSchema
        )
        spec.components.schema("RoleBriefSchema", schema=RoleBriefSchema)
        spec.components.schema("UserBriefSchema", schema=UserBriefSchema)
        spec.components.schema("UserCreateRequestSchema", schema=UserCreateRequestSchema)
        spec.components.schema("UserUpdateRequestSchema", schema=UserUpdateRequestSchema)
        spec.components.schema("UserDetailSchema", schema=UserDetailSchema)
        spec.components.schema("UserListResponseSchema", schema=UserListResponseSchema)

        # Register Fuel Order Schemas
        spec.components.schema("FuelOrderCreateRequestSchema", schema=FuelOrderCreateRequestSchema)
        spec.components.schema("FuelOrderStatusUpdateRequestSchema", schema=FuelOrderStatusUpdateRequestSchema)
        spec.components.schema("FuelOrderCompleteRequestSchema", schema=FuelOrderCompleteRequestSchema)
        spec.components.schema("FuelOrderResponseSchema", schema=FuelOrderResponseSchema)
        spec.components.schema("FuelOrderBriefResponseSchema", schema=FuelOrderBriefResponseSchema)
        spec.components.schema("FuelOrderCreateResponseSchema", schema=FuelOrderCreateResponseSchema)
        spec.components.schema("FuelOrderUpdateResponseSchema", schema=FuelOrderUpdateResponseSchema)
        spec.components.schema("PaginationSchema", schema=PaginationSchema)
        spec.components.schema("FuelOrderListResponseSchema", schema=FuelOrderListResponseSchema)
        spec.components.schema("OrderStatusCountsSchema", schema=OrderStatusCountsSchema)
        spec.components.schema("OrderStatusCountsResponseSchema", schema=OrderStatusCountsResponseSchema)

        # Register Fuel Truck Schemas
        spec.components.schema("FuelTruckSchema", schema=FuelTruckSchema)
        spec.components.schema("FuelTruckListResponseSchema", schema=FuelTruckListResponseSchema)
        spec.components.schema("FuelTruckCreateRequestSchema", schema=FuelTruckCreateRequestSchema)
        spec.components.schema("FuelTruckCreateResponseSchema", schema=FuelTruckCreateResponseSchema)

        # Register Aircraft Schemas
        from src.schemas.aircraft_schemas import (
            AircraftCreateSchema,
            AircraftUpdateSchema,
            AircraftResponseSchema,
            AircraftListSchema,
            ErrorResponseSchema as AircraftErrorResponseSchema
        )
        spec.components.schema("AircraftCreateSchema", schema=AircraftCreateSchema)
        spec.components.schema("AircraftUpdateSchema", schema=AircraftUpdateSchema)
        spec.components.schema("AircraftResponseSchema", schema=AircraftResponseSchema)
        spec.components.schema("AircraftListSchema", schema=AircraftListSchema)
        spec.components.schema("AircraftErrorResponseSchema", schema=AircraftErrorResponseSchema)

        # Register Customer Schemas
        from src.schemas.customer_schemas import (
            CustomerCreateSchema,
            CustomerUpdateSchema,
            CustomerResponseSchema,
            CustomerListSchema,
            ErrorResponseSchema as CustomerErrorResponseSchema
        )
        spec.components.schema("CustomerCreateSchema", schema=CustomerCreateSchema)
        spec.components.schema("CustomerUpdateSchema", schema=CustomerUpdateSchema)
        spec.components.schema("CustomerResponseSchema", schema=CustomerResponseSchema)
        spec.components.schema("CustomerListSchema", schema=CustomerListSchema)
        spec.components.schema("CustomerErrorResponseSchema", schema=CustomerErrorResponseSchema)

        # Register Admin Schemas
        from src.schemas.admin_schemas import (
            AdminAircraftSchema, AdminAircraftListResponseSchema,
            AdminCustomerSchema, AdminCustomerListResponseSchema
        )
        spec.components.schema("AdminAircraftSchema", schema=AdminAircraftSchema)
        spec.components.schema("AdminAircraftListResponseSchema", schema=AdminAircraftListResponseSchema)
        spec.components.schema("AdminCustomerSchema", schema=AdminCustomerSchema)
        spec.components.schema("AdminCustomerListResponseSchema", schema=AdminCustomerListResponseSchema)

        # Register Permission Schemas
        from src.routes.admin.permission_admin_routes import PermissionListResponseSchema
        from src.schemas import PermissionSchema
        spec.components.schema("PermissionSchema", schema=PermissionSchema)
        spec.components.schema("PermissionListResponseSchema", schema=PermissionListResponseSchema)

        # Register Auth Views
        from src.routes.auth_routes import register, login
        spec.path(view=register, bp=auth_bp)
        spec.path(view=login, bp=auth_bp)

        # Register User Views
        from src.routes.user_routes import get_users
        spec.path(view=get_users, bp=user_bp)

        # Register Fuel Order Views
        from src.routes.fuel_order_routes import (
            create_fuel_order, get_fuel_orders, get_fuel_order,
            update_fuel_order_status, submit_fuel_data, review_fuel_order,
            export_fuel_orders_csv, get_status_counts
        )
        spec.path(view=create_fuel_order, bp=fuel_order_bp)
        spec.path(view=get_fuel_orders, bp=fuel_order_bp)
        spec.path(view=get_fuel_order, bp=fuel_order_bp)
        spec.path(view=update_fuel_order_status, bp=fuel_order_bp)
        spec.path(view=submit_fuel_data, bp=fuel_order_bp)
        spec.path(view=review_fuel_order, bp=fuel_order_bp)
        spec.path(view=export_fuel_orders_csv, bp=fuel_order_bp)
        spec.path(view=get_status_counts, bp=fuel_order_bp)


        # Register Fuel Truck Views
        from src.routes.fuel_truck_routes import get_fuel_trucks, create_fuel_truck
        spec.path(view=get_fuel_trucks, bp=truck_bp)
        spec.path(view=create_fuel_truck, bp=truck_bp)

        # Register Aircraft Views
        from src.routes.aircraft_routes import list_aircraft, create_aircraft, get_aircraft, update_aircraft, delete_aircraft
        spec.path(view=list_aircraft, bp=aircraft_bp)
        spec.path(view=create_aircraft, bp=aircraft_bp)
        spec.path(view=get_aircraft, bp=aircraft_bp)
        spec.path(view=update_aircraft, bp=aircraft_bp)
        spec.path(view=delete_aircraft, bp=aircraft_bp)

        # Register Admin Aircraft Views
        from src.routes.admin.aircraft_admin_routes import list_aircraft as admin_list_aircraft, create_aircraft as admin_create_aircraft, get_aircraft as admin_get_aircraft, update_aircraft as admin_update_aircraft, delete_aircraft as admin_delete_aircraft
        spec.path(view=admin_list_aircraft, bp=aircraft_admin_bp)
        spec.path(view=admin_create_aircraft, bp=aircraft_admin_bp)
        spec.path(view=admin_get_aircraft, bp=aircraft_admin_bp)
        spec.path(view=admin_update_aircraft, bp=aircraft_admin_bp)
        spec.path(view=admin_delete_aircraft, bp=aircraft_admin_bp)

        # Register Customer Views
        from src.routes.customer_routes import list_customers, create_customer, get_customer, update_customer, delete_customer
        spec.path(view=list_customers, bp=customer_bp)
        spec.path(view=create_customer, bp=customer_bp)
        spec.path(view=get_customer, bp=customer_bp)
        spec.path(view=update_customer, bp=customer_bp)
        spec.path(view=delete_customer, bp=customer_bp)

        # Register Admin Customer Views
        from src.routes.admin.customer_admin_routes import list_customers as admin_list_customers, create_customer as admin_create_customer, get_customer as admin_get_customer, update_customer as admin_update_customer, delete_customer as admin_delete_customer
        spec.path(view=admin_list_customers, bp=customer_admin_bp)
        spec.path(view=admin_create_customer, bp=customer_admin_bp)
        spec.path(view=admin_get_customer, bp=customer_admin_bp)
        spec.path(view=admin_update_customer, bp=customer_admin_bp)
        spec.path(view=admin_delete_customer, bp=customer_admin_bp)

        # Register Permission Views
        from src.routes.admin.permission_admin_routes import get_permissions
        spec.path(view=get_permissions, bp=permission_admin_bp)

        # Register User Admin Views
        from src.routes.admin.user_admin_routes import get_users as admin_get_users, create_user as admin_create_user, get_user as admin_get_user, update_user as admin_update_user, delete_user as admin_delete_user
        spec.path(view=admin_get_users, bp=user_admin_bp)
        spec.path(view=admin_create_user, bp=user_admin_bp)
        spec.path(view=admin_get_user, bp=user_admin_bp)
        spec.path(view=admin_update_user, bp=user_admin_bp)
        spec.path(view=admin_delete_user, bp=user_admin_bp)

        # Register Role and Permission schemas
        from src.schemas.role_schemas import (
            RoleSchema, RoleCreateRequestSchema, RoleUpdateRequestSchema,
            RoleListResponseSchema, RoleAssignPermissionRequestSchema
        )
        spec.components.schema("RoleSchema", schema=RoleSchema)
        spec.components.schema("RoleCreateRequestSchema", schema=RoleCreateRequestSchema)
        spec.components.schema("RoleUpdateRequestSchema", schema=RoleUpdateRequestSchema)
        spec.components.schema("RoleListResponseSchema", schema=RoleListResponseSchema)
        spec.components.schema("RoleAssignPermissionRequestSchema", schema=RoleAssignPermissionRequestSchema)

        # Register Role management paths
        from src.routes.admin.role_admin_routes import get_roles, create_role, get_role, update_role, delete_role, get_role_permissions
        spec.path(view=get_roles, bp=role_admin_bp)
        spec.path(view=create_role, bp=role_admin_bp)
        spec.path(view=get_role, bp=role_admin_bp)
        spec.path(view=update_role, bp=role_admin_bp)
        spec.path(view=delete_role, bp=role_admin_bp)
        spec.path(view=get_role_permissions, bp=role_admin_bp)

        # Register Permission paths
        spec.path(view=get_permissions, bp=permission_admin_bp)

    @app.route('/')
    def root():
        """Root endpoint."""
        return jsonify({"status": "ok", "message": "FBO LaunchPad API is running"})

    @app.route('/health')
    def health_check():
        """Basic health check endpoint."""
        return jsonify({'status': 'healthy', 'message': 'FBO LaunchPad API is running'})

    @app.route('/api/swagger.json')
    def create_swagger_spec():
        """Serve the swagger specification."""
        return jsonify(app.spec.to_dict())

    # Add global CORS headers to every response (including errors)
    @app.after_request
    def add_cors_headers(response):
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Headers'] = '*'
        response.headers['Access-Control-Allow-Methods'] = 'GET,POST,PUT,DELETE,OPTIONS'
        return response

    return app

if __name__ == '__main__':
    app = create_app()
    app.run()
</file>

<file path="src/cli.py">
import click
from flask.cli import with_appcontext
from .extensions import db

@click.command('create-admin')
@with_appcontext
def create_admin():
    """Create an admin user."""
    from .models.user import User
    from .models.role import Role
    
    # Check if admin already exists
    if User.query.filter_by(email='admin@fbolaunchpad.com').first():
        click.echo("Admin user already exists!")
        return
    
    # Get admin role
    admin_role = Role.query.filter_by(name='Administrator').first()
    if not admin_role:
        click.echo("Error: Administrator role not found!")
        return
    
    # Create new admin user
    admin = User(
        email='admin@fbolaunchpad.com',
        username='admin',
        name='Admin',
        is_active=True
    )
    admin.set_password('Admin123!')
    admin.roles = [admin_role]
    
    # Save to database
    db.session.add(admin)
    db.session.commit()
    click.echo("Admin user created successfully!")

def init_app(app):
    """Register CLI commands."""
    app.cli.add_command(create_admin)
</file>

<file path="src/config.py">
import os
from dotenv import load_dotenv
from datetime import timedelta

# Load environment variables from .env file
load_dotenv()

class Config:
    """Base configuration class."""
    # Flask
    SECRET_KEY = os.getenv('SECRET_KEY', 'dev-key-please-change')
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY', 'dev-secret-key')
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)
    JWT_ALGORITHM = 'HS256'
    JWT_TOKEN_LOCATION = ['headers']
    JWT_HEADER_NAME = 'Authorization'
    JWT_HEADER_TYPE = 'Bearer'
    FLASK_ENV = os.getenv('FLASK_ENV', 'development')
    DEBUG = os.getenv('DEBUG', 'True').lower() == 'true'

    # Database
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ECHO = os.getenv('SQLALCHEMY_ECHO', 'False').lower() == 'true'

    # Application specific
    APP_NAME = os.getenv('APP_NAME', 'FBO LaunchPad')
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'DEBUG')

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True

class ProductionConfig(Config):
    """Production configuration."""
    DEBUG = False

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    # Always use SQLite in-memory for tests
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    # Keep test output clean
    SQLALCHEMY_ECHO = False
    # Use static keys for testing
    SECRET_KEY = 'test-secret-key'
    JWT_SECRET_KEY = 'test-jwt-secret-key'
    # Disable CSRF for testing if using Flask-WTF
    WTF_CSRF_ENABLED = False
    # Disable error catching during request handling
    PROPAGATE_EXCEPTIONS = True
    # Disable Flask-DebugToolbar if installed
    DEBUG_TB_ENABLED = False

# Configuration dictionary
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}
</file>

<file path="src/extensions.py">
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from apispec import APISpec
from apispec.ext.marshmallow import MarshmallowPlugin
from flask_jwt_extended import JWTManager

# Database
db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()

# API documentation
apispec = APISpec(
    title="FBO LaunchPad API",
    version="1.0.0",
    openapi_version="3.0.2",
    plugins=[MarshmallowPlugin()],
)
</file>

<file path="tasks/active_Context.md">
# Active Backend Context

## Current Focus
- Backend CRUD API endpoints for Users, Fuel Trucks, Aircraft, Customers
- Permission-based access control (PBAC) schema implemented (Permission, Role, role_permissions, user_roles, User.roles)
- Static role columns/enums removed from User model
- Marshmallow validation and serialization
- Consistent error handling and OpenAPI documentation

## Entities & Endpoints
- **Users**: Full CRUD, soft delete, activation, role enforcement
- **Fuel Trucks**: Full CRUD, truck number uniqueness
- **Aircraft**: Full CRUD, tail number uniqueness
- **Customers**: Full CRUD, name uniqueness
- **Security**: JWT, decorators for role and active status
- **Docs**: OpenAPI docs for all endpoints

## Security & Validation Patterns
- All CUD operations require Admin role
- JWT required for all endpoints
- Input validated with Marshmallow schemas
- Consistent error/message response structure
- Sensitive fields excluded from responses

## Known Issues
- No pagination or search on list endpoints
- Unit test coverage incomplete
- Some endpoints missing frontend integration

## Status Update
- Admin CRUD API endpoints for Aircraft and Customers are now implemented, documented, and available for frontend integration/testing.
- PBAC migration script updated: Permission, Role, user_roles, role_permissions tables created, User.role column removed. **Permissions table is now seeded with 21 finalized permissions via bulk_insert in upgrade; downgrade removes these records before dropping the table.** Migration script inspected and verified for correctness (upgrade/downgrade, data seeding).
- **Step 5 complete:** Migration now also seeds default roles (System Administrator, Customer Service Representative, Line Service Technician) and assigns the correct permissions to each via the role_permissions table. This ensures baseline access for user migration in the next step. Migration script reviewed for correctness and reversibility.
- **Step 6 complete:** Migration script now migrates all existing users to the new default roles based on their previous role assignment. Old users.role values are mapped to new role names and inserted into user_roles. Downgrade deletes all user_roles links before dropping the table. This preserves user access during PBAC transition.
- **Step 7 complete (2025-05-04):** Alembic migration script applied successfully using `flask db upgrade`. All schema changes (permissions, roles, role_permissions, user_roles tables) and data seeding/migration logic executed without error. Users migrated to new user_roles table, old users.role column removed. Migration ordering and session/table definition issues encountered and resolved (see error documentation). **PBAC Phase 1 is now complete.**
- **Step 8 complete (2025-05-05):** User.has_permission(permission_name) method implemented in src/models/user.py. This enables efficient permission checks for users based on their roles and is ready for use in new authorization logic (decorators, etc.).
- **Step 9 complete (2025-05-06):** @require_permission(permission_name) decorator implemented in src/utils/decorators.py, replacing @require_role. Decorator uses g.current_user.has_permission(permission_name) and returns 403/500 as appropriate. Old @require_role removed. Next: Refactor routes to use new decorator and update tests.
- PBAC Phase 2 Step 10 complete: All route handlers now use @require_permission with correct permission names, all redundant role checks removed, and docstrings updated. Backend authorization logic overhaul is complete. API docs may need APIDog update if docstrings changed significantly.
- **Step 11 complete (2025-05-08):** Implemented complete business logic for `RoleService` class with all required static methods for managing roles and their permissions. Service includes comprehensive error handling, input validation, and proper database transaction management. All methods follow consistent return pattern and are ready for integration with admin routes.
- **Step 12 complete (2025-05-09):** Implemented `get_all_permissions` static method in `PermissionService` class. Method retrieves all permissions ordered by name, includes proper error handling with SQLAlchemy exception catching and session rollback, and follows the consistent return pattern (data/None, message, status_code). Ready for integration with admin routes.
- **Step 13 complete (2025-05-10):** Implemented complete RESTful API endpoints in `src/routes/admin/role_admin_routes.py` for managing Roles and their Permissions. All endpoints are secured with `@require_permission('MANAGE_ROLES')`, use proper request validation and response serialization via Marshmallow schemas, and are fully documented with OpenAPI specifications. The routes are connected to the `RoleService` methods and follow the consistent error handling pattern.
- **Step 14 complete (2025-05-11):** Implemented Flask route handler in `src/routes/admin/permission_admin_routes.py` for listing all available system Permissions. Created `PermissionListResponseSchema` for consistent response serialization, secured endpoint with `@require_permission('VIEW_PERMISSIONS')`, connected to `PermissionService.get_all_permissions()` method, and added OpenAPI documentation. Ready for frontend integration via APIDog swagger.json import.
- **Step 15 complete (2025-05-12):** Refactored `UserService` class to fully support PBAC's many-to-many relationship between Users and Roles. All methods (`create_user`, `update_user`, `get_users`, `get_user_by_id`) now handle role_ids lists, validate role existence, and use SQLAlchemy's eager loading to prevent N+1 queries. The old UserRole enum has been completely removed, and proper error messages are in place for invalid role assignments. This completes the service-layer updates for PBAC Phase 3.
- **Step 16 complete (2025-05-13):** Implemented complete Admin User Management API route handlers in `src/routes/admin/user_admin_routes.py`. Created/updated user schemas to handle role_ids list and proper response serialization. All endpoints (`GET /`, `POST /`, `GET /<id>`, `PATCH /<id>`, `DELETE /<id>`) are secured with appropriate permissions (`VIEW_USERS` or `MANAGE_USERS`). Blueprint registered in `src/app.py` with proper URL prefix and OpenAPI documentation. Ready for frontend integration via APIDog swagger.json import.

## Next Steps
- Add pagination/search to list endpoints
- Write/complete unit and integration tests
- Integrate endpoints with frontend
- Improve error messages and documentation
- Update service and route logic to use new PBAC schema

## [2024-05-01] Refactor: LSTs can now create orders; POST /api/fuel-orders supports -1 for auto-assigning least busy LST; new GET /api/fuel-orders/stats/status-counts endpoint for dashboard; removed obsolete queue/global assign logic.
</file>

<file path="tasks/tasks_plan.md">
# Project Progress (Backend)

## Completed Features
- User authentication (JWT, password hashing, role-based access)
- Fuel Order CRUD endpoints
- User CRUD endpoints (Admin/CSR, soft delete)
- Fuel Truck CRUD endpoints
- Aircraft CRUD endpoints
- Customer CRUD endpoints
- OpenAPI/Swagger documentation for all endpoints
- Consistent error handling and validation (Marshmallow)

## Current API Entities & Endpoints
- **Users**: Create, list, retrieve, update, delete (Admin/CSR, soft delete, activation)
- **Fuel Orders**: Full CRUD, status management, CSV export
- **Fuel Trucks**: Full CRUD, truck number uniqueness
- **Aircraft**: Full CRUD, tail number uniqueness
- **Customers**: Full CRUD, name uniqueness
- **Security**: JWT, role-based decorators, active status enforcement
- **Docs**: All endpoints and schemas documented in OpenAPI

## Known Issues
- No pagination on list endpoints
- No search or advanced filtering
- Unit test coverage incomplete
- Some endpoints lack frontend integration

## Backend Refactor: Fuel Order Auto-Assign & Stats (April 26, 2025)

### Completed
- Refactored `FuelOrderService.create_fuel_order` to implement `-1` auto-assign for LSTs:
  - If `assigned_lst_user_id` is `-1`, backend selects least busy active LST (fewest active/in-progress orders).
  - If not `-1`, validates LST exists, is active, and is an LST.
  - Truck assignment logic unchanged.
- Updated `POST /api/fuel-orders` route:
  - Now allows LSTs to create orders (`@require_role` includes LST).
  - Docstring and validation updated to clarify `-1` behavior and type handling.
- Implemented `GET /api/fuel-orders/stats/status-counts` endpoint:
  - Counts orders by status group (pending, in progress, completed) for dashboard.
  - Available to CSR, ADMIN, and LST roles.
  - Registered schema and route in OpenAPI.
- Updated schemas:
  - `FuelOrderCreateRequestSchema` allows `-1` for auto-assign (with docstring/metadata).
  - `OrderStatusCountsResponseSchema` docstring clarified.
  - All schemas registered in `src/schemas/__init__.py`.
- Registered new schemas and paths in `src/app.py` for OpenAPI docs.
- Removed all obsolete code related to global auto-assign toggle and LST queue API (no longer relevant).
- **As of April 26, 2025:** `src/routes/admin/assignment_settings_routes.py` is now a pure deprecation stub (comment only, no Blueprint or routes). This fixes all NameError and lint errors from that file and confirms the global auto-assign admin API is fully removed.

### New API Behavior
- To auto-assign an LST, send `assigned_lst_user_id: -1` in POST payload.
- All roles (CSR, ADMIN, LST) can create fuel orders and view status counts.
- API docs and schemas up-to-date with new logic.

### Next Steps
- Add pagination and search to list endpoints
- Complete unit/integration test coverage
- Integrate all endpoints with frontend
- Review and improve error messages
- Document any new endpoints or changes in OpenAPI
3. Reporting features

## PBAC Overhaul (Phase 1)
### Step 4 Complete (2025-05-01):
- Alembic migration script for PBAC now seeds the permissions table with the finalized list of 21 permissions (bulk_insert in upgrade, targeted delete in downgrade).
- This ensures all system permissions are present for subsequent role/assignment steps.
- Migration script reviewed for correctness and reversibility.

### Step 5 Complete (2025-05-02):
- Alembic migration script now seeds the default roles (System Administrator, Customer Service Representative, Line Service Technician) and assigns the correct permissions to each via the role_permissions table.
- This ensures all baseline roles and permissions are present for user migration in the next step.
- Migration script reviewed for correctness, reversibility, and data integrity.

### Step 6 Complete (2025-05-03):
- Alembic migration script now migrates all existing users to the new default roles based on their previous role assignment.
- Reads old users.role value before column is dropped, maps to new role name, and inserts into user_roles association table.
- Ensures all users retain correct access after PBAC migration.
- Downgrade deletes all user_roles links before dropping table.
- Migration script reviewed for correctness, reversibility, and data integrity.

### Step 7 Complete (2025-05-04):
- Alembic migration script applied successfully using `flask db upgrade`.
- All schema changes (permissions, roles, role_permissions, user_roles tables) and data seeding/migration logic executed without error.
- Users migrated to new user_roles table, old users.role column removed.
- Migration ordering and session/table definition issues encountered and resolved (see error documentation).
- **PBAC Phase 1 is now complete.**

### Next Steps
- Assign seeded permissions to default roles in a follow-up migration or script.
- Update service and route logic to use new PBAC schema.
- Continue with PBAC Phase 2 as planned.

## PBAC Overhaul (Phase 2)
### Step 8 Complete (2025-05-05):
- Implemented User.has_permission(permission_name) method in src/models/user.py.
- This method checks if a user has a specific permission by iterating through their roles and checking each role's permissions efficiently using SQLAlchemy's filter_by.
- Ready for use by the new authorization decorator (to be implemented in Step 9).

### Step 9 Complete (2025-05-06):
- Implemented @require_permission(permission_name) decorator in src/utils/decorators.py.
- Decorator checks g.current_user.has_permission(permission_name) and returns 403/500 as appropriate.
- Old @require_role decorator removed.
- Ready for use in route protection for all endpoints requiring granular permission checks.
- Next: Refactor routes to use @require_permission and update tests accordingly.

### Step 10 Complete (2025-05-07):
- All route handlers now use @require_permission with correct permission names, all redundant role checks removed, and docstrings updated.
- Backend authorization logic overhaul is complete.
- API docs may need APIDog update if docstrings changed significantly.

## PBAC Overhaul (Phase 3)
### Step 11 Complete (2025-05-08):
- Implemented complete business logic for all static methods in `RoleService` class (`src/services/role_service.py`).
- Methods implemented:
  - `get_all_roles`: Retrieves all roles ordered by name
  - `create_role`: Creates new role with name validation
  - `get_role_by_id`: Retrieves role by ID
  - `update_role`: Updates role with name uniqueness check
  - `delete_role`: Deletes role with user assignment check
  - `get_role_permissions`: Gets permissions for a role
  - `assign_permission_to_role`: Assigns permission to role
  - `remove_permission_from_role`: Removes permission from role
- All methods include proper error handling, input validation, and database transaction management
- Return tuples follow consistent pattern: (result, message, status_code)
- Ready for integration with admin routes in next step

### Step 12 Complete (2025-05-09):
- Implemented `get_all_permissions` static method in `PermissionService` class.
- Method retrieves all permissions ordered by name.
- Includes proper error handling with SQLAlchemy exception catching and session rollback.
- Follows consistent return pattern (data/None, message, status_code).
- Ready for integration with admin routes.

### Step 13 Complete (2025-05-10):
- Implemented complete RESTful API endpoints in `src/routes/admin/role_admin_routes.py` for managing Roles and their Permissions.
- All endpoints secured with `@require_permission('MANAGE_ROLES')`.
- Uses proper request validation and response serialization via Marshmallow schemas.
- Fully documented with OpenAPI specifications.
- Routes connected to `RoleService` methods and follow consistent error handling pattern.

### Step 14 Complete (2025-05-11):
- Implemented Flask route handler in `src/routes/admin/permission_admin_routes.py` for listing all available system Permissions.
- Created `PermissionListResponseSchema` for consistent response serialization.
- Endpoint secured with `@require_permission('VIEW_PERMISSIONS')`.
- Connected to `PermissionService.get_all_permissions()` method.
- Added OpenAPI documentation and registered blueprint/schemas in `src/app.py`.
- Ready for frontend integration via APIDog swagger.json import.

### Step 15 Complete (2025-05-12):
- Refactored `UserService` class to handle many-to-many relationship between Users and Roles.
- Updated all methods to work with `role_ids` list instead of single `role` enum:
  - `create_user`: Now accepts and validates list of role IDs, fetches Role objects, and assigns them to user.
  - `update_user`: Handles role_ids updates, including empty list for removing all roles.
  - `get_users`: Uses eager loading (selectinload) for roles, supports filtering by role IDs.
  - `get_user_by_id`: Uses eager loading for roles to prevent N+1 queries.
- Added proper validation for role IDs existence and format.
- Improved error messages for invalid role assignments.
- Removed all references to old UserRole enum.
- Uses SQLAlchemy relationship features correctly for many-to-many associations.

### Step 16 Complete (2025-05-13):
- Implemented complete Admin User Management API route handlers in `src/routes/admin/user_admin_routes.py`.
- Created/updated user schemas in `src/schemas/user_schemas.py`:
  - Added `RoleBriefSchema` for role information in responses
  - Updated `UserCreateRequestSchema` and `UserUpdateRequestSchema` to use `role_ids` list
  - Added `UserBriefSchema` and `UserDetailSchema` for responses
  - Updated `UserListResponseSchema` to use `UserBriefSchema`
- Implemented all required endpoints with proper permission decorators:
  - `GET /api/admin/users/` - List users (`@require_permission('VIEW_USERS')`)
  - `POST /api/admin/users/` - Create user (`@require_permission('MANAGE_USERS')`)
  - `GET /api/admin/users/<id>` - Get user details (`@require_permission('VIEW_USERS')`)
  - `PATCH /api/admin/users/<id>` - Update user (`@require_permission('MANAGE_USERS')`)
  - `DELETE /api/admin/users/<id>` - Delete user (`@require_permission('MANAGE_USERS')`)
- Updated `src/app.py` to:
  - Register `user_admin_bp` blueprint with URL prefix `/api/admin/users`
  - Register all user admin schemas with apispec
  - Register all user admin views with apispec for documentation
- All endpoints properly documented with OpenAPI specifications
- Ready for frontend integration via APIDog swagger.json import

## Recent Changes
2. Implemented Admin CRUD API endpoints for Aircraft and Customers:
   - Created `src/routes/admin/aircraft_admin_routes.py` and `src/routes/admin/customer_admin_routes.py` for all admin CRUD operations (GET, POST, PATCH, DELETE).
   - Added/verified service logic in `src/services/aircraft_service.py` and `src/services/customer_service.py` (including error handling, foreign key checks, and correct PK usage).
   - Created `src/schemas/admin_schemas.py` with Marshmallow schemas for admin Aircraft and Customer operations.
   - Registered new blueprints and schemas in `src/app.py` and updated OpenAPI documentation (apispec docstrings and schema registration).
   - All endpoints secured with Admin role and JWT, with consistent error handling and OpenAPI compliance.

1. Updated user_routes.py:
   - Implemented get_users endpoint
   - Added filter parameter handling
   - Added response serialization
   - Updated API documentation

## Validation Status
- ✅ API documentation complete
- ✅ Security measures implemented
- ⏳ Test coverage pending
- ⏳ Frontend integration pending
</file>

<file path="tests/conftest.py">
import os
os.environ.pop('DATABASE_URL', None)
os.environ.pop('TEST_DATABASE_URL', None)

import pytest
import jwt
from datetime import datetime, timedelta
from src import create_app
from src.models.user import User
from src.models.role import Role
from src.models.permission import Permission
from src.models.aircraft import Aircraft
from src.models.customer import Customer
from src.models.fuel_truck import FuelTruck
from src.models.fuel_order import FuelOrder
from src.extensions import db as _db

@pytest.fixture(scope='session')
def app():
    """Create application for the tests."""
    app = create_app('testing')
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    app.config['JWT_SECRET_KEY'] = 'test-secret-key'
    return app

@pytest.fixture(scope='session')
def db(app):
    """Set up the database for testing."""
    with app.app_context():
        _db.create_all()
        yield _db
        _db.session.remove()
        _db.drop_all()

@pytest.fixture(scope='function')
def db_session(app, db):
    """Create a new database session for a test."""
    with app.app_context():
        # Start a nested transaction
        connection = db.engine.connect()
        transaction = connection.begin()
        
        # Use the connection with the begun transaction
        db.session.configure(bind=connection)
        
        yield db.session
        
        # Rollback the transaction and remove the session
        transaction.rollback()
        connection.close()
        db.session.remove()

@pytest.fixture
def client(app):
    """Create test client."""
    return app.test_client()

@pytest.fixture(scope='session')
def test_permissions(db_session):
    """Create test permissions."""
    permissions = [
        Permission(name='MANAGE_ROLES', description='Can manage roles'),
        Permission(name='VIEW_PERMISSIONS', description='Can view permissions'),
        Permission(name='MANAGE_USERS', description='Can manage users'),
        Permission(name='VIEW_USERS', description='Can view users'),
        Permission(name='CREATE_ORDER', description='Can create fuel orders'),
        Permission(name='MANAGE_ORDERS', description='Can manage fuel orders'),
        Permission(name='VIEW_ORDERS', description='Can view fuel orders'),
        Permission(name='COMPLETE_ORDER', description='Can complete fuel orders'),
        Permission(name='MANAGE_TRUCKS', description='Can manage fuel trucks'),
        Permission(name='VIEW_TRUCKS', description='Can view fuel trucks')
    ]
    for p in permissions:
        db_session.add(p)
    db_session.commit()
    return permissions

@pytest.fixture(scope='session')
def test_roles(db_session, test_permissions):
    """Create test roles."""
    # Admin role gets all permissions
    admin_role = Role(name='Administrator', description='Full system access')
    admin_role.permissions.extend(test_permissions)
    
    # CSR role gets customer service permissions
    csr_role = Role(name='Customer Service Representative', description='Customer service access')
    csr_permissions = [p for p in test_permissions if p.name in [
        'CREATE_ORDER', 'MANAGE_ORDERS', 'VIEW_ORDERS', 'VIEW_USERS'
    ]]
    csr_role.permissions.extend(csr_permissions)
    
    # LST role gets limited permissions
    lst_role = Role(name='Line Service Technician', description='Line service access')
    lst_permissions = [p for p in test_permissions if p.name in [
        'VIEW_ORDERS', 'COMPLETE_ORDER', 'VIEW_TRUCKS'
    ]]
    lst_role.permissions.extend(lst_permissions)
    
    roles = [admin_role, csr_role, lst_role]
    for role in roles:
        db_session.add(role)
    db_session.commit()
    return roles

@pytest.fixture(scope='session')
def test_users(db_session, test_roles):
    """Create test users."""
    admin_role = Role.query.filter_by(name='Administrator').first()
    csr_role = Role.query.filter_by(name='Customer Service Representative').first()
    lst_role = Role.query.filter_by(name='Line Service Technician').first()
    
    admin_user = User(
        username='admin',
        email='admin@test.com',
        name='Admin User',
        is_active=True
    )
    admin_user.set_password('adminpass')
    admin_user.roles.append(admin_role)
    
    csr_user = User(
        username='csr',
        email='csr@test.com',
        name='CSR User',
        is_active=True
    )
    csr_user.set_password('csrpass')
    csr_user.roles.append(csr_role)
    
    lst_user = User(
        username='lst',
        email='lst@test.com',
        name='LST User',
        is_active=True
    )
    lst_user.set_password('lstpass')
    lst_user.roles.append(lst_role)
    
    inactive_user = User(
        username='inactive',
        email='inactive@test.com',
        name='Inactive User',
        is_active=False
    )
    inactive_user.set_password('inactivepass')
    inactive_user.roles.append(lst_role)
    
    users = [admin_user, csr_user, lst_user, inactive_user]
    for user in users:
        db_session.add(user)
    db_session.commit()
    return users

@pytest.fixture
def test_admin_user(test_users):
    """Get the admin test user."""
    return next(u for u in test_users if 'Administrator' in [r.name for r in u.roles])

@pytest.fixture
def test_csr_user(test_users):
    """Get the CSR test user."""
    return next(u for u in test_users if 'Customer Service Representative' in [r.name for r in u.roles] and u.is_active)

@pytest.fixture
def test_lst_user(test_users):
    """Get the LST test user."""
    return next(u for u in test_users if 'Line Service Technician' in [r.name for r in u.roles])

@pytest.fixture
def test_inactive_user(test_users):
    """Get the inactive test user."""
    return next(u for u in test_users if not u.is_active)

@pytest.fixture(scope='session')
def auth_headers(app, test_users):
    """Generate authentication headers for test users."""
    headers = {}
    with app.app_context():
        for user in test_users:
            if user.is_active:  # Only generate tokens for active users
                token = jwt.encode(
                    {
                        'user_id': user.id,
                        'username': user.username,
                        'roles': [role.name for role in user.roles],
                        'is_active': user.is_active,
                        'exp': datetime.utcnow() + timedelta(days=1),
                        'iat': datetime.utcnow()
                    },
                    app.config['JWT_SECRET_KEY'],
                    algorithm='HS256'
                )
                role_key = user.roles[0].name.lower().split()[0]  # Get first word of role name in lowercase
                headers[role_key] = {'Authorization': f'Bearer {token}'}
    return headers

@pytest.fixture(scope='session')
def test_customer(db_session):
    """Create a test customer."""
    customer = Customer(
        name='Test Customer',
        email='customer@test.com',
        phone='1234567890'
    )
    db_session.add(customer)
    db_session.commit()
    return customer

@pytest.fixture(scope='session')
def test_aircraft(db_session, test_customer):
    """Create a test aircraft."""
    aircraft = Aircraft(
        tail_number='N12345',
        aircraft_type='Jet',
        fuel_type='Jet-A',
        customer_id=test_customer.id
    )
    db_session.add(aircraft)
    db_session.commit()
    return aircraft

@pytest.fixture(scope='session')
def test_fuel_truck(db_session):
    """Create a test fuel truck."""
    truck = FuelTruck(
        truck_number='FT001',
        fuel_type='Jet-A',
        capacity=5000.0,
        current_fuel_level=4000.0,
        is_active=True
    )
    db_session.add(truck)
    db_session.commit()
    return truck

@pytest.fixture
def test_fuel_order(db_session, test_aircraft, test_fuel_truck, test_lst_user):
    """Create a test fuel order."""
    order = FuelOrder(
        aircraft=test_aircraft,
        fuel_truck=test_fuel_truck,
        assigned_lst=test_lst_user,
        requested_amount=1000.0,
        location_on_ramp='Test Location',
        status='pending'
    )
    db_session.add(order)
    db_session.commit()
    return order

@pytest.fixture(scope='function')
def runner(app):
    """Create a test CLI runner."""
    return app.test_cli_runner()
</file>

<file path="tests/test_admin_permissions.py">
"""Tests for the permission listing API endpoint."""

import pytest
from flask import json
from src.models.permission import Permission

def test_get_permissions(client, auth_headers, test_permissions):
    """Test GET /api/admin/permissions endpoint."""
    # Test unauthorized access
    response = client.get('/api/admin/permissions')
    assert response.status_code == 401, "Unauthorized request should be rejected"

    # Test forbidden access (LST)
    response = client.get('/api/admin/permissions', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access"

    # Test successful retrieval (Admin)
    response = client.get('/api/admin/permissions', headers=auth_headers['admin'])
    assert response.status_code == 200, "Admin should have access"
    data = json.loads(response.data)
    assert 'permissions' in data, "Response should contain permissions"
    
    # Verify permission list format
    permissions = data['permissions']
    for permission in permissions:
        assert 'id' in permission
        assert 'name' in permission
        assert 'description' in permission

    # Verify all test permissions are present
    permission_names = [perm['name'] for perm in permissions]
    for perm_name in test_permissions:
        assert perm_name in permission_names, f"Permission {perm_name} should be present"

    # Test access with CSR role (should be denied if VIEW_PERMISSIONS is admin-only)
    response = client.get('/api/admin/permissions', headers=auth_headers['csr'])
    assert response.status_code == 403, "CSR should be denied access to permissions list"

def test_get_permissions_csr_access(client, auth_headers):
    """Test CSR access to permissions endpoint (should be allowed VIEW_PERMISSIONS)."""
    response = client.get('/api/admin/permissions', headers=auth_headers['csr'])
    assert response.status_code == 200, "CSR should have access with VIEW_PERMISSIONS"

def test_get_permissions_response_format(client, auth_headers):
    """Test the format of the permissions response."""
    response = client.get('/api/admin/permissions', headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Check response structure
    assert 'permissions' in data
    assert isinstance(data['permissions'], list)
    
    # Check permission object structure
    for permission in data['permissions']:
        assert 'id' in permission
        assert 'name' in permission
        assert isinstance(permission['id'], int)
        assert isinstance(permission['name'], str)

def test_get_permissions_empty_db(client, auth_headers, db_session):
    """Test permissions endpoint with empty database."""
    # Delete all permissions
    Permission.query.delete()
    db_session.commit()
    
    response = client.get('/api/admin/permissions', headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 0, "Empty database should return empty list"
</file>

<file path="tests/test_admin_roles.py">
"""Tests for the role management API endpoints."""

import pytest
from flask import json
from src.models.role import Role
from src.models.permission import Permission

def test_get_roles(client, auth_headers, test_roles):
    """Test GET /api/admin/roles endpoint."""
    # Test unauthorized access
    response = client.get('/api/admin/roles')
    assert response.status_code == 401, "Unauthorized request should be rejected"

    # Test forbidden access (LST)
    response = client.get('/api/admin/roles', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access"

    # Test successful retrieval (Admin)
    response = client.get('/api/admin/roles', headers=auth_headers['admin'])
    assert response.status_code == 200, "Admin should have access"
    data = json.loads(response.data)
    assert 'roles' in data, "Response should contain roles"
    
    # Verify role list format
    roles = data['roles']
    for role in roles:
        assert 'id' in role
        assert 'name' in role
        assert 'description' in role
        assert 'created_at' in role

    # Verify all test roles are present
    role_names = [role['name'] for role in roles]
    assert 'System Administrator' in role_names
    assert 'Customer Service Representative' in role_names
    assert 'Line Service Technician' in role_names

def test_create_role(client, auth_headers, test_permissions):
    """Test POST /api/admin/roles endpoint."""
    new_role_data = {
        'name': 'Test Role',
        'description': 'A test role'
    }

    # Test unauthorized
    response = client.post('/api/admin/roles',
                          json=new_role_data)
    assert response.status_code == 401

    # Test forbidden (CSR)
    response = client.post('/api/admin/roles',
                          headers=auth_headers['csr'],
                          json=new_role_data)
    assert response.status_code == 403

    # Test successful creation (Admin)
    response = client.post('/api/admin/roles',
                          headers=auth_headers['admin'],
                          json=new_role_data)
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['role']['name'] == 'Test Role'
    assert data['role']['description'] == 'A test role'

    # Test duplicate name
    response = client.post('/api/admin/roles',
                          headers=auth_headers['admin'],
                          json=new_role_data)
    assert response.status_code == 409

def test_get_role(client, auth_headers, test_roles):
    """Test GET /api/admin/roles/<id> endpoint."""
    role_id = test_roles['csr'].id

    # Test unauthorized
    response = client.get(f'/api/admin/roles/{role_id}')
    assert response.status_code == 401

    # Test forbidden (LST)
    response = client.get(f'/api/admin/roles/{role_id}',
                         headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful retrieval (Admin)
    response = client.get(f'/api/admin/roles/{role_id}',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['role']['name'] == 'Customer Service Representative'

    # Test non-existent role
    response = client.get('/api/admin/roles/99999',
                         headers=auth_headers['admin'])
    assert response.status_code == 404

def test_update_role(client, auth_headers, db_session):
    """Test PATCH /api/admin/roles/<id> endpoint."""
    # Create a role to update
    role = Role(name='Role To Update')
    db_session.add(role)
    db_session.commit()
    role_id = role.id

    update_data = {
        'name': 'Updated Role',
        'description': 'Updated description'
    }

    # Test unauthorized
    response = client.patch(f'/api/admin/roles/{role_id}',
                          json=update_data)
    assert response.status_code == 401

    # Test forbidden (CSR)
    response = client.patch(f'/api/admin/roles/{role_id}',
                          headers=auth_headers['csr'],
                          json=update_data)
    assert response.status_code == 403

    # Test successful update (Admin)
    response = client.patch(f'/api/admin/roles/{role_id}',
                          headers=auth_headers['admin'],
                          json=update_data)
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['role']['name'] == 'Updated Role'
    assert data['role']['description'] == 'Updated description'

def test_delete_role(client, auth_headers, db_session, test_users):
    """Test DELETE /api/admin/roles/<id> endpoint."""
    # Create a role to delete
    role = Role(name='Role To Delete')
    db_session.add(role)
    db_session.commit()
    role_id = role.id

    # Test unauthorized
    response = client.delete(f'/api/admin/roles/{role_id}')
    assert response.status_code == 401

    # Test forbidden (CSR)
    response = client.delete(f'/api/admin/roles/{role_id}',
                           headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test successful deletion (Admin)
    response = client.delete(f'/api/admin/roles/{role_id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 200

    # Test deleting non-existent role
    response = client.delete('/api/admin/roles/99999',
                           headers=auth_headers['admin'])
    assert response.status_code == 404

    # Test deleting role assigned to users
    admin_role_id = test_users['admin'].roles[0].id
    response = client.delete(f'/api/admin/roles/{admin_role_id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 409

def test_role_permissions(client, auth_headers, db_session, test_permissions):
    """Test role permission assignment endpoints."""
    # Create a test role
    role = Role(name='Permission Test Role')
    db_session.add(role)
    db_session.commit()
    role_id = role.id

    # Get initial permissions
    response = client.get(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 0

    # Assign a permission
    perm = Permission.query.filter_by(name='CREATE_ORDER').first()
    response = client.post(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'],
                         json={'permission_id': perm.id})
    assert response.status_code == 200

    # Verify permission was assigned
    response = client.get(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 1
    assert data['permissions'][0]['name'] == 'CREATE_ORDER'

    # Remove the permission
    response = client.delete(f'/api/admin/roles/{role_id}/permissions/{perm.id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 200

    # Verify permission was removed
    response = client.get(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert len(data['permissions']) == 0

    # Test assigning invalid permission ID
    response = client.post(f'/api/admin/roles/{role_id}/permissions',
                         headers=auth_headers['admin'],
                         json={'permission_id': 99999})
    assert response.status_code == 400
</file>

<file path="tests/test_admin_users.py">
"""Tests for the user management API endpoints."""

import pytest
from flask import json
from src.models.user import User

def test_get_users(client, auth_headers, test_users, test_roles):
    """Test GET /api/admin/users endpoint."""
    # Test unauthorized access
    response = client.get('/api/admin/users/')
    assert response.status_code == 401, "Unauthorized request should be rejected"

    # Test forbidden access (LST)
    response = client.get('/api/admin/users/', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access"

    # Test successful retrieval with VIEW_USERS (CSR)
    response = client.get('/api/admin/users/', headers=auth_headers['csr'])
    assert response.status_code == 200, "CSR should have access with VIEW_USERS"
    data = json.loads(response.data)
    assert 'users' in data, "Response should contain users"
    
    # Verify user list format
    users = data['users']
    for user in users:
        assert 'id' in user
        assert 'username' in user
        assert 'email' in user
        assert 'roles' in user
        assert isinstance(user['roles'], list)
        for role in user['roles']:
            assert 'id' in role
            assert 'name' in role

    # Verify all test users are present
    usernames = [user['username'] for user in users]
    assert 'testadmin' in usernames
    assert 'testcsr' in usernames
    assert 'testlst' in usernames

def test_create_user(client, auth_headers, test_roles):
    """Test POST /api/admin/users endpoint."""
    new_user_data = {
        'username': 'newuser',
        'email': 'newuser@test.com',
        'password': 'testpass123',
        'name': 'New User',
        'role_ids': [test_roles['csr'].id]
    }

    # Test unauthorized
    response = client.post('/api/admin/users/',
                          json=new_user_data)
    assert response.status_code == 401

    # Test forbidden (CSR - has VIEW_USERS but not MANAGE_USERS)
    response = client.post('/api/admin/users/',
                          headers=auth_headers['csr'],
                          json=new_user_data)
    assert response.status_code == 403

    # Test successful creation (Admin)
    response = client.post('/api/admin/users/',
                          headers=auth_headers['admin'],
                          json=new_user_data)
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['user']['username'] == 'newuser'
    assert data['user']['email'] == 'newuser@test.com'
    assert len(data['user']['roles']) == 1
    assert data['user']['roles'][0]['name'] == 'Customer Service Representative'

    # Test duplicate username
    response = client.post('/api/admin/users/',
                          headers=auth_headers['admin'],
                          json=new_user_data)
    assert response.status_code == 409

    # Test invalid role ID
    invalid_user = new_user_data.copy()
    invalid_user['username'] = 'invaliduser'
    invalid_user['email'] = 'invalid@test.com'
    invalid_user['role_ids'] = [99999]
    response = client.post('/api/admin/users/',
                          headers=auth_headers['admin'],
                          json=invalid_user)
    assert response.status_code == 400

def test_get_user(client, auth_headers, test_users):
    """Test GET /api/admin/users/<id> endpoint."""
    user_id = test_users['csr'].id

    # Test unauthorized
    response = client.get(f'/api/admin/users/{user_id}')
    assert response.status_code == 401

    # Test successful retrieval with VIEW_USERS (CSR)
    response = client.get(f'/api/admin/users/{user_id}',
                         headers=auth_headers['csr'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['user']['username'] == 'testcsr'
    assert 'roles' in data['user']
    assert len(data['user']['roles']) == 1
    assert data['user']['roles'][0]['name'] == 'Customer Service Representative'

    # Test non-existent user
    response = client.get('/api/admin/users/99999',
                         headers=auth_headers['admin'])
    assert response.status_code == 404

def test_update_user(client, auth_headers, test_users, test_roles):
    """Test PATCH /api/admin/users/<id> endpoint."""
    user = User(username='updateuser', email='update@test.com', name='Update User')
    user.set_password('testpass')
    user.roles.append(test_roles['lst'])
    db_session = test_roles['lst'].query.session
    db_session.add(user)
    db_session.commit()
    user_id = user.id

    update_data = {
        'name': 'Updated Name',
        'role_ids': [test_roles['csr'].id]
    }

    # Test unauthorized
    response = client.patch(f'/api/admin/users/{user_id}',
                          json=update_data)
    assert response.status_code == 401

    # Test forbidden (CSR - has VIEW_USERS but not MANAGE_USERS)
    response = client.patch(f'/api/admin/users/{user_id}',
                          headers=auth_headers['csr'],
                          json=update_data)
    assert response.status_code == 403

    # Test successful update (Admin)
    response = client.patch(f'/api/admin/users/{user_id}',
                          headers=auth_headers['admin'],
                          json=update_data)
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['user']['name'] == 'Updated Name'
    assert len(data['user']['roles']) == 1
    assert data['user']['roles'][0]['name'] == 'Customer Service Representative'

    # Test invalid role ID
    invalid_update = {'role_ids': [99999]}
    response = client.patch(f'/api/admin/users/{user_id}',
                          headers=auth_headers['admin'],
                          json=invalid_update)
    assert response.status_code == 400

def test_delete_user(client, auth_headers, test_users, db_session):
    """Test DELETE /api/admin/users/<id> endpoint."""
    # Create a user to delete
    user = User(username='deleteuser', email='delete@test.com', name='Delete User')
    user.set_password('testpass')
    db_session.add(user)
    db_session.commit()
    user_id = user.id

    # Test unauthorized
    response = client.delete(f'/api/admin/users/{user_id}')
    assert response.status_code == 401

    # Test forbidden (CSR - has VIEW_USERS but not MANAGE_USERS)
    response = client.delete(f'/api/admin/users/{user_id}',
                           headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test successful deletion (Admin)
    response = client.delete(f'/api/admin/users/{user_id}',
                           headers=auth_headers['admin'])
    assert response.status_code == 200

    # Verify user is soft deleted
    user = User.query.get(user_id)
    assert user is not None, "User should still exist (soft delete)"
    assert not user.is_active, "User should be inactive"

    # Test deleting non-existent user
    response = client.delete('/api/admin/users/99999',
                           headers=auth_headers['admin'])
    assert response.status_code == 404
</file>

<file path="tests/test_auth.py">
"""Tests for authentication endpoints."""

import pytest
import json
from src.models.user import User
from flask import g
from src.models.role import Role
from src.models.permission import Permission
from src.routes.auth_routes import reset_rate_limits

@pytest.fixture(autouse=True)
def reset_rate_limiting():
    """Reset rate limiting between tests."""
    reset_rate_limits()
    yield

# === Registration Tests (/auth/register) ===

def test_register_success(client, db_session, test_roles):
    """ Test successful user registration """
    response = client.post('/api/auth/register', json={
        'username': 'newuser',
        'name': 'New User',
        'email': 'newuser@test.com',
        'password': 'password123'
    })
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['message'] == 'User registered successfully'
    assert 'user' in data
    assert data['user']['email'] == 'newuser@test.com'
    assert data['user']['name'] == 'New User'
    
    # Verify user exists in DB with CSR role
    user = User.query.filter_by(email='newuser@test.com').first()
    assert user is not None
    assert user.name == 'New User'
    assert user.check_password('password123')  # Verify password hashing
    
    # Verify user has CSR role
    assert len(user.roles) == 1
    assert user.roles[0].name == 'Customer Service Representative'
    
    # Verify CSR permissions
    assert user.has_permission('CREATE_ORDER')
    assert user.has_permission('VIEW_ORDERS')
    assert user.has_permission('MANAGE_ORDERS')
    assert user.has_permission('VIEW_USERS')
    assert user.has_permission('VIEW_AIRCRAFT')
    assert user.has_permission('VIEW_CUSTOMERS')
    assert user.has_permission('VIEW_TRUCKS')
    assert not user.has_permission('MANAGE_ROLES')
    assert not user.has_permission('MANAGE_USERS')

def test_register_invalid_data(client):
    """ Test registration with invalid data """
    # Missing required fields
    response = client.post('/api/auth/register', json={
        'name': 'Invalid User'
    })
    assert response.status_code == 400
    assert json.loads(response.data)['error'] == 'Invalid request data'

def test_register_duplicate_email(client, test_users):
    """ Test registration with duplicate email """
    response = client.post('/api/auth/register', json={
        'username': 'duplicate',
        'name': 'Duplicate User',
        'email': 'admin@test.com',  # Using existing email from test_users
        'password': 'password123'
    })
    assert response.status_code == 409
    assert json.loads(response.data)['error'] == 'Email already registered'

# === Login Tests (/auth/login) ===

def test_login_success(client, test_users):
    """ Test successful login """
    response = client.post('/api/auth/login', json={
        'email': 'admin@test.com',
        'password': 'adminpass'
    })
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'access_token' in data
    assert data['token_type'] == 'Bearer'
    
    # Verify user permissions after login
    user = User.query.filter_by(email='admin@test.com').first()
    assert user.has_permission('CREATE_ORDER')
    assert user.has_permission('VIEW_ORDERS')
    assert user.has_permission('MANAGE_ORDERS')
    assert user.has_permission('VIEW_USERS')
    assert user.has_permission('VIEW_AIRCRAFT')
    assert user.has_permission('VIEW_CUSTOMERS')
    assert user.has_permission('VIEW_TRUCKS')
    assert not user.has_permission('MANAGE_ROLES')
    assert not user.has_permission('MANAGE_USERS')

def test_login_invalid_credentials(client, test_users):
    """ Test login with invalid credentials """
    response = client.post('/api/auth/login', json={
        'email': 'admin@test.com',
        'password': 'wrongpass'
    })
    assert response.status_code == 401
    assert json.loads(response.data)['error'] == 'Invalid credentials'

def test_login_inactive_user(client, test_users):
    """ Test login with inactive user """
    response = client.post('/api/auth/login', json={
        'email': 'inactive@test.com',
        'password': 'inactivepass'
    })
    assert response.status_code == 403
    assert json.loads(response.data)['error'] == 'Account is inactive'

def test_login_rate_limiting(client, test_users):
    """ Test login rate limiting """
    # Make 6 login attempts (exceeding the limit of 5)
    for i in range(6):
        response = client.post('/api/auth/login', json={
            'email': 'admin@test.com',
            'password': 'wrongpass'
        })
        if i < 5:
            assert response.status_code in [401, 403]  # Either invalid credentials or rate limit
        else:
            assert response.status_code == 429
            data = json.loads(response.data)
            assert 'error' in data
            assert 'retry_after_seconds' in data

def test_rate_limit_window_expiration(client, test_users):
    """ Test rate limit window expiration """
    # This test might need to be adjusted or skipped in CI environments
    # where time manipulation is not possible
    pass

def test_rate_limit_per_ip(client, test_users):
    """ Test rate limiting is per IP address """
    # This test might need to be adjusted based on how you simulate different IPs
    pass

def test_login_role_permissions(client, test_users, auth_headers):
    """ Test that login response includes correct role permissions """
    response = client.post('/api/auth/login', json={
        'email': 'admin@test.com',
        'password': 'adminpass'
    })
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'access_token' in data
    
    # Verify token contains role information
    import jwt
    token = data['access_token']
    decoded = jwt.decode(token, verify=False)  # We're not verifying the signature here
    assert 'roles' in decoded
    assert 'Administrator' in decoded['roles']

def test_permission_inheritance(client, db_session, test_users):
    """Test that admin role inherits all permissions."""
    admin = test_users['admin']
    csr = test_users['csr']
    lst = test_users['lst']
    
    # Admin should have all permissions
    assert admin.has_permission('MANAGE_ROLES')
    assert admin.has_permission('MANAGE_USERS')
    assert admin.has_permission('MANAGE_ORDERS')
    assert admin.has_permission('MANAGE_AIRCRAFT')
    assert admin.has_permission('MANAGE_CUSTOMERS')
    assert admin.has_permission('MANAGE_TRUCKS')
    
    # CSR should have subset of permissions
    assert csr.has_permission('CREATE_ORDER')
    assert csr.has_permission('MANAGE_ORDERS')
    assert csr.has_permission('VIEW_USERS')
    assert not csr.has_permission('MANAGE_ROLES')
    assert not csr.has_permission('MANAGE_USERS')
    
    # LST should have minimal permissions
    assert lst.has_permission('VIEW_ORDERS')
    assert lst.has_permission('CREATE_ORDER')
    assert lst.has_permission('VIEW_AIRCRAFT')
    assert lst.has_permission('VIEW_TRUCKS')
    assert not lst.has_permission('MANAGE_ORDERS')
    assert not lst.has_permission('MANAGE_ROLES')
    assert not lst.has_permission('MANAGE_USERS')

def test_permission_caching(client, db_session, test_users, app):
    """Test that permission checks are properly cached within a request."""
    from flask import g
    
    with app.test_request_context():
        user = test_users['csr']
        
        # First check should cache the result
        assert user.has_permission('CREATE_ORDER')
        cache_key = f'user_{user.id}_perm_CREATE_ORDER'
        assert hasattr(g, '_permission_cache')
        assert cache_key in g._permission_cache
        assert g._permission_cache[cache_key] is True

def test_permission_cache_invalidation(client, db_session, test_users, app):
    """Test that permission cache is request-scoped."""
    from flask import g
    
    user = test_users['csr']
    
    # Check permission in first request
    with app.test_request_context():
        assert not hasattr(g, '_permission_cache')  # Should not exist yet
        assert user.has_permission('CREATE_ORDER')
        cache_key = f'user_{user.id}_perm_CREATE_ORDER'
        assert hasattr(g, '_permission_cache')
        assert cache_key in g._permission_cache
        assert g._permission_cache[cache_key] is True
        
    # Check permission in new request (should not have cached value)
    with app.test_request_context():
        assert not hasattr(g, '_permission_cache')  # New request, no cache
        assert user.has_permission('CREATE_ORDER')  # Should recalculate
        assert hasattr(g, '_permission_cache')  # Cache should be created
        cache_key = f'user_{user.id}_perm_CREATE_ORDER'
        assert cache_key in g._permission_cache  # Permission should be cached

def test_inactive_user_permissions(client, db_session, test_inactive_user):
    """Test that inactive users have no permissions regardless of roles."""
    user = test_inactive_user
    assert not user.is_active
    assert not user.has_permission('VIEW_ORDERS')
    assert not user.has_permission('CREATE_ORDER')

def test_permission_check_performance(client, db_session, test_users, benchmark):
    """Test the performance of permission checking with caching."""
    user = test_users['csr']
    
    def check_permission():
        return user.has_permission('CREATE_ORDER')
    
    # Benchmark permission check
    result = benchmark(check_permission)
    assert result is True
</file>

<file path="tests/test_fuel_order_api.py">
import os
os.environ.pop('DATABASE_URL', None)
os.environ.pop('TEST_DATABASE_URL', None)

import pytest
from flask import Flask
from src import create_app, db

@pytest.fixture
def app():
    app = create_app('testing')
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

def test_create_and_get_fuel_order(app):
    with app.app_context():
        client = app.test_client()
        # Register a test user
        client.post('/api/auth/register', json={
            'email': 'testuser@example.com',
            'password': 'testpassword'
        })
        # Set correct role
        from src.models.user import User, UserRole
        from src.extensions import db
        user = User.query.filter_by(email='testuser@example.com').first()
        assert user is not None, 'User should exist after registration.'
        user.role = UserRole.CSR
        db.session.add(user)
        db.session.commit()
        # Log in to get token
        resp = client.post('/auth/login', json={
            'email': 'testuser@example.com',
            'password': 'testpassword'
        })
        print('JWT_SECRET_KEY during login:', app.config.get('JWT_SECRET_KEY'))
        token = resp.get_json()['token']

        # Debug: print JWT secret from app config before making API call
        print('JWT_SECRET_KEY during protected endpoint:', app.config.get('JWT_SECRET_KEY'))
        # Create a fuel order
        resp = client.post('/fuel-orders/', json={
            'tail_number': 'N12345',
            'fuel_type': 'Jet-A',
            'assigned_lst_user_id': 1,
            'assigned_truck_id': 1,
            'requested_amount': 100.0,
            'location_on_ramp': 'Ramp A'
        }, headers={'Authorization': f'Bearer {token}'})
        assert resp.status_code == 201

        # Get fuel orders (if implemented)
        # resp = client.get('/fuel-orders/', headers={'Authorization': f'Bearer {token}'})
        # data = resp.get_json()
        # assert any(order['requested_amount'] == 100.0 for order in data.get('orders', []))

def test_create_fuel_order_unauthorized(client):
    resp = client.post('/api/fuel-orders/', json={
        'tail_number': 'N12345',
        'fuel_type': 'Jet-A',
        'assigned_lst_user_id': 1,
        'assigned_truck_id': 1,
        'requested_amount': 100.0,
        'location_on_ramp': 'Ramp A'
    })
    assert resp.status_code == 401
</file>

<file path="tests/test_fuel_orders.py">
import pytest
import json
from decimal import Decimal
from src.models import FuelOrder, FuelOrderStatus
from src.extensions import db

# === Fuel Order Creation Tests (POST /api/fuel-orders) ===

def test_create_fuel_order_success_csr(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test successful fuel order creation by a user with CREATE_ORDER permission """
    csr_headers = auth_headers['csr']  # CSR has CREATE_ORDER permission
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number

    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
        "location_on_ramp": "Hangar 1",
        "requested_amount": "100.50",  # Send as string, backend handles Decimal
        "additive_requested": True,
        "csr_notes": "Test order notes"
        # customer_id is optional
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)

    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Fuel order created successfully'
    assert 'fuel_order' in data
    order_data = data['fuel_order']
    assert order_data['status'] == FuelOrderStatus.DISPATCHED.value
    assert order_data['tail_number'] == tail_number
    assert order_data['assigned_lst_user_id'] == lst_user_id
    assert order_data['assigned_truck_id'] == truck_id
    assert order_data['requested_amount'] == "100.50"  # Check string representation
    assert order_data['additive_requested'] is True
    assert order_data['csr_notes'] == "Test order notes"
    assert order_data['dispatch_timestamp'] is not None

    # Verify DB state
    order_in_db = FuelOrder.query.get(order_data['id'])
    assert order_in_db is not None
    assert order_in_db.status == FuelOrderStatus.DISPATCHED
    assert order_in_db.requested_amount == Decimal("100.50")  # Check Decimal in DB

def test_create_fuel_order_success_admin(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test successful fuel order creation by an admin (who has CREATE_ORDER permission) """
    admin_headers = auth_headers['admin']  # Admin has all permissions including CREATE_ORDER
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number

    payload = {  # Minimal required payload
        "tail_number": tail_number,
        "fuel_type": "100LL",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=admin_headers, json=payload)
    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Fuel order created successfully'
    assert 'fuel_order' in data
    order_data = data['fuel_order']
    assert order_data['status'] == FuelOrderStatus.DISPATCHED.value
    assert order_data['tail_number'] == tail_number
    assert order_data['assigned_lst_user_id'] == lst_user_id
    assert order_data['assigned_truck_id'] == truck_id

def test_create_fuel_order_success_lst(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test successful fuel order creation by an LST (who now has CREATE_ORDER permission) """
    lst_headers = auth_headers['lst']  # LST now has CREATE_ORDER permission
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number

    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=lst_headers, json=payload)
    assert response.status_code == 201
    data = response.get_json()
    assert 'fuel_order' in data
    assert data['message'] == 'Fuel order created successfully'

def test_create_fuel_order_unauthenticated(client, db_session, test_users, test_fuel_truck, test_aircraft):
    """ Test creating a fuel order without authentication """
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', json=payload)  # No headers
    assert response.status_code == 401  # Unauthorized
    data = response.get_json()
    assert 'error' in data
    assert "Authentication token is missing" in data['error']

def test_create_fuel_order_missing_required_fields(client, db_session, auth_headers, test_aircraft):
    """ Test creating order with missing required fields """
    csr_headers = auth_headers['csr']
    payload = {
        "tail_number": test_aircraft.tail_number
        # Missing fuel_type, assigned_lst_user_id, assigned_truck_id
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Missing required fields" in data['error']

def test_create_fuel_order_invalid_lst_id(client, db_session, auth_headers, test_fuel_truck, test_aircraft):
    """ Test creating order with a non-existent LST user ID """
    csr_headers = auth_headers['csr']
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": 99999,  # Non-existent ID
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request (Service validation)
    data = response.get_json()
    assert 'error' in data
    assert "Invalid or inactive LST user ID" in data['error']

def test_create_fuel_order_invalid_truck_id(client, db_session, auth_headers, test_users, test_aircraft):
    """ Test creating order with a non-existent Truck ID """
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": 99999,  # Non-existent ID
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Invalid or inactive Fuel Truck ID" in data['error']

def test_create_fuel_order_invalid_aircraft_id(client, db_session, auth_headers, test_users, test_fuel_truck):
    """ Test creating order with a non-existent Aircraft tail number """
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    payload = {
        "tail_number": "N999XX",  # Non-existent tail number
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Aircraft with tail number N999XX not found" in data['error']

def test_create_fuel_order_invalid_amount(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """ Test creating order with invalid requested amount """
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
        "requested_amount": "invalid",  # Invalid amount
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "Invalid requested amount" in data['error']

def test_order_status_update_permissions(client, db_session, auth_headers, test_users, test_fuel_truck, test_aircraft):
    """Test order status updates with different user permissions."""
    # Create an order first
    csr_headers = auth_headers['csr']
    lst_user_id = test_users['lst'].id
    truck_id = test_fuel_truck.id
    tail_number = test_aircraft.tail_number
    
    # Create order
    payload = {
        "tail_number": tail_number,
        "fuel_type": "Jet A",
        "assigned_lst_user_id": lst_user_id,
        "assigned_truck_id": truck_id,
    }
    response = client.post('/api/fuel-orders', headers=csr_headers, json=payload)
    assert response.status_code == 201
    order_id = response.get_json()['fuel_order']['id']
    
    # Test LST can update status (has MANAGE_ORDERS permission)
    lst_headers = auth_headers['lst']
    update_payload = {"status": "IN_PROGRESS"}
    response = client.patch(f'/api/fuel-orders/{order_id}/status',
                          headers=lst_headers,
                          json=update_payload)
    assert response.status_code == 200
    
    # Test CSR can update status (has MANAGE_ORDERS permission)
    update_payload = {"status": "COMPLETED"}
    response = client.patch(f'/api/fuel-orders/{order_id}/status',
                          headers=csr_headers,
                          json=update_payload)
    assert response.status_code == 200
    
    # Test Admin can update status (has all permissions)
    admin_headers = auth_headers['admin']
    update_payload = {"status": "CANCELLED"}
    response = client.patch(f'/api/fuel-orders/{order_id}/status',
                          headers=admin_headers,
                          json=update_payload)
    assert response.status_code == 200
</file>

<file path="tests/test_fuel_trucks.py">
import pytest
from decimal import Decimal
from src.models import FuelTruck

def test_create_fuel_truck_success_admin(client, db_session, auth_headers):
    """Test successful fuel truck creation by an authenticated Admin"""
    admin_headers = auth_headers['admin']
    payload = {
        "truck_number": "TRUCK002",
        "fuel_type": "Jet A",
        "capacity": "5000.00",
        "current_meter_reading": "100.00"
    }
    response = client.post('/api/fuel-trucks/', headers=admin_headers, json=payload)
    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Fuel truck created successfully'
    assert 'fuel_truck' in data
    truck_data = data['fuel_truck']
    assert truck_data['truck_number'] == "TRUCK002"
    assert truck_data['fuel_type'] == "Jet A"
    assert float(truck_data['capacity']) == 5000.00
    assert float(truck_data['current_meter_reading']) == 100.00
    assert truck_data['is_active'] is True

def test_create_fuel_truck_forbidden_csr(client, db_session, auth_headers):
    """Test that a CSR cannot create a fuel truck"""
    csr_headers = auth_headers['csr']
    payload = {
        "truck_number": "TRUCK003",
        "fuel_type": "Jet A",
        "capacity": "5000.00"
    }
    response = client.post('/api/fuel-trucks/', headers=csr_headers, json=payload)
    assert response.status_code == 403  # Forbidden
    data = response.get_json()
    assert 'error' in data
    assert "Insufficient permissions" in data['error']

def test_create_fuel_truck_duplicate_number(client, db_session, auth_headers, test_fuel_truck):
    """Test creating a truck with a duplicate truck number"""
    admin_headers = auth_headers['admin']
    payload = {
        "truck_number": test_fuel_truck.truck_number,  # Using existing truck number
        "fuel_type": "Jet A",
        "capacity": "5000.00"
    }
    response = client.post('/api/fuel-trucks/', headers=admin_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data
    assert "already exists" in data['error']

def test_create_fuel_truck_invalid_data(client, db_session, auth_headers):
    """Test creating a truck with invalid data"""
    admin_headers = auth_headers['admin']
    # Missing required fields
    payload = {
        "truck_number": "TRUCK004"
        # Missing fuel_type and capacity
    }
    response = client.post('/api/fuel-trucks/', headers=admin_headers, json=payload)
    assert response.status_code == 400  # Bad Request
    data = response.get_json()
    assert 'error' in data

def test_get_fuel_trucks_success(client, db_session, auth_headers, test_fuel_truck):
    """Test successful retrieval of fuel trucks"""
    csr_headers = auth_headers['csr']
    response = client.get('/api/fuel-trucks/', headers=csr_headers)
    assert response.status_code == 200
    data = response.get_json()
    assert 'fuel_trucks' in data
    assert len(data['fuel_trucks']) >= 1
    assert any(truck['truck_number'] == test_fuel_truck.truck_number for truck in data['fuel_trucks'])

def test_get_fuel_trucks_filter_active(client, db_session, auth_headers, test_fuel_truck):
    """Test filtering fuel trucks by active status"""
    csr_headers = auth_headers['csr']
    # Create an inactive truck
    inactive_truck = FuelTruck(
        truck_number='INACTIVE001',
        fuel_type='Jet A',
        capacity=5000.0,
        is_active=False
    )
    db_session.add(inactive_truck)
    db_session.commit()

    # Test filtering active trucks
    response = client.get('/api/fuel-trucks/?is_active=true', headers=csr_headers)
    assert response.status_code == 200
    data = response.get_json()
    assert all(truck['is_active'] for truck in data['fuel_trucks'])

    # Test filtering inactive trucks
    response = client.get('/api/fuel-trucks/?is_active=false', headers=csr_headers)
    assert response.status_code == 200
    data = response.get_json()
    assert all(not truck['is_active'] for truck in data['fuel_trucks'])
</file>

<file path="tests/test_models.py">
import pytest
from datetime import datetime
from src.models.fuel_order import FuelOrder, FuelOrderStatus

def test_create_fuel_order(db_session, test_aircraft, test_customer, test_user, test_fuel_truck):
    """Test creating a new fuel order."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        customer_id=test_customer.id,
        fuel_type='Jet A',
        additive_requested=False,
        requested_amount=1000.0,
        assigned_lst_user_id=test_user.id,
        assigned_truck_id=test_fuel_truck.id,
        location_on_ramp='Gate A1'
    )
    
    db_session.add(fuel_order)
    db_session.commit()
    
    assert fuel_order.id is not None
    assert fuel_order.status == FuelOrderStatus.DISPATCHED
    assert fuel_order.created_at is not None

def test_fuel_order_status_transitions(db_session, test_aircraft):
    """Test fuel order status transitions."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        fuel_type='Jet A',
        requested_amount=1000.0
    )
    db_session.add(fuel_order)
    db_session.commit()
    
    # Test initial status
    assert fuel_order.status == FuelOrderStatus.DISPATCHED
    assert fuel_order.dispatch_timestamp is None
    
    # Test acknowledge transition
    fuel_order.status = FuelOrderStatus.ACKNOWLEDGED
    fuel_order.acknowledge_timestamp = datetime.utcnow()
    db_session.commit()
    assert fuel_order.status == FuelOrderStatus.ACKNOWLEDGED
    assert fuel_order.acknowledge_timestamp is not None
    
    # Test en route transition
    fuel_order.status = FuelOrderStatus.EN_ROUTE
    fuel_order.en_route_timestamp = datetime.utcnow()
    db_session.commit()
    assert fuel_order.status == FuelOrderStatus.EN_ROUTE
    assert fuel_order.en_route_timestamp is not None

def test_fuel_order_relationships(db_session, test_aircraft, test_customer, test_user, test_fuel_truck):
    """Test fuel order relationships with other models."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        customer_id=test_customer.id,
        fuel_type='Jet A',
        requested_amount=1000.0,
        assigned_lst_user_id=test_user.id,
        assigned_truck_id=test_fuel_truck.id
    )
    
    db_session.add(fuel_order)
    db_session.commit()
    
    # Test relationships
    assert fuel_order.aircraft.tail_number == test_aircraft.tail_number
    assert fuel_order.customer.id == test_customer.id
    assert fuel_order.assigned_lst.id == test_user.id
    assert fuel_order.assigned_truck.id == test_fuel_truck.id

def test_fuel_order_metering(db_session, test_aircraft):
    """Test fuel order metering calculations."""
    fuel_order = FuelOrder(
        tail_number=test_aircraft.tail_number,
        fuel_type='Jet A',
        requested_amount=1000.0,
        start_meter_reading=5000.0,
        end_meter_reading=6000.0
    )
    
    db_session.add(fuel_order)
    db_session.commit()
    
    # Test metering calculations
    assert fuel_order.calculated_gallons_dispensed == 1000.0
</file>

<file path="tests/test_permissions.py">
"""Tests for the permission system."""

import pytest
from flask import json
from src.models.user import User
from src.models.role import Role
from src.models.permission import Permission
from src.utils.decorators import require_permission
from flask import Blueprint, jsonify

# Create a test blueprint with protected routes
test_bp = Blueprint('test_bp', __name__)

@test_bp.route('/test-permission')
@require_permission('TEST_PERMISSION')
def test_permission_route():
    return jsonify({'message': 'success'})

def test_user_has_permission(client, db_session, test_users, test_permissions):
    """Test the user.has_permission() method."""
    # Admin should have all permissions
    admin = test_users['admin']
    for perm_name in test_permissions:
        assert admin.has_permission(perm_name), f"Admin should have {perm_name} permission"

    # CSR should have specific permissions
    csr = test_users['csr']
    assert csr.has_permission('CREATE_ORDER'), "CSR should have CREATE_ORDER permission"
    assert csr.has_permission('MANAGE_ORDERS'), "CSR should have MANAGE_ORDERS permission"
    assert csr.has_permission('VIEW_USERS'), "CSR should have VIEW_USERS permission"
    assert not csr.has_permission('MANAGE_ROLES'), "CSR should not have MANAGE_ROLES permission"

    # LST should have limited permissions
    lst = test_users['lst']
    assert lst.has_permission('VIEW_ORDERS'), "LST should have VIEW_ORDERS permission"
    assert lst.has_permission('CREATE_ORDER'), "LST should have CREATE_ORDER permission"
    assert not lst.has_permission('MANAGE_ORDERS'), "LST should not have MANAGE_ORDERS permission"
    assert not lst.has_permission('MANAGE_ROLES'), "LST should not have MANAGE_ROLES permission"

def test_permission_decorator(app, client, db_session, test_users, test_permissions):
    """Test the @require_permission decorator."""
    # Register test route
    test_perm = Permission(name='TEST_PERMISSION')
    db_session.add(test_perm)
    db_session.commit()

    # Add test permission to admin role
    admin_role = test_users['admin'].roles[0]
    admin_role.permissions.append(test_perm)
    db_session.commit()

    # Register blueprint
    app.register_blueprint(test_bp)

    # Test with admin (has permission)
    response = client.get('/test-permission', 
                         headers={'Authorization': f'Bearer {test_users["admin"].generate_token()}'})
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['message'] == 'success'

    # Test with CSR (no permission)
    response = client.get('/test-permission',
                         headers={'Authorization': f'Bearer {test_users["csr"].generate_token()}'})
    assert response.status_code == 403
    data = json.loads(response.data)
    assert 'error' in data
    assert 'Permission denied' in data['error']

    # Test with LST (no permission)
    response = client.get('/test-permission',
                         headers={'Authorization': f'Bearer {test_users["lst"].generate_token()}'})
    assert response.status_code == 403
    data = json.loads(response.data)
    assert 'error' in data
    assert 'Permission denied' in data['error']

def test_permission_inheritance(client, db_session, test_users, test_permissions):
    """Test that permissions are correctly inherited through roles."""
    # Create a new role that inherits from CSR
    parent_role = test_users['csr'].roles[0]
    child_role = Role(name='Child Role', description='Inherits from CSR')
    db_session.add(child_role)
    db_session.commit()

    # Create a user with the child role
    user = User(username='childuser', email='child@test.com', name='Child User')
    user.set_password('testpass')
    user.roles.append(child_role)
    db_session.add(user)
    db_session.commit()

    # Child role should have parent's permissions
    assert user.has_permission('CREATE_ORDER'), "User should inherit CREATE_ORDER permission"
    assert user.has_permission('MANAGE_ORDERS'), "User should inherit MANAGE_ORDERS permission"
    assert user.has_permission('VIEW_USERS'), "User should inherit VIEW_USERS permission"
    assert not user.has_permission('MANAGE_ROLES'), "User should not have MANAGE_ROLES permission"

def test_permission_caching(client, db_session, test_users, test_permissions):
    """Test that permission checks are properly cached."""
    user = test_users['csr']
    perm_name = 'CREATE_ORDER'

    # First check should cache the result
    assert user.has_permission(perm_name), "User should have CREATE_ORDER permission"

    # Remove permission but don't clear cache
    role = user.roles[0]
    perm = next(p for p in role.permissions if p.name == perm_name)
    role.permissions.remove(perm)
    db_session.commit()

    # Should still return True from cache
    assert user.has_permission(perm_name), "Cached permission should still return True"

    # Clear cache and check again
    user.clear_permission_cache()
    assert not user.has_permission(perm_name), "Permission should be False after cache clear"

    # Restore permission
    role.permissions.append(perm)
    db_session.commit()

def test_user_with_multiple_roles(db_session, test_permissions):
    """Test user with multiple roles."""
    # Create two roles with different permissions
    role1 = Role(name='Role1')
    role1.permissions.append(test_permissions['VIEW_ORDERS'])
    role2 = Role(name='Role2')
    role2.permissions.append(test_permissions['CREATE_ORDER'])
    
    db_session.add(role1)
    db_session.add(role2)
    
    # Create user with both roles
    user = User(username='multiuser', email='multi@test.com')
    user.set_password('testpass')
    user.roles.append(role1)
    user.roles.append(role2)
    
    db_session.add(user)
    db_session.commit()
    
    # User should have permissions from both roles
    assert user.has_permission('VIEW_ORDERS'), "User should have VIEW_ORDERS from Role1"
    assert user.has_permission('CREATE_ORDER'), "User should have CREATE_ORDER from Role2"
    assert not user.has_permission('MANAGE_ROLES'), "User should not have MANAGE_ROLES"

def test_require_permission_decorator(client, auth_headers):
    """Test @require_permission decorator."""
    # Test admin access (has MANAGE_ROLES)
    response = client.get('/api/admin/roles/', headers=auth_headers['admin'])
    assert response.status_code == 200, "Admin should have access to roles endpoint"

    # Test CSR access (no MANAGE_ROLES)
    response = client.get('/api/admin/roles/', headers=auth_headers['csr'])
    assert response.status_code == 403, "CSR should be denied access to roles endpoint"

    # Test LST access (no MANAGE_ROLES)
    response = client.get('/api/admin/roles/', headers=auth_headers['lst'])
    assert response.status_code == 403, "LST should be denied access to roles endpoint"

    # Test unauthorized access
    response = client.get('/api/admin/roles/')
    assert response.status_code == 401, "Unauthorized request should be rejected"

def test_permission_edge_cases(db_session, test_permissions):
    """Test edge cases for permissions."""
    # Test user with no roles
    user = User(username='noroles', email='noroles@test.com')
    user.set_password('testpass')
    db_session.add(user)
    db_session.commit()
    
    assert not user.has_permission('VIEW_ORDERS'), "User with no roles should have no permissions"
    
    # Test user with empty role (no permissions)
    empty_role = Role(name='Empty')
    db_session.add(empty_role)
    user.roles.append(empty_role)
    db_session.commit()
    
    assert not user.has_permission('VIEW_ORDERS'), "User with empty role should have no permissions"
    
    # Test non-existent permission
    assert not user.has_permission('NON_EXISTENT'), "Non-existent permission should return False"

def test_inactive_user_permissions(test_inactive_user, test_roles, test_permissions):
    """Test that inactive users can't use permissions."""
    # Give the inactive user some permissions via a role
    test_inactive_user.roles.append(test_roles['csr'])
    
    # Even though the user has the role, they should not have permission when inactive
    assert not test_inactive_user.has_permission('VIEW_ORDERS'), \
        "Inactive user should not have permissions"
</file>

<file path="tests/test_routes.py">
import pytest
import json
from datetime import datetime
from src.models.fuel_order import FuelOrderStatus

def test_create_fuel_order(client, test_aircraft, test_customer, test_user, test_fuel_truck):
    """Test creating a fuel order via API."""
    # Login first
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    response_data = json.loads(login_response.data)
    print(f"Login response: {response_data}")
    token = response_data['token']
    
    # Create fuel order
    headers = {'Authorization': f'Bearer {token}'}
    data = {
        'tail_number': test_aircraft.tail_number,
        'customer_id': test_customer.id,
        'fuel_type': 'Jet A',
        'additive_requested': False,
        'requested_amount': 1000.0,
        'assigned_lst_user_id': test_user.id,
        'assigned_truck_id': test_fuel_truck.id,
        'location_on_ramp': 'Gate A1',
        'csr_notes': 'Test order'
    }
    
    response = client.post('/fuel-orders/', 
                         json=data,
                         headers=headers)
    print(f"Create response: {response.data.decode()}")
    assert response.status_code == 201
    
    response_data = json.loads(response.data)
    assert response_data['tail_number'] == test_aircraft.tail_number
    assert response_data['status'] == FuelOrderStatus.DISPATCHED.value

def test_get_fuel_orders(client, db_session, test_aircraft, test_user):
    """Test getting list of fuel orders."""
    # Login
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    token = json.loads(login_response.data)['token']
    headers = {'Authorization': f'Bearer {token}'}
    
    # Get fuel orders
    response = client.get('/fuel-orders/', headers=headers)
    assert response.status_code == 200
    
    data = json.loads(response.data)
    assert 'fuel_orders' in data
    assert isinstance(data['fuel_orders'], list)
    assert 'pagination' in data

def test_update_fuel_order_status(client, db_session, test_aircraft, test_csr_user, test_lst_user, test_fuel_truck):
    """Test updating fuel order status."""
    # Login as CSR
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    token = json.loads(login_response.data)['token']
    headers = {'Authorization': f'Bearer {token}'}
    
    # Create a fuel order first
    create_data = {
        'tail_number': test_aircraft.tail_number,
        'fuel_type': 'Jet A',
        'additive_requested': False,
        'requested_amount': 1000.0,
        'assigned_lst_user_id': test_lst_user.id,
        'assigned_truck_id': test_fuel_truck.id,
        'location_on_ramp': 'Gate A1',
        'csr_notes': 'Test order'
    }
    create_response = client.post('/fuel-orders/', 
                                json=create_data,
                                headers=headers)
    print(f"Create response: {create_response.data.decode()}")
    assert create_response.status_code == 201
    fuel_order_id = json.loads(create_response.data)['id']
    
    # Update status
    update_data = {
        'status': 'Acknowledged',
        'assigned_truck_id': test_fuel_truck.id
    }
    response = client.put(f'/fuel-orders/{fuel_order_id}/',
                         json=update_data,
                         headers=headers)
    assert response.status_code == 200
    
    updated_data = json.loads(response.data)
    assert updated_data['status'] == FuelOrderStatus.ACKNOWLEDGED.value
    assert updated_data['assigned_truck_id'] == test_fuel_truck.id

def test_complete_fuel_order(client, test_aircraft, test_csr_user, test_lst_user, test_fuel_truck):
    # Login as CSR
    login_response = client.post('/auth/login', json={
        'email': 'testcsr@example.com',
        'password': 'csrpass'
    })
    assert login_response.status_code == 200
    csr_token = json.loads(login_response.data)['token']
    auth_headers_csr = {'Authorization': f'Bearer {csr_token}'}
    
    # Login as LST
    login_response = client.post('/auth/login', json={
        'email': 'testlst@example.com',
        'password': 'csrpass'  # LST users also use csrpass in tests
    })
    assert login_response.status_code == 200
    lst_token = json.loads(login_response.data)['token']
    auth_headers_lst = {'Authorization': f'Bearer {lst_token}'}

    # Create a fuel order as CSR
    response = client.post('/fuel-orders/', json={
        'tail_number': test_aircraft.tail_number,
        'fuel_type': 'Jet A',
        'requested_amount': 1000.0,
        'location_on_ramp': 'Gate A1',
        'csr_notes': 'Test order',
        'assigned_truck_id': test_fuel_truck.id,
        'assigned_lst_user_id': test_lst_user.id,
        'additive_requested': False
    }, headers=auth_headers_csr)
    assert response.status_code == 201
    order_data = json.loads(response.data)

    # LST acknowledges the order
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'ACKNOWLEDGED',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_lst)
    assert response.status_code == 200

    # LST marks en route
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'EN_ROUTE',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_lst)
    assert response.status_code == 200

    # LST marks fueling
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'FUELING',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_lst)
    print(f"Fueling response: {response.data.decode()}")
    assert response.status_code == 200

    # LST completes the order with meter readings
    response = client.put(f'/fuel-orders/{order_data["id"]}/submit-data', json={
        'start_meter_reading': 1000.0,
        'end_meter_reading': 1950.0,
        'lst_notes': 'Completed fueling'
    }, headers=auth_headers_lst)
    print(f"Complete response: {response.data.decode()}")
    assert response.status_code == 200

    # CSR reviews the order
    response = client.put(f'/fuel-orders/{order_data["id"]}/', json={
        'status': 'REVIEWED',
        'assigned_truck_id': test_fuel_truck.id
    }, headers=auth_headers_csr)
    print(f"Review response: {response.data.decode()}")
    assert response.status_code == 200
</file>

<file path="tests/test_users.py">
"""Tests for user management endpoints."""

import pytest
import json
from src.models.user import User
from src.models.role import Role

def test_get_users_list(client, auth_headers, test_users):
    """Test GET /api/users endpoint."""
    # Test unauthorized access
    response = client.get('/api/users')
    assert response.status_code == 401

    # Test access with CSR role (should have VIEW_USERS permission)
    response = client.get('/api/users', headers=auth_headers['csr'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert isinstance(data['users'], list)
    assert len(data['users']) > 0
    for user in data['users']:
        assert 'id' in user
        assert 'email' in user
        assert 'name' in user
        assert 'roles' in user
        assert isinstance(user['roles'], list)

    # Test access with LST role (should have VIEW_USERS permission)
    response = client.get('/api/users', headers=auth_headers['lst'])
    assert response.status_code == 200

    # Test access with admin role
    response = client.get('/api/users', headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert isinstance(data['users'], list)
    assert len(data['users']) > 0

def test_get_user_detail(client, auth_headers, test_users):
    """Test GET /api/users/<id> endpoint."""
    user_id = test_users['csr'].id

    # Test unauthorized access
    response = client.get(f'/api/users/{user_id}')
    assert response.status_code == 401

    # Test access with CSR role (should have VIEW_USERS permission)
    response = client.get(f'/api/users/{user_id}', headers=auth_headers['csr'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['id'] == user_id
    assert 'email' in data
    assert 'name' in data
    assert 'roles' in data
    assert isinstance(data['roles'], list)

    # Test access with LST role (should have VIEW_USERS permission)
    response = client.get(f'/api/users/{user_id}', headers=auth_headers['lst'])
    assert response.status_code == 200

    # Test access with admin role
    response = client.get(f'/api/users/{user_id}', headers=auth_headers['admin'])
    assert response.status_code == 200

    # Test non-existent user
    response = client.get('/api/users/999999', headers=auth_headers['admin'])
    assert response.status_code == 404

def test_create_user(client, auth_headers, test_roles):
    """Test POST /api/admin/users endpoint."""
    new_user_data = {
        'name': 'New Test User',
        'email': 'newtest@test.com',
        'password': 'testpass123',
        'roles': ['Customer Service Representative']
    }

    # Test unauthorized access
    response = client.post('/api/admin/users', json=new_user_data)
    assert response.status_code == 401

    # Test access with CSR role (should not have MANAGE_USERS permission)
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test access with LST role (should not have MANAGE_USERS permission)
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful creation with admin role
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['admin'])
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['email'] == new_user_data['email']
    assert data['name'] == new_user_data['name']
    assert len(data['roles']) == 1
    assert data['roles'][0]['name'] == 'Customer Service Representative'

    # Verify user exists in database with correct roles
    user = User.query.filter_by(email=new_user_data['email']).first()
    assert user is not None
    assert user.name == new_user_data['name']
    assert len(user.roles) == 1
    assert user.roles[0].name == 'Customer Service Representative'

    # Test duplicate email
    response = client.post('/api/admin/users', json=new_user_data, headers=auth_headers['admin'])
    assert response.status_code == 409

def test_update_user(client, auth_headers, test_users, test_roles):
    """Test PUT /api/admin/users/<id> endpoint."""
    user_id = test_users['csr'].id
    update_data = {
        'name': 'Updated Name',
        'email': 'updated@test.com',
        'roles': ['Line Service Technician']
    }

    # Test unauthorized access
    response = client.put(f'/api/admin/users/{user_id}', json=update_data)
    assert response.status_code == 401

    # Test access with CSR role (should not have MANAGE_USERS permission)
    response = client.put(f'/api/admin/users/{user_id}', json=update_data, headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test access with LST role (should not have MANAGE_USERS permission)
    response = client.put(f'/api/admin/users/{user_id}', json=update_data, headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful update with admin role
    response = client.put(f'/api/admin/users/{user_id}', json=update_data, headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['email'] == update_data['email']
    assert data['name'] == update_data['name']
    assert len(data['roles']) == 1
    assert data['roles'][0]['name'] == 'Line Service Technician'

    # Verify changes in database
    user = User.query.get(user_id)
    assert user.email == update_data['email']
    assert user.name == update_data['name']
    assert len(user.roles) == 1
    assert user.roles[0].name == 'Line Service Technician'

    # Test non-existent user
    response = client.put('/api/admin/users/999999', json=update_data, headers=auth_headers['admin'])
    assert response.status_code == 404

def test_delete_user(client, auth_headers, test_users):
    """Test DELETE /api/admin/users/<id> endpoint."""
    user_to_delete = test_users['lst']
    user_id = user_to_delete.id

    # Test unauthorized access
    response = client.delete(f'/api/admin/users/{user_id}')
    assert response.status_code == 401

    # Test access with CSR role (should not have MANAGE_USERS permission)
    response = client.delete(f'/api/admin/users/{user_id}', headers=auth_headers['csr'])
    assert response.status_code == 403

    # Test access with LST role (should not have MANAGE_USERS permission)
    response = client.delete(f'/api/admin/users/{user_id}', headers=auth_headers['lst'])
    assert response.status_code == 403

    # Test successful deletion with admin role
    response = client.delete(f'/api/admin/users/{user_id}', headers=auth_headers['admin'])
    assert response.status_code == 200

    # Verify user is deleted
    assert User.query.get(user_id) is None

    # Test non-existent user
    response = client.delete('/api/admin/users/999999', headers=auth_headers['admin'])
    assert response.status_code == 404

def test_user_role_assignment(client, auth_headers, test_users, test_roles):
    """Test role assignment functionality."""
    user = test_users['csr']
    lst_role = Role.query.filter_by(name='Line Service Technician').first()

    # Add LST role to CSR user
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative', 'Line Service Technician']
    }

    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user has both roles
    assert len(data['roles']) == 2
    role_names = [role['name'] for role in data['roles']]
    assert 'Customer Service Representative' in role_names
    assert 'Line Service Technician' in role_names

    # Verify permissions from both roles
    user = User.query.get(user.id)
    assert user.has_permission('CREATE_ORDER')  # CSR permission
    assert user.has_permission('VIEW_ORDERS')   # LST permission
    assert user.has_permission('MANAGE_ORDERS') # CSR permission
    assert user.has_permission('VIEW_AIRCRAFT') # Both roles
    assert user.has_permission('VIEW_TRUCKS')   # Both roles

def test_user_role_removal(client, auth_headers, test_users, test_roles):
    """Test role removal functionality."""
    user = test_users['csr']
    
    # First add LST role
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative', 'Line Service Technician']
    }
    
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    
    # Then remove CSR role
    update_data['roles'] = ['Line Service Technician']
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user only has LST role
    assert len(data['roles']) == 1
    assert data['roles'][0]['name'] == 'Line Service Technician'
    
    # Verify permissions reflect only LST role
    user = User.query.get(user.id)
    assert user.has_permission('VIEW_ORDERS')     # LST permission
    assert user.has_permission('VIEW_AIRCRAFT')   # LST permission
    assert user.has_permission('VIEW_TRUCKS')     # LST permission
    assert not user.has_permission('MANAGE_ORDERS') # Lost CSR permission

def test_user_deactivation(client, auth_headers, test_users):
    """Test user deactivation functionality."""
    user = test_users['csr']
    
    # Deactivate user
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative'],
        'is_active': False
    }
    
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user is inactive
    assert not data['is_active']
    
    # Verify user cannot log in
    response = client.post('/api/auth/login', json={
        'email': user.email,
        'password': 'testpass'
    })
    assert response.status_code == 401
    data = json.loads(response.data)
    assert 'Account is inactive' in data['error']

def test_user_reactivation(client, auth_headers, test_users):
    """Test user reactivation functionality."""
    user = test_users['inactive']
    
    # Reactivate user
    update_data = {
        'name': user.name,
        'email': user.email,
        'roles': ['Customer Service Representative'],
        'is_active': True
    }
    
    response = client.put(f'/api/admin/users/{user.id}', 
                         json=update_data, 
                         headers=auth_headers['admin'])
    assert response.status_code == 200
    data = json.loads(response.data)
    
    # Verify user is active
    assert data['is_active']
    
    # Verify user can log in
    response = client.post('/api/auth/login', json={
        'email': user.email,
        'password': 'testpass'
    })
    assert response.status_code == 200
    assert 'token' in json.loads(response.data)
</file>

<file path=".gitignore">
# Environment variables
.env

# Python virtual environment
venv/
*/venv/

# Python cache files
__pycache__/
*.py[cod]
*$py.class

# Docker
docker-compose.override.yml

# IDE / Editor specific
.vscode/
.idea/
*.swp
</file>

<file path="config.py">
import os
from datetime import timedelta

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard-to-guess-string'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'jwt-secret-string'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)
    
    @staticmethod
    def init_app(app):
        pass

class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'postgresql://localhost/fbo_launchpad_dev'

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \
        'postgresql://localhost/fbo_launchpad_test'
    WTF_CSRF_ENABLED = False

class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')

config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
</file>

<file path="create_admin.py">
from src.models.user import User, UserRole
from src.extensions import db
from src.app import create_app

def create_admin_user():
    app = create_app()
    with app.app_context():
        # Check if admin already exists
        if User.query.filter_by(email='admin@fbolaunchpad.com').first():
            print("Admin user already exists!")
            return
        
        # Create new admin user
        admin = User(
            email='admin@fbolaunchpad.com',
            username='admin',
            role=UserRole.ADMIN,
            is_active=True
        )
        admin.set_password('Admin123!')
        
        # Save to database
        db.session.add(admin)
        db.session.commit()
        print("Admin user created successfully!")

if __name__ == '__main__':
    create_admin_user()
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "5001:5000"
    volumes:
      - ./src:/app/src
      - ./migrations:/app/migrations
      - ./tests:/app/tests
    env_file:
      - .env
    depends_on:
      - db
    environment:
      - FLASK_APP=src/app.py
      - FLASK_ENV=development
    restart: unless-stopped

  db:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=fbo_user
      - POSTGRES_PASSWORD=fbo_password
      - POSTGRES_DB=fbo_launchpad_dev
    ports:
      - "5433:5432"
    restart: unless-stopped

volumes:
  postgres_data:
</file>

<file path="Dockerfile">
# Use Python 3.10 slim image as base
FROM python:3.10-slim

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    FLASK_APP=src/app.py \
    PYTHONDONTWRITEBYTECODE=1

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements file
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application
COPY src/ src/
COPY migrations/ migrations/

# Expose the application port
EXPOSE 5000

# Command to run the application
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "src.app:create_app()", "--workers", "4", "--reload"]
</file>

<file path="pytest.ini">
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Display all test results, including passing ones
addopts = -v

# Environment variables for testing
env =
    FLASK_ENV=testing
    FLASK_APP=src/app.py
    SQLALCHEMY_DATABASE_URI=sqlite:///:memory:
    SECRET_KEY=test-secret-key

# Markers for test categorization
markers =
    auth: authentication related tests
    models: database model tests
    routes: API route tests
    integration: integration tests

# Logging configuration
log_cli = true
log_cli_level = INFO
log_cli_format = %(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)
log_cli_date_format = %Y-%m-%d %H:%M:%S
</file>

<file path="requirements.txt">
Flask==3.0.2
Flask-Cors==5.0.1
Flask-Migrate==4.0.5
Flask-SQLAlchemy==3.1.1
PyJWT>=2.0.0,<3.0.0
apispec>=6.0.0,<7.0.0
apispec-webframeworks>=0.5.0,<1.0.0
gunicorn==21.2.0
marshmallow>=3.0.0,<4.0.0
psycopg2-binary==2.9.9
pytest==8.0.2
pytest-env==1.1.3
pytest-flask==1.3.0
python-dotenv==1.0.1
flask_jwt_extended
</file>

<file path="setup.py">
from setuptools import setup, find_packages

setup(
    name="fbo-launchpad-backend",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "flask",
        "flask-sqlalchemy",
        "flask-migrate",
        "psycopg2-binary",
        "python-dotenv",
        "apispec",
        "apispec-webframeworks",
        "marshmallow",
    ],
)
</file>

<file path="test-requirements.txt">
pytest==8.0.2
pytest-env==1.1.3
pytest-flask==1.3.0
pytest-cov==4.1.0  # For test coverage reporting
pytest-xdist==3.5.0  # For parallel test execution
pytest-timeout==2.2.0  # For test timeouts
pytest-mock==3.12.0  # For mocking
pytest-randomly==3.15.0  # For randomized test order
</file>

</files>
</file>

<file path="fbo-launchpad-backend/setup.py">
from setuptools import setup, find_packages

setup(
    name="fbo-launchpad-backend",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "flask",
        "flask-sqlalchemy",
        "flask-migrate",
        "psycopg2-binary",
        "python-dotenv",
        "apispec",
        "apispec-webframeworks",
        "marshmallow",
    ],
)
</file>

<file path="fbo-launchpad-backend/test-requirements.txt">
pytest==8.0.2
pytest-env==1.1.3
pytest-flask==1.3.0
pytest-cov==4.1.0  # For test coverage reporting
pytest-xdist==3.5.0  # For parallel test execution
pytest-timeout==2.2.0  # For test timeouts
pytest-mock==3.12.0  # For mocking
pytest-randomly==3.15.0  # For randomized test order
</file>

<file path="fbo-launchpad-frontend-csr/docs/architecture.md">
# FBO LaunchPad Frontend CSR Project Brief

## Project Overview
FBO LaunchPad is a web platform for managing fuel orders at Fixed Base Operators (FBOs). This is the frontend client-side rendered (CSR) implementation using React and Vite.

## Core Requirements
- Single Page Application (SPA) using React and Vite
- Client-side routing with react-router-dom
- RESTful API integration using Axios
- User authentication and authorization
- Order management functionality
- Responsive and modern UI

## Technical Stack
- React (with Vite)
- React Router for routing
- Axios for API calls
- Environment-based configuration

## Project Structure
```
src/
├── assets/             # Static assets
├── components/         # Reusable UI components
│   └── common/         # General-purpose components
│   └── layout/         # Layout components
├── contexts/          # React Context providers
├── hooks/             # Custom React hooks
├── pages/             # Page components
├── services/          # API services
└── styles/            # Global styles
```

## Core Features
1. User Authentication
   - Login/Logout
   - Token management
   - Protected routes

2. Order Management
   - View orders list
   - Create new orders
   - View order details
   - Update order status

3. Admin Features (to be implemented)
   - User management
   - System configuration
   - Analytics dashboard

## Development Guidelines
- Follow React best practices
- Use functional components and hooks
- Implement proper error handling
- Maintain clean code structure
- Document components and functions
- Use environment variables for configuration

## Security Considerations
- Implement proper authentication
- Secure API calls
- Protected routes
- Token management
- XSS prevention
- CSRF protection 

# System Patterns

## Component Patterns

### Common Components
1. PaginationControls
   - Location: `src/components/common/PaginationControls.jsx`
   - Purpose: Reusable pagination component for lists and grids
   - Props:
     - `paginationData`: Object containing pagination state (page, total_pages, has_prev, has_next, total_items)
     - `onPageChange`: Callback function for page navigation
   - Features:
     - Conditional rendering based on page count
     - Previous/Next navigation
     - Page information display
     - Disabled state handling
     - Accessible button controls

2. ProtectedRoute
   - Location: `src/components/common/ProtectedRoute.jsx`
   - Purpose: Route wrapper for authentication protection
   - Features:
     - Authentication state check
     - Redirect handling
     - Route protection

## Data Fetching Patterns

### Pagination Pattern
1. State Management:
   - Pagination state stored at page level
   - Filters combined with pagination parameters
   - Loading and error states handled globally

2. API Integration:
   - Query parameters for page and per_page
   - Response includes pagination metadata
   - Error handling with state reset

3. User Interaction:
   - Page navigation through PaginationControls
   - Filter changes reset to first page
   - Loading states during transitions

## Component Hierarchy
1. Page Components
   - Manage data fetching
   - Handle state management
   - Compose UI components

2. Feature Components
   - Implement specific functionality
   - Receive data via props
   - Emit events to parent

3. Common Components
   - Reusable across features
   - Controlled via props
   - Consistent styling
</file>

<file path="fbo-launchpad-frontend-csr/docs/technical.md">
# Technical Context

## Development Environment
- Node.js environment
- Vite as build tool and dev server
- React 18+ for UI components
- ESLint for code quality
- Git for version control

## Key Dependencies
- react-router-dom: Client-side routing
- axios: HTTP client for API calls
- Other dependencies to be added as needed

## Frontend Testing Framework
1. Test Environment
   - Vitest as test runner
   - React Testing Library for component testing
   - JSDOM for browser environment simulation
   - Jest-DOM for DOM assertions

2. Test Setup
   - Custom test setup with providers
   - Mock utilities for common data
   - Test utilities for rendering with context

3. Test Coverage
   - Component unit tests
   - Integration tests
   - Coverage reporting (HTML, JSON, text)

4. Running Tests
   ```bash
   npm test           # Run tests in watch mode
   npm run test:ui    # Run tests with UI
   npm run test:coverage # Generate coverage report
   npm run test:watch   # Watch mode with coverage
   ```

## Backend Testing Framework
1. Test Environment
   - pytest and pytest-flask for testing
   - Separate PostgreSQL test database
   - TestingConfig with specific test settings
   - Fixtures for common test scenarios

2. Test Database
   - Isolated test database (fbo_launchpad_test)
   - Automatic table creation/cleanup
   - Transaction rollback after tests

3. Test Fixtures
   - Application context fixture
   - Database session fixture
   - Test client fixture
   - CLI runner fixture
   - User fixtures (CSR, LST, Admin)
   - Authentication header fixtures
   - Entity fixtures (Aircraft, Customer, FuelTruck)

4. Authentication Testing
   - JWT token generation
   - Role-based access testing
   - Token expiration handling

5. Running Tests
   ```bash
   # Inside backend container
   pytest                 # Run all tests
   pytest -v              # Verbose output
   pytest tests/test_*.py # Run specific test files
   pytest -k "test_name"  # Run tests matching pattern
   ```

## API Integration
- RESTful API communication
- Centralized API service configuration
- Token-based authentication
- Interceptors for request/response handling

## File Structure Conventions
1. Components
   - One component per file
   - Named exports for components
   - Organized by feature/type

2. Pages
   - Top-level route components
   - Handle data fetching and state
   - Compose smaller components

3. Services
   - API service configuration
   - Reusable API calls
   - Error handling

4. Contexts
   - Global state management
   - Authentication context
   - Theme context (if needed)

## Development Workflow
1. Local Development
   - `npm run dev` for development server
   - Environment variables in `.env.local`
   - Hot module replacement enabled

2. Building
   - `npm run build` for production build
   - Environment-specific builds
   - Build optimization

3. Testing (to be implemented)
   - Unit tests with Vitest
   - Component testing
   - Integration tests

## Deployment Considerations
- Static file hosting
- Environment variable management
- Build optimization
- Cache management

## Security Implementation
1. Authentication
   - JWT token storage
   - Token refresh mechanism
   - Secure routes

2. API Security
   - HTTPS only
   - Token validation
   - Request/response encryption

3. Data Protection
   - Input validation
   - XSS prevention
   - CSRF protection

## Performance Considerations
- Code splitting
- Lazy loading
- Image optimization
- Caching strategies
- Bundle size optimization
</file>

<file path="fbo-launchpad-frontend-csr/docs/ui_implementation.md">
# FBO LaunchPad Frontend UI Implementation

## Overview
The FBO LaunchPad frontend has been implemented as a modern, responsive web application using React with a focus on user experience, accessibility, and maintainability.

## Technical Stack
- **Framework**: React with React Router v6
- **Styling**: Tailwind CSS
- **State Management**: React Context API
- **Authentication**: JWT-based authentication
- **Font**: Inter (Google Fonts)
- **Icons**: Inline SVG with proper accessibility attributes

## Current Implementation Status

### Completed
1. ✅ Basic project structure
2. ✅ React Router setup
3. ✅ Tailwind CSS installation
4. ✅ PostCSS configuration
5. ✅ Base component architecture
6. ✅ Font integration (Inter)

### In Progress
1. ⏳ Tailwind CSS styling implementation
   - Configuration complete but styles not applying correctly
   - Need to verify build process
   - Need to check CSS import order
2. ⏳ Component styling migration to Tailwind
3. ⏳ Responsive design implementation

### Pending
1. Dark mode support
2. Loading skeletons
3. Error boundary components
4. Unit tests
5. E2E tests
6. Form validation library
7. Toast notifications
8. State management enhancement

## Component Architecture

### Layout Components
1. **MainLayout** (`src/components/layout/MainLayout.jsx`)
   - Provides consistent page structure
   - Responsive navigation
   - Footer with dynamic year
   - Props:
     - `children`: React nodes to render in main content area

### Page Components
1. **LoginPage** (`src/pages/LoginPage.jsx`)
   - Handles user authentication
   - Form validation
   - Loading states
   - Error handling

2. **DashboardPage** (`src/pages/DashboardPage.jsx`)
   - Main order management interface
   - Features:
     - Order filtering
     - CSV export
     - Pagination
     - Quick access to order creation

### Reusable Components
1. **OrderGrid** (`src/components/orders/OrderGrid.jsx`)
   - Displays order data in tabular format
   - Features:
     - Status badges with color coding
     - Responsive table layout
     - Loading states
     - Empty states
     - Error states
   - Props:
     ```javascript
     {
       orders: Array<Order>,
       isLoading: boolean,
       error: string,
       onViewDetails: (orderId: string|number) => void
     }
     ```

2. **OrderFilters** (`src/components/orders/OrderFilters.jsx`)
   - Order filtering interface
   - Status filter with predefined options
   - Extensible for additional filters
   - Props:
     ```javascript
     {
       currentFilters: {
         status: string
       },
       onFilterChange: (filterName: string, value: string) => void
     }
     ```

3. **PaginationControls** (`src/components/common/PaginationControls.jsx`)
   - Handles data pagination
   - Responsive design
   - Props:
     ```javascript
     {
       paginationData: {
         page: number,
         total_pages: number,
         has_prev: boolean,
         has_next: boolean,
         total_items: number
       },
       onPageChange: (newPage: number) => void
     }
     ```

## Current Configuration

### Tailwind CSS Setup
```javascript
// tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#2563eb',
          dark: '#1d4ed8'
        },
        success: '#059669',
        warning: '#d97706',
        danger: '#dc2626',
      },
      fontFamily: {
        sans: ['Inter', ...require('tailwindcss/defaultTheme').fontFamily.sans],
      },
    },
  },
  plugins: [],
}
```

### PostCSS Configuration
```javascript
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss/nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  }
}
```

### Global Styles
```css
/* src/styles/global.css */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom component styles */
@layer components {
  .status-dispatched { @apply bg-amber-100 text-amber-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-acknowledged { @apply bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm font-medium; }
  /* ... other status styles ... */
}
```

## Known Issues

1. 🔴 Tailwind styles not applying correctly
   - Configuration is complete but styles aren't being applied
   - Possible causes:
     - Build process not processing Tailwind correctly
     - CSS import order issues
     - Vite configuration might need adjustment
     - PostCSS processing order might be incorrect

2. 🟡 Custom utility classes removed
   - Migrated to Tailwind equivalents
   - Need to verify all components are updated

3. 🟡 Responsive design
   - Need to implement proper breakpoints
   - Some components may need adjustment

## Next Steps

1. **Critical**
   - Debug Tailwind CSS processing
   - Verify build pipeline
   - Check Vite configuration
   - Test PostCSS processing

2. **High Priority**
   - Complete component migration to Tailwind
   - Implement responsive designs
   - Add loading states
   - Enhance error handling

3. **Medium Priority**
   - Implement dark mode
   - Add loading skeletons
   - Set up unit tests
   - Add form validation

4. **Low Priority**
   - Add E2E tests
   - Implement toast notifications
   - Enhance state management

## Accessibility Features
1. Proper ARIA labels
2. Keyboard navigation support
3. Focus management
4. Screen reader friendly status messages
5. Proper heading hierarchy
6. Color contrast compliance

## Performance Considerations
1. Code splitting setup needed
2. Image optimization needed
3. Proper caching strategy needed
4. Bundle size optimization needed
5. Performance monitoring needed

## Setup Instructions

1. **Install Dependencies**
   ```bash
   npm install
   ```

2. **Required Environment Variables**
   ```env
   VITE_API_BASE_URL=your_api_url
   ```

3. **Development Server**
   ```bash
   npm run dev
   ```

## Missing Elements / To-Do

1. **CSS Framework Integration**
   - The current implementation uses custom utility classes
   - Recommend installing Tailwind CSS for proper utility class support:
   ```bash
   npm install -D tailwindcss postcss autoprefixer
   npx tailwindcss init -p
   ```

2. **Tailwind Configuration**
   Create `tailwind.config.js`:
   ```javascript
   module.exports = {
     content: [
       "./src/**/*.{js,jsx,ts,tsx}",
     ],
     theme: {
       extend: {},
     },
     plugins: [],
   }
   ```

3. **PostCSS Configuration**
   Create `postcss.config.js`:
   ```javascript
   module.exports = {
     plugins: {
       tailwindcss: {},
       autoprefixer: {},
     }
   }
   ```

4. **Update CSS Import**
   Replace current CSS with Tailwind directives:
   ```css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ```

## Next Steps

1. Install and configure Tailwind CSS for proper utility class support
2. Add responsive design breakpoints
3. Implement dark mode support
4. Add loading skeletons for better UX
5. Implement error boundary components
6. Add unit tests for components
7. Add E2E tests for critical user flows
8. Implement proper form validation library
9. Add proper toast notifications for actions
10. Implement proper state management if complexity grows
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/AircraftForm.jsx">
import React, { useState, useEffect } from 'react';

const AircraftForm = ({ initialData = {}, onSubmit, isSubmitting, error }) => {
  const isEditMode = Boolean(initialData && initialData.tail_number);
  const [tailNumber, setTailNumber] = useState(initialData.tail_number || '');
  const [customerId, setCustomerId] = useState(initialData.customer_id || '');
  const [formError, setFormError] = useState('');

  useEffect(() => {
    setTailNumber(initialData.tail_number || '');
    setCustomerId(initialData.customer_id || '');
    setFormError('');
  }, [initialData]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!tailNumber.trim() && !isEditMode) {
      setFormError('Tail number is required.');
      return;
    }
    onSubmit({
      tail_number: tailNumber.trim(),
      customer_id: customerId ? Number(customerId) : undefined,
    });
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block mb-1 font-medium">Tail Number *</label>
        <input
          type="text"
          className="input w-full"
          value={tailNumber}
          onChange={e => setTailNumber(e.target.value)}
          required
          readOnly={isEditMode}
          placeholder="e.g. N12345"
        />
      </div>
      <div>
        <label className="block mb-1 font-medium">Customer ID</label>
        <input
          type="number"
          className="input w-full"
          value={customerId}
          onChange={e => setCustomerId(e.target.value)}
          placeholder="Customer ID (optional)"
        />
      </div>
      {(formError || error) && (
        <div className="text-red-600 text-sm">{formError || error}</div>
      )}
      <button
        type="submit"
        className="btn btn-primary w-full"
        disabled={isSubmitting}
      >
        {isEditMode ? 'Update Aircraft' : 'Create Aircraft'}
      </button>
    </form>
  );
};

export default AircraftForm;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/AircraftTable.jsx">
import React from 'react';

const AircraftTable = ({ aircraftList = [], onEdit, onDelete, isLoading }) => {
  return (
    <div className="overflow-x-auto">
      <table className="min-w-full bg-white border border-gray-200">
        <thead>
          <tr>
            <th className="px-4 py-2 border-b">Tail Number</th>
            <th className="px-4 py-2 border-b">Customer ID</th>
            <th className="px-4 py-2 border-b">Created At</th>
            <th className="px-4 py-2 border-b">Actions</th>
          </tr>
        </thead>
        <tbody>
          {isLoading ? (
            <tr><td colSpan={4} className="text-center py-4">Loading...</td></tr>
          ) : (
            aircraftList.length === 0 ? (
              <tr><td colSpan={4} className="text-center py-4">No aircraft found.</td></tr>
            ) : (
              aircraftList.map(aircraft => (
                <tr key={aircraft.tail_number}>
                  <td className="px-4 py-2 border-b">{aircraft.tail_number}</td>
                  <td className="px-4 py-2 border-b">{aircraft.customer_id || '-'}</td>
                  <td className="px-4 py-2 border-b">{aircraft.created_at ? new Date(aircraft.created_at).toLocaleString() : '-'}</td>
                  <td className="px-4 py-2 border-b space-x-2">
                    <button className="btn btn-xs btn-outline" onClick={() => onEdit(aircraft)}>Edit</button>
                    <button className="btn btn-xs btn-danger" onClick={() => onDelete(aircraft.tail_number)}>Delete</button>
                  </td>
                </tr>
              ))
            )
          )}
        </tbody>
      </table>
    </div>
  );
};

export default AircraftTable;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/CustomerForm.jsx">
import React, { useState, useEffect } from 'react';

const CustomerForm = ({ initialData = {}, onSubmit, isSubmitting, error }) => {
  const isEditMode = Boolean(initialData && initialData.id);
  const [name, setName] = useState(initialData.name || '');
  const [formError, setFormError] = useState('');

  useEffect(() => {
    setName(initialData.name || '');
    setFormError('');
  }, [initialData]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!name.trim()) {
      setFormError('Name is required.');
      return;
    }
    onSubmit({ name: name.trim() });
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block mb-1 font-medium">Customer Name *</label>
        <input
          type="text"
          className="input w-full"
          value={name}
          onChange={e => setName(e.target.value)}
          required
          placeholder="Customer name"
        />
      </div>
      {(formError || error) && (
        <div className="text-red-600 text-sm">{formError || error}</div>
      )}
      <button
        type="submit"
        className="btn btn-primary w-full"
        disabled={isSubmitting}
      >
        {isEditMode ? 'Update Customer' : 'Create Customer'}
      </button>
    </form>
  );
};

export default CustomerForm;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/CustomerTable.jsx">
import React from 'react';

const CustomerTable = ({ customerList = [], onEdit, onDelete, isLoading }) => {
  return (
    <div className="overflow-x-auto">
      <table className="min-w-full bg-white border border-gray-200">
        <thead>
          <tr>
            <th className="px-4 py-2 border-b">ID</th>
            <th className="px-4 py-2 border-b">Name</th>
            <th className="px-4 py-2 border-b">Created At</th>
            <th className="px-4 py-2 border-b">Actions</th>
          </tr>
        </thead>
        <tbody>
          {isLoading ? (
            <tr><td colSpan={4} className="text-center py-4">Loading...</td></tr>
          ) : (
            customerList.length === 0 ? (
              <tr><td colSpan={4} className="text-center py-4">No customers found.</td></tr>
            ) : (
              customerList.map(customer => (
                <tr key={customer.id}>
                  <td className="px-4 py-2 border-b">{customer.id}</td>
                  <td className="px-4 py-2 border-b">{customer.name}</td>
                  <td className="px-4 py-2 border-b">{customer.created_at ? new Date(customer.created_at).toLocaleString() : '-'}</td>
                  <td className="px-4 py-2 border-b space-x-2">
                    <button className="btn btn-xs btn-outline" onClick={() => onEdit(customer)}>Edit</button>
                    <button className="btn btn-xs btn-danger" onClick={() => onDelete(customer.id)}>Delete</button>
                  </td>
                </tr>
              ))
            )
          )}
        </tbody>
      </table>
    </div>
  );
};

export default CustomerTable;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/PermissionListTable.jsx">
import React from 'react';
import PropTypes from 'prop-types';
import { Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, CircularProgress } from '@mui/material';

function PermissionListTable({ permissions, isLoading }) {
  if (isLoading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', padding: '2rem' }}>
        <CircularProgress />
      </div>
    );
  }

  if (!permissions || permissions.length === 0) {
    return <div>No permissions found.</div>;
  }

  return (
    <TableContainer component={Paper}>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell><strong>Permission Name</strong></TableCell>
            <TableCell><strong>Description</strong></TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {permissions.map((permission) => (
            <TableRow key={permission.name}>
              <TableCell>
                <code>{permission.name}</code>
              </TableCell>
              <TableCell>{permission.description || 'N/A'}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
}

PermissionListTable.propTypes = {
  permissions: PropTypes.arrayOf(
    PropTypes.shape({
      name: PropTypes.string.isRequired,
      description: PropTypes.string
    })
  ).isRequired,
  isLoading: PropTypes.bool.isRequired
};

export default PermissionListTable;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/RoleForm.jsx">
import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';

const RoleForm = ({ initialData, onSubmit, isSubmitting, error }) => {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
  });

  useEffect(() => {
    if (initialData) {
      setFormData({
        name: initialData.name || '',
        description: initialData.description || '',
      });
    }
  }, [initialData]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(formData);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error}
        </div>
      )}

      <div>
        <label htmlFor="name" className="block text-sm font-medium text-gray-700">
          Name *
        </label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          required
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
          placeholder="Enter role name"
          disabled={isSubmitting}
        />
      </div>

      <div>
        <label htmlFor="description" className="block text-sm font-medium text-gray-700">
          Description
        </label>
        <textarea
          id="description"
          name="description"
          value={formData.description}
          onChange={handleChange}
          rows={3}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
          placeholder="Enter role description"
          disabled={isSubmitting}
        />
      </div>

      <div className="flex justify-end">
        <button
          type="submit"
          disabled={isSubmitting}
          className={`inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${
            isSubmitting ? 'opacity-50 cursor-not-allowed' : ''
          }`}
        >
          {isSubmitting ? 'Saving...' : 'Save'}
        </button>
      </div>
    </form>
  );
};

RoleForm.propTypes = {
  initialData: PropTypes.shape({
    name: PropTypes.string,
    description: PropTypes.string,
  }),
  onSubmit: PropTypes.func.isRequired,
  isSubmitting: PropTypes.bool,
  error: PropTypes.string,
};

RoleForm.defaultProps = {
  initialData: null,
  isSubmitting: false,
  error: '',
};

export default RoleForm;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/RolePermissionManager.jsx">
import React from 'react';
import PropTypes from 'prop-types';

const RolePermissionManager = ({
  role,
  allPermissions,
  assignedPermissions,
  onAssign,
  onRemove,
  isLoading,
}) => {
  const availablePermissions = allPermissions.filter(
    (permission) => !assignedPermissions.find((ap) => ap.id === permission.id)
  );

  if (isLoading) {
    return <div className="text-center py-4">Loading permissions...</div>;
  }

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-medium text-gray-900">
          Manage Permissions for Role: {role.name}
        </h3>
        <p className="mt-1 text-sm text-gray-500">
          Assign or remove permissions for this role.
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Available Permissions */}
        <div>
          <h4 className="text-sm font-medium text-gray-900 mb-3">Available Permissions</h4>
          <div className="border rounded-md divide-y">
            {availablePermissions.length === 0 ? (
              <div className="p-4 text-sm text-gray-500">No available permissions</div>
            ) : (
              availablePermissions.map((permission) => (
                <div
                  key={permission.id}
                  className="p-4 flex items-center justify-between hover:bg-gray-50"
                >
                  <div>
                    <p className="text-sm font-medium text-gray-900">{permission.name}</p>
                    {permission.description && (
                      <p className="text-sm text-gray-500">{permission.description}</p>
                    )}
                  </div>
                  <button
                    onClick={() => onAssign(permission.id)}
                    className="ml-4 text-sm text-indigo-600 hover:text-indigo-900"
                  >
                    Assign
                  </button>
                </div>
              ))
            )}
          </div>
        </div>

        {/* Assigned Permissions */}
        <div>
          <h4 className="text-sm font-medium text-gray-900 mb-3">Assigned Permissions</h4>
          <div className="border rounded-md divide-y">
            {assignedPermissions.length === 0 ? (
              <div className="p-4 text-sm text-gray-500">No assigned permissions</div>
            ) : (
              assignedPermissions.map((permission) => (
                <div
                  key={permission.id}
                  className="p-4 flex items-center justify-between hover:bg-gray-50"
                >
                  <div>
                    <p className="text-sm font-medium text-gray-900">{permission.name}</p>
                    {permission.description && (
                      <p className="text-sm text-gray-500">{permission.description}</p>
                    )}
                  </div>
                  <button
                    onClick={() => onRemove(permission.id)}
                    className="ml-4 text-sm text-red-600 hover:text-red-900"
                  >
                    Remove
                  </button>
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

RolePermissionManager.propTypes = {
  role: PropTypes.shape({
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    name: PropTypes.string.isRequired,
  }).isRequired,
  allPermissions: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      name: PropTypes.string.isRequired,
      description: PropTypes.string,
    })
  ).isRequired,
  assignedPermissions: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      name: PropTypes.string.isRequired,
      description: PropTypes.string,
    })
  ).isRequired,
  onAssign: PropTypes.func.isRequired,
  onRemove: PropTypes.func.isRequired,
  isLoading: PropTypes.bool,
};

RolePermissionManager.defaultProps = {
  isLoading: false,
};

export default RolePermissionManager;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/RoleTable.jsx">
import React from 'react';
import PropTypes from 'prop-types';

const RoleTable = ({ roles, onEdit, onDelete, onManagePermissions, isLoading }) => {
  if (isLoading) {
    return <div className="text-center py-4">Loading roles...</div>;
  }

  if (!roles?.length) {
    return <div className="text-center py-4">No roles found.</div>;
  }

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full bg-white border border-gray-300">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
            <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {roles.map((role) => (
            <tr key={role.id}>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{role.id}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{role.name}</td>
              <td className="px-6 py-4 text-sm text-gray-900">{role.description || '-'}</td>
              <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <button
                  onClick={() => onManagePermissions(role)}
                  className="text-indigo-600 hover:text-indigo-900 mr-4"
                >
                  Permissions
                </button>
                <button
                  onClick={() => onEdit(role)}
                  className="text-blue-600 hover:text-blue-900 mr-4"
                >
                  Edit
                </button>
                <button
                  onClick={() => onDelete(role)}
                  className="text-red-600 hover:text-red-900"
                >
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

RoleTable.propTypes = {
  roles: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      name: PropTypes.string.isRequired,
      description: PropTypes.string,
    })
  ).isRequired,
  onEdit: PropTypes.func.isRequired,
  onDelete: PropTypes.func.isRequired,
  onManagePermissions: PropTypes.func.isRequired,
  isLoading: PropTypes.bool,
};

RoleTable.defaultProps = {
  isLoading: false,
};

export default RoleTable;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/TruckForm.jsx">
import React, { useState } from 'react';

export default function TruckForm({ initialData = {}, onSubmit, onCancel, isSubmitting }) {
  const [truckNumber, setTruckNumber] = useState(initialData.truck_number || '');
  const [fuelType, setFuelType] = useState(initialData.fuel_type || '');
  const [capacity, setCapacity] = useState(initialData.capacity || '');
  const [error, setError] = useState(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!truckNumber.trim() || !fuelType.trim() || !capacity) {
      setError('All fields are required');
      return;
    }
    if (isNaN(Number(capacity)) || Number(capacity) <= 0) {
      setError('Capacity must be a positive number');
      return;
    }
    setError(null);
    onSubmit({
      truck_number: truckNumber.trim(),
      fuel_type: fuelType.trim(),
      capacity: Number(capacity)
    });
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <h2 className="text-xl font-semibold mb-2">{initialData.id ? 'Edit Truck' : 'Create Truck'}</h2>
      <div>
        <label className="block mb-1 font-medium">Truck Number</label>
        <input
          className="input input-bordered w-full"
          type="text"
          value={truckNumber}
          onChange={e => setTruckNumber(e.target.value)}
          disabled={isSubmitting}
        />
      </div>
      <div>
        <label className="block mb-1 font-medium">Fuel Type</label>
        <input
          className="input input-bordered w-full"
          type="text"
          value={fuelType}
          onChange={e => setFuelType(e.target.value)}
          disabled={isSubmitting}
        />
      </div>
      <div>
        <label className="block mb-1 font-medium">Capacity (gallons)</label>
        <input
          className="input input-bordered w-full"
          type="number"
          min="1"
          value={capacity}
          onChange={e => setCapacity(e.target.value)}
          disabled={isSubmitting}
        />
      </div>
      {error && <div className="text-red-600 text-sm">{error}</div>}
      <div className="flex gap-2 mt-4">
        <button className="btn btn-primary" type="submit" disabled={isSubmitting}>{isSubmitting ? 'Saving...' : 'Save'}</button>
        <button className="btn btn-secondary" type="button" onClick={onCancel} disabled={isSubmitting}>Cancel</button>
      </div>
    </form>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/components/admin/UserForm.jsx">
import React, { useState, useEffect } from 'react';

export default function UserForm({ initialData = {}, onSubmit, onCancel, isSubmitting, isEditMode, availableRoles = [] }) {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    is_active: true
  });
  const [selectedRoleIds, setSelectedRoleIds] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (initialData) {
      setFormData({
        name: initialData.name || '',
        email: initialData.email || '',
        password: '', // Don't populate password for edit
        is_active: initialData.is_active !== undefined ? initialData.is_active : true,
      });
      // Set selected roles from initialData.roles array
      setSelectedRoleIds(initialData.roles?.map(role => role.id) || []);
    } else {
      // Reset form for create mode
      setFormData({
        name: '',
        email: '',
        password: '',
        is_active: true
      });
      setSelectedRoleIds([]);
    }
  }, [initialData]);

  const validateEmail = (email) => {
    return /\S+@\S+\.\S+/.test(email);
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleRoleChange = (roleId) => {
    setSelectedRoleIds(prev => {
      if (prev.includes(roleId)) {
        return prev.filter(id => id !== roleId);
      } else {
        return [...prev, roleId];
      }
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!formData.name.trim() || !formData.email.trim() || (!isEditMode && !formData.password.trim())) {
      setError('Name, email, and password (on create) are required.');
      return;
    }
    if (!validateEmail(formData.email)) {
      setError('Invalid email format.');
      return;
    }
    if (!isEditMode && formData.password.length < 6) {
      setError('Password must be at least 6 characters.');
      return;
    }
    if (selectedRoleIds.length === 0) {
      setError('Please select at least one role.');
      return;
    }
    setError(null);

    const userData = {
      name: formData.name.trim(),
      email: formData.email.trim(),
      role_ids: selectedRoleIds,
      is_active: formData.is_active
    };

    if (!isEditMode) {
      userData.password = formData.password;
    }

    onSubmit(userData);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <h2 className="text-xl font-semibold mb-2">{isEditMode ? 'Edit User' : 'Create User'}</h2>
      <div>
        <label className="block mb-1 font-medium">Name</label>
        <input
          className="input input-bordered w-full"
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
          disabled={isSubmitting}
        />
      </div>
      <div>
        <label className="block mb-1 font-medium">Email</label>
        <input
          className="input input-bordered w-full"
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          disabled={isSubmitting}
        />
      </div>
      {!isEditMode && (
        <div>
          <label className="block mb-1 font-medium">Password</label>
          <input
            className="input input-bordered w-full"
            type="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            disabled={isSubmitting}
          />
        </div>
      )}
      <div>
        <label className="block mb-1 font-medium">Roles*</label>
        <div className="space-y-2 border rounded-lg p-3">
          {availableRoles.length === 0 ? (
            <p className="text-gray-500 italic">Loading roles...</p>
          ) : (
            availableRoles.map(role => (
              <div key={role.id} className="flex items-center gap-2">
                <input
                  type="checkbox"
                  id={`role-${role.id}`}
                  checked={selectedRoleIds.includes(role.id)}
                  onChange={() => handleRoleChange(role.id)}
                  disabled={isSubmitting}
                  className="checkbox checkbox-primary"
                />
                <label htmlFor={`role-${role.id}`} className="cursor-pointer">
                  {role.name}
                </label>
              </div>
            ))
          )}
        </div>
      </div>
      <div className="flex items-center gap-2">
        <input
          type="checkbox"
          id="is_active"
          name="is_active"
          checked={formData.is_active}
          onChange={handleChange}
          disabled={isSubmitting}
          className="checkbox"
        />
        <label htmlFor="is_active">Active</label>
      </div>
      {error && <div className="text-red-600 text-sm">{error}</div>}
      <div className="flex gap-2 mt-4">
        <button className="btn btn-primary" type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Saving...' : 'Save'}
        </button>
        <button className="btn btn-secondary" type="button" onClick={onCancel} disabled={isSubmitting}>
          Cancel
        </button>
      </div>
    </form>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/components/common/DarkModeToggle.jsx">
import React from 'react';
import { useDarkMode } from '../../context/DarkModeContext';
import { FaMoon, FaSun } from 'react-icons/fa';

export default function DarkModeToggle({ className = '' }) {
  const { darkMode, toggleDarkMode } = useDarkMode();

  return (
    <button
      onClick={toggleDarkMode}
      className={`flex items-center gap-2 px-3 py-1 rounded-full border border-transparent hover:border-blue-400 transition bg-gray-100 dark:bg-gray-800 dark:text-yellow-200 text-gray-700 shadow ${className}`}
      aria-label="Toggle dark mode"
      title={darkMode ? 'Switch to light mode' : 'Switch to dark mode'}
    >
      {darkMode ? (
        <FaSun className="text-yellow-300" />
      ) : (
        <FaMoon className="text-blue-600" />
      )}
      <span className="hidden md:inline text-sm font-medium">
        {darkMode ? 'Light' : 'Dark'}
      </span>
    </button>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/components/common/Modal.jsx">
import React from 'react';
import { FaTimes } from 'react-icons/fa';

/**
 * Modern glassmorphic modal with fade/scale animation.
 * Props:
 * - isOpen: boolean
 * - onClose: function
 * - children: content
 * - title: optional string
 */
export default function Modal({ isOpen, onClose, children, title }) {
  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div
        className="absolute inset-0 bg-black/30 backdrop-blur-sm transition-opacity animate-fadein"
        onClick={onClose}
        aria-label="Close modal overlay"
      />
      <div className="relative bg-white/80 backdrop-blur-xl rounded-2xl shadow-2xl p-6 w-full max-w-md mx-auto animate-scalein">
        <button
          className="absolute top-3 right-3 text-gray-400 hover:text-blue-700 focus:outline-none text-xl"
          onClick={onClose}
          aria-label="Close modal"
        >
          <FaTimes />
        </button>
        {title && <h2 className="text-xl font-semibold mb-4 text-blue-800">{title}</h2>}
        <div>{children}</div>
      </div>
      <style>{`
        @keyframes fadein { from { opacity: 0; } to { opacity: 1; } }
        @keyframes scalein { from { opacity: 0; transform: scale(0.96); } to { opacity: 1; transform: scale(1); } }
        .animate-fadein { animation: fadein 0.2s ease; }
        .animate-scalein { animation: scalein 0.2s cubic-bezier(.4,0,.2,1); }
      `}</style>
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/components/common/StatusBadge.jsx">
import React from "react";

const STATUS_STYLES = {
  Pending: "bg-yellow-100 text-yellow-800",
  "In Progress": "bg-blue-100 text-blue-700",
  Completed: "bg-green-100 text-green-700",
  Cancelled: "bg-red-100 text-red-700",
  default: "bg-gray-100 text-gray-700"
};

const StatusBadge = ({ status }) => {
  const style = STATUS_STYLES[status] || STATUS_STYLES.default;
  return (
    <span className={`px-3 py-1 rounded-full text-xs font-semibold ${style}`}>{status}</span>
  );
};

export default StatusBadge;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/dashboard/OrderStatusCard.jsx">
import React from "react";

const OrderStatusCard = ({ title, count, description, icon, color = "bg-blue-100", onViewAll }) => {
  return (
    <div className={`flex flex-col justify-between rounded-lg shadow-sm p-5 min-w-[220px] bg-white border border-gray-100 h-32`}>
      <div className="flex items-center gap-3 mb-2">
        <div className={`flex items-center justify-center w-10 h-10 rounded-full ${color}`}>
          {icon || (
            <svg className="h-6 w-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><circle cx="12" cy="12" r="10" strokeWidth="2" /></svg>
          )}
        </div>
        <div className="flex flex-col">
          <span className="text-2xl font-bold text-gray-800">{count}</span>
          <span className="text-gray-600 text-sm font-medium">{title}</span>
        </div>
      </div>
      <div className="flex items-center justify-between">
        <span className="text-xs text-gray-400">{description}</span>
        {onViewAll && (
          <button
            className="text-xs text-blue-600 hover:underline font-semibold ml-2"
            onClick={onViewAll}
          >
            View All
          </button>
        )}
      </div>
    </div>
  );
};

export default OrderStatusCard;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/dashboard/RecentReceipts.jsx">
import React from "react";
import StatusBadge from "../common/StatusBadge";
import { Link } from "react-router-dom";

const RecentReceipts = ({ receipts }) => {
  if (!receipts?.length) {
    return <div className="py-8 text-center text-gray-400">No recent receipts.</div>;
  }
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {receipts.map((receipt) => (
        <div key={receipt.receipt_id} className="bg-white border border-gray-100 rounded-lg shadow-sm p-4 flex flex-col justify-between min-h-[140px]">
          <div className="flex items-center justify-between mb-2">
            <span className="font-semibold text-gray-700">Receipt #{receipt.receipt_id}</span>
            <StatusBadge status={receipt.status} />
          </div>
          <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-xs text-gray-500 mb-2">
            <div>Aircraft:</div>
            <div className="text-gray-700">{receipt.tail_number} ({receipt.aircraft_type})</div>
            <div>Customer:</div>
            <div className="text-gray-700">{receipt.customer}</div>
            <div>Fuel Type:</div>
            <div className="text-gray-700">{receipt.fuel_type}</div>
            <div>Actual Quantity:</div>
            <div className="text-gray-700">{receipt.calculated_gallons_dispensed}</div>
            <div>Completed:</div>
            <div className="text-gray-700">{receipt.completed_at}</div>
          </div>
          <div>
            <Link to={`/receipts/${receipt.receipt_id}`} className="text-blue-600 hover:underline text-xs font-medium">View Receipt</Link>
          </div>
        </div>
      ))}
    </div>
  );
};

export default RecentReceipts;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/layout/AdminLayout.jsx">
import { useState } from 'react';
import { NavLink, Outlet, useNavigate } from 'react-router-dom';
import { FaTruck, FaUser, FaPlane, FaUsers, FaBars, FaSignOutAlt, FaUserShield, FaKey } from 'react-icons/fa';
import DarkModeToggle from '../common/DarkModeToggle';
import AdminTabBar from './AdminTabBar';
import { useAuth } from '../../contexts/AuthContext';

export default function AdminLayout() {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const navLinks = [
    { to: '/admin/trucks', label: 'Manage Trucks', icon: <FaTruck /> },
    { to: '/admin/users', label: 'Manage Users', icon: <FaUser /> },
    { to: '/admin/aircraft', label: 'Manage Aircraft', icon: <FaPlane /> },
    { to: '/admin/customers', label: 'Manage Customers', icon: <FaUsers /> },
    { to: '/admin/roles', label: 'Manage Roles', icon: <FaUserShield /> },
    { to: '/admin/permissions', label: 'System Permissions', icon: <FaKey /> },
  ];

  const handleLogout = async () => {
    if (window.confirm('Are you sure you want to logout?')) {
      await logout();
      navigate('/login');
    }
  };

  return (
    <div className="min-h-screen flex bg-gradient-to-br from-gray-50 to-blue-50 dark:bg-gray-900 dark:bg-gradient-to-br dark:from-gray-900 dark:to-blue-950 transition-colors duration-300">
      {/* Sidebar */}
      <aside className={`fixed md:static z-30 top-0 left-0 h-full w-64 transition-transform duration-300 ${sidebarOpen ? 'translate-x-0' : '-translate-x-full md:translate-x-0'} backdrop-blur bg-white/80 dark:bg-gray-800 shadow-lg border-r border-gray-200 dark:border-gray-700 rounded-r-2xl md:rounded-none flex flex-col`}>
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <span className="text-xl font-bold tracking-tight text-blue-700 dark:text-yellow-200">Management</span>
          <button className="md:hidden" onClick={() => setSidebarOpen(false)} aria-label="Close sidebar">
            <FaBars />
          </button>
        </div>
        <nav className="flex-1 flex flex-col gap-2 p-4">
          {navLinks.map(link => (
            <NavLink
              key={link.to}
              to={link.to}
              className={({ isActive }) =>
                `flex items-center gap-3 px-4 py-2 rounded-lg transition font-medium ${isActive ? 'bg-blue-100 text-blue-700 shadow' : 'hover:bg-blue-50 text-gray-700'}`
              }
              onClick={() => setSidebarOpen(false)}
            >
              <span className="text-lg">{link.icon}</span> {link.label}
            </NavLink>
          ))}
        </nav>
        <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex items-center gap-3">
          <div className="flex-1">
            <div className="font-semibold text-gray-700 dark:text-yellow-100 text-sm">{user?.name || user?.email || 'User'}</div>
            <button 
              onClick={handleLogout}
              className="flex items-center gap-2 text-xs text-gray-400 dark:text-gray-300 hover:text-blue-700 dark:hover:text-yellow-200 mt-1"
            >
              <FaSignOutAlt /> Logout
            </button>
          </div>
        </div>
      </aside>
      {/* Main Content */}
      <div className="flex-1 flex flex-col min-h-screen">
        {/* Topbar */}
        <header className="flex items-center justify-between px-4 py-3 bg-white/80 dark:bg-gray-800 backdrop-blur shadow-sm border-b border-gray-200 dark:border-gray-700 sticky top-0 z-20">
          <div className="flex items-center gap-4">
            <button onClick={() => setSidebarOpen(true)} aria-label="Open sidebar" className="text-blue-700 dark:text-yellow-200 text-xl md:hidden"><FaBars /></button>
            <a href="/" className="flex items-center gap-1 px-2 py-1 rounded hover:bg-blue-50 dark:hover:bg-gray-700 text-blue-600 dark:text-yellow-200 font-medium text-sm transition">
              <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" /></svg>
              Back to Dashboard
            </a>
          </div>
          <DarkModeToggle className="ml-4" />
        </header>
        <main className="flex-1 p-4 md:p-8">
          <h1 className="text-2xl font-bold mb-2 text-gray-900 dark:text-white">System Management</h1>
          <AdminTabBar />
          <Outlet />
        </main>
      </div>
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/components/layout/AdminTabBar.jsx">
import React from "react";
import { NavLink } from "react-router-dom";

const tabs = [
  { name: "Fuel Trucks", path: "/admin/trucks" },
  { name: "Users", path: "/admin/users" },
  { name: "Aircraft", path: "/admin/aircraft" },
  { name: "Customers", path: "/admin/customers" },
  { name: "Roles", path: "/admin/roles" },
];

export default function AdminTabBar() {
  return (
    <div className="w-full flex gap-2 bg-gray-900 dark:bg-gray-900 border-b border-gray-700 px-2 pt-2 pb-0 mb-4">
      {tabs.map((tab) => (
        <NavLink
          key={tab.path}
          to={tab.path}
          className={({ isActive }) =>
            `px-4 py-2 rounded-t-md font-medium text-sm focus:outline-none transition-colors duration-150
            ${isActive ?
              "bg-gray-800 dark:bg-gray-800 text-blue-400 dark:text-yellow-300 border-b-2 border-blue-400 dark:border-yellow-400" :
              "bg-gray-900 dark:bg-gray-900 text-gray-400 dark:text-gray-400 hover:bg-gray-800 hover:text-blue-300 dark:hover:text-yellow-200"}`
          }
        >
          {tab.name}
        </NavLink>
      ))}
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/components/layout/Navbar.jsx">
import React from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import DarkModeToggle from '../common/DarkModeToggle';

const Navbar = () => {
  const { user } = useAuth();
  return (
    <nav className="w-full bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-800 shadow-sm h-16 flex items-center justify-between px-6 z-50">
      <div className="flex items-center gap-2">
        <span className="text-blue-500 dark:text-yellow-400 font-bold text-lg tracking-tight flex items-center">
          {/* Logo placeholder */}
          <svg className="h-6 w-6 mr-1 text-blue-400 dark:text-yellow-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><circle cx="12" cy="12" r="10" strokeWidth="2" /></svg>
          FBO LaunchPad
        </span>
        {/* Admin link will be shown but protected by backend permissions */}
        <Link
          to="/admin/trucks"
          className="ml-6 px-3 py-1 rounded text-blue-700 dark:text-yellow-200 bg-blue-100 dark:bg-gray-700 hover:bg-blue-200 dark:hover:bg-gray-600 text-sm font-medium"
        >
          Admin
        </Link>
      </div>
      <div className="flex items-center gap-6">
        {/* Notification Icon */}
        <button className="relative text-gray-500 dark:text-gray-300 hover:text-blue-500 dark:hover:text-yellow-400 focus:outline-none">
          <span className="sr-only">Notifications</span>
          <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>
        </button>
        {/* Settings Icon */}
        <button className="text-gray-500 dark:text-gray-300 hover:text-blue-500 dark:hover:text-yellow-400 focus:outline-none">
          <span className="sr-only">Settings</span>
          <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 10c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z" /></svg>
        </button>
        {/* User Dropdown */}
        <div className="flex items-center gap-2">
          <span className="font-semibold text-gray-700 dark:text-yellow-100">{user?.name || user?.email || 'User'}</span>
          <button className="rounded-full bg-gray-200 dark:bg-gray-700 w-8 h-8 flex items-center justify-center text-gray-500 dark:text-yellow-200">
            {/* User avatar placeholder */}
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><circle cx="12" cy="8" r="4" /><path d="M6 20c0-2.21 3.58-4 6-4s6 1.79 6 4" /></svg>
          </button>
        </div>
        {/* Logout Button */}
        <button className="ml-4 px-3 py-1 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded text-gray-700 dark:text-yellow-100 text-sm font-medium border border-gray-300 dark:border-gray-600" onClick={() => {
          // Implement logout logic or call context
          if (window.confirm('Are you sure you want to logout?')) {
            localStorage.removeItem('token');
            window.location.href = '/login';
          }
        }}>
          Logout
        </button>
        <DarkModeToggle className="ml-4" />
      </div>
    </nav>
  );
};

export default Navbar;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/Dashboard.jsx">
import React, { useState } from "react";
import OrderStatusCard from "../dashboard/OrderStatusCard";
import FuelOrdersTable from "./FuelOrdersTable";
import RecentReceipts from "../dashboard/RecentReceipts";
import PaginationControls from "../common/PaginationControls";
import { useNavigate } from "react-router-dom";




const FILTER_TABS = [
  { label: "All Orders", value: "all" },
  { label: "Pending", value: "Pending" },
  { label: "In Progress", value: "In Progress" },
  { label: "Completed", value: "Completed" },
];

const Dashboard = () => {
  const [activeTab, setActiveTab] = useState("all");
  // Placeholder removal: use empty arrays as default; real data will be fetched later
  const [orders] = useState([]);
  const [isLoading] = useState(false);
  const [error] = useState(null);
  const [receipts] = useState([]);
  const navigate = useNavigate();

  const filteredOrders = activeTab === "all"
    ? orders
    : orders.filter((o) => o.status === activeTab);

  const pendingCount = orders.filter(o => o.status === "Pending").length;
  const inProgressCount = orders.filter(o => o.status === "In Progress").length;
  const completedCount = orders.filter(o => o.status === "Completed").length;

  return (
    <div className="space-y-8">
      {/* Status Cards Row */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <OrderStatusCard
          title="Pending Orders"
          count={pendingCount}
          description="Orders waiting for fueling"
          color="bg-yellow-100"
          onViewAll={() => setActiveTab("Pending")}
        />
        <OrderStatusCard
          title="In Progress"
          count={inProgressCount}
          description="Orders currently being fueled"
          color="bg-blue-100"
          onViewAll={() => setActiveTab("In Progress")}
        />
        <OrderStatusCard
          title="Completed Orders"
          count={completedCount}
          description="Recently completed fuel orders"
          color="bg-green-100"
          onViewAll={() => setActiveTab("Completed")}
        />
      </div>

      {/* Fuel Orders Section */}
      <section className="bg-white rounded-lg shadow-sm border border-gray-100 p-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-4 gap-2">
          <div>
            <h2 className="text-lg font-semibold text-gray-800">Fuel Orders</h2>
            <p className="text-sm text-gray-500">Manage and track fuel orders</p>
          </div>
          <div className="flex gap-2 mt-2 md:mt-0">
            <button className="px-3 py-1 bg-gray-100 border border-gray-200 rounded text-gray-700 text-sm font-medium hover:bg-gray-200">Export</button>
            <button className="px-3 py-1 bg-blue-600 text-white rounded text-sm font-medium hover:bg-blue-700" onClick={() => navigate('/orders/new')}>New Order</button>
          </div>
        </div>
        {/* Tabs */}
        <div className="flex gap-2 mb-4">
          {FILTER_TABS.map((tab) => (
            <button
              key={tab.value}
              className={`px-4 py-1 rounded-full text-sm font-medium border transition-colors duration-100 ${
                activeTab === tab.value
                  ? "bg-blue-100 text-blue-700 border-blue-300"
                  : "bg-gray-100 text-gray-600 border-gray-200 hover:bg-blue-50 hover:text-blue-600"
              }`}
              onClick={() => setActiveTab(tab.value)}
            >
              {tab.label}
            </button>
          ))}
        </div>
        {/* Orders Table */}
        <FuelOrdersTable orders={filteredOrders} isLoading={isLoading} error={error} />
        {/* Pagination Controls (if needed) */}
        <div className="mt-4">
          <PaginationControls
            paginationData={{
              page: 1,
              total_pages: 1,
              has_prev: false,
              has_next: false,
              total_items: filteredOrders.length
            }}
            onPageChange={() => {}}
          />
        </div>
      </section>

      {/* Recent Receipts Section */}
      <section className="bg-white rounded-lg shadow-sm border border-gray-100 p-6">
        <h2 className="text-lg font-semibold text-gray-800 mb-4">Recent Fueling Receipts</h2>
        <RecentReceipts receipts={receipts} />
      </section>
    </div>
  );
};

export default Dashboard;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/FuelOrdersTable.jsx">
import React from "react";
import StatusBadge from "../common/StatusBadge";
import { Link } from "react-router-dom";

const FuelOrdersTable = ({ orders = [], isLoading, error }) => {
  if (isLoading) {
    return <div className="py-8 text-center text-gray-400">Loading orders...</div>;
  }
  if (error) {
    return <div className="py-8 text-center text-red-500">{error}</div>;
  }
  if (!orders.length) {
    return <div className="py-8 text-center text-gray-400">No orders found.</div>;
  }
  return (
    <div className="overflow-x-auto bg-white rounded-lg border border-gray-100 shadow-sm">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">ID</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Aircraft</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Customer</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Fuel Type</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Quantity</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Status</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Created</th>
            <th className="px-4 py-2 text-xs font-semibold text-gray-500 uppercase text-left">Actions</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-100">
          {orders.map((order) => (
            <tr key={order.id || order.ID} className="hover:bg-gray-50">
              <td className="px-4 py-2 text-sm text-blue-600 font-semibold">#{order.id || order.ID}</td>
              <td className="px-4 py-2 text-sm">{order.aircraft}</td>
              <td className="px-4 py-2 text-sm">{order.customer}</td>
              <td className="px-4 py-2 text-sm">{order.fuelType}</td>
              <td className="px-4 py-2 text-sm">{order.quantity}</td>
              <td className="px-4 py-2 text-sm"><StatusBadge status={order.status} /></td>
              <td className="px-4 py-2 text-sm">{order.created_at}</td>
              <td className="px-4 py-2 text-sm flex gap-2">
                <Link to={`/orders/${order.id}`} className="text-blue-600 hover:underline text-xs font-medium">View</Link>
                {order.status === "COMPLETED" && (
                  <Link to={`/orders/${order.id}/receipt`} className="text-green-600 hover:underline text-xs font-medium">View Receipt</Link>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default FuelOrdersTable;
</file>

<file path="fbo-launchpad-frontend-csr/src/context/DarkModeContext.jsx">
import React, { createContext, useContext, useEffect, useState } from 'react';

const DarkModeContext = createContext();

export function DarkModeProvider({ children }) {
  const [darkMode, setDarkMode] = useState(() => {
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem('darkMode');
      if (stored !== null) return stored === 'true';
      // Default: match system
      return window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    return false;
  });

  useEffect(() => {
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    localStorage.setItem('darkMode', darkMode);
  }, [darkMode]);

  const toggleDarkMode = () => setDarkMode((prev) => !prev);

  return (
    <DarkModeContext.Provider value={{ darkMode, toggleDarkMode }}>
      {children}
    </DarkModeContext.Provider>
  );
}

export function useDarkMode() {
  return useContext(DarkModeContext);
}
</file>

<file path="fbo-launchpad-frontend-csr/src/hooks/useAdminRole.js">
import { useAuth } from '../contexts/AuthContext';

export default function useAdminRole() {
  const { user } = useAuth();
  // Remove role check - rely on backend permissions
  return true;
}
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/AircraftManagementPage.jsx">
import React, { useEffect, useState } from 'react';
import AircraftService from '../../services/AircraftService';
import AircraftForm from '../../components/admin/AircraftForm';
import Modal from '../../components/common/Modal';
import { FaEdit, FaTrash } from 'react-icons/fa';
import AircraftTable from '../../components/admin/AircraftTable';

export default function AircraftManagementPage() {
  const [aircraftList, setAircraftList] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [showFormModal, setShowFormModal] = useState(false);
  const [editingAircraft, setEditingAircraft] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);

  // Fetch aircraft list
  useEffect(() => {
    fetchAircraft();
  }, []);

  const fetchAircraft = async () => {
    setIsLoading(true);
    setError('');
    try {
      const res = await AircraftService.getAircraft();
      setAircraftList(res.aircraft || []);
    } catch (err) {
      setError(err.message || 'Failed to fetch aircraft');
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreate = () => {
    setEditingAircraft(null);
    setShowFormModal(true);
  };

  const handleEdit = (aircraft) => {
    setEditingAircraft(aircraft);
    setShowFormModal(true);
  };

  const handleDelete = (tail_number) => {
    setDeleteTarget(tail_number);
    setShowDeleteModal(true);
  };

  const handleFormSubmit = async (formData) => {
    setIsSubmitting(true);
    setError('');
    try {
      if (editingAircraft) {
        await AircraftService.updateAircraft(editingAircraft.tail_number, formData);
      } else {
        await AircraftService.createAircraft(formData);
      }
      setShowFormModal(false);
      fetchAircraft();
    } catch (err) {
      setError(err.message || 'Failed to save aircraft');
    } finally {
      setIsSubmitting(false);
    }
  };

  const confirmDelete = async () => {
    if (!deleteTarget) return;
    setIsSubmitting(true);
    setError('');
    try {
      await AircraftService.deleteAircraft(deleteTarget);
      setShowDeleteModal(false);
      fetchAircraft();
    } catch (err) {
      setError(err.message || 'Failed to delete aircraft');
    } finally {
      setIsSubmitting(false);
      setDeleteTarget(null);
    }
  };

  return (
    <div className="max-w-5xl mx-auto py-8">
      <div className="flex items-center justify-between mb-8">
        <h1 className="text-3xl font-bold text-blue-900">Aircraft Management</h1>
        <button className="btn btn-primary shadow-md" onClick={handleCreate}>Add Aircraft</button>
      </div>
      <div className="bg-white/80 backdrop-blur-xl rounded-2xl shadow-xl p-4">
        <AircraftTable
          aircraftList={aircraftList}
          onEdit={handleEdit}
          onDelete={handleDelete}
          isLoading={isLoading}
        />
      </div>
      <Modal
        isOpen={showFormModal}
        onClose={() => setShowFormModal(false)}
        title={editingAircraft ? 'Edit Aircraft' : 'Add Aircraft'}
      >
        <AircraftForm
          initialData={editingAircraft}
          onSubmit={handleFormSubmit}
          isSubmitting={isSubmitting}
          error={error}
        />
      </Modal>
      <Modal
        isOpen={showDeleteModal}
        onClose={() => setShowDeleteModal(false)}
        title="Delete Aircraft"
      >
        <p>Are you sure you want to delete this aircraft?</p>
        <div className="flex gap-2 mt-4">
          <button className="btn btn-danger" onClick={confirmDelete} disabled={isSubmitting}>Delete</button>
          <button className="btn btn-secondary" onClick={() => setShowDeleteModal(false)}>Cancel</button>
        </div>
      </Modal>
      {error && <div className="text-red-600 mt-4">{error}</div>}
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/AssignmentSettingsPage.jsx">
import React, { useEffect, useState } from 'react';
import apiService from '../../services/apiService';

export default function AssignmentSettingsPage() {
  const [autoAssignEnabled, setAutoAssignEnabled] = useState(true);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    async function fetchSetting() {
      setLoading(true);
      setError('');
      try {
        const res = await apiService.get('/api/admin/assignment-settings');
        setAutoAssignEnabled(res.data.auto_assign_enabled);
      } catch (err) {
        setError('Failed to fetch assignment setting.');
      } finally {
        setLoading(false);
      }
    }
    fetchSetting();
  }, []);

  async function handleToggle(e) {
    const value = e.target.checked;
    setAutoAssignEnabled(value);
    setError('');
    setSuccess('');
    try {
      await apiService.post('/api/admin/assignment-settings', { auto_assign_enabled: value });
      setSuccess('Setting updated successfully.');
    } catch (err) {
      setError('Failed to update setting.');
    }
  }

  return (
    <div className="container mx-auto p-6 max-w-lg">
      <h1 className="text-2xl font-bold mb-4">Assignment Settings</h1>
      <div className="flex items-center gap-3 mb-6">
        <input
          type="checkbox"
          id="autoAssignEnabled"
          checked={autoAssignEnabled}
          onChange={handleToggle}
          className="form-checkbox h-5 w-5 text-blue-600"
        />
        <label htmlFor="autoAssignEnabled" className="text-lg font-medium">
          Enable Auto-Assign for LST/Truck
        </label>
      </div>
      {loading && <div>Loading...</div>}
      {error && <div className="text-red-600 mb-2">{error}</div>}
      {success && <div className="text-green-600 mb-2">{success}</div>}
      <div className="text-gray-500 text-sm">
        When enabled, new fuel orders will be assigned automatically to LSTs and trucks. When disabled, orders will appear in a queue for LSTs to claim in their app.
      </div>
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/CustomerManagementPage.jsx">
import React, { useEffect, useState } from 'react';
import CustomerService from '../../services/CustomerService';
import CustomerForm from '../../components/admin/CustomerForm';
import Modal from '../../components/common/Modal';
import { FaEdit, FaTrash } from 'react-icons/fa';
import CustomerTable from '../../components/admin/CustomerTable';

export default function CustomerManagementPage() {
  const [customerList, setCustomerList] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [showFormModal, setShowFormModal] = useState(false);
  const [editingCustomer, setEditingCustomer] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);

  useEffect(() => {
    fetchCustomers();
  }, []);

  const fetchCustomers = async () => {
    setIsLoading(true);
    setError('');
    try {
      const res = await CustomerService.getCustomers();
      setCustomerList(res.customers || []);
    } catch (err) {
      setError(err.message || 'Failed to fetch customers');
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreate = () => {
    setEditingCustomer(null);
    setShowFormModal(true);
  };

  const handleEdit = (customer) => {
    setEditingCustomer(customer);
    setShowFormModal(true);
  };

  const handleDelete = (id) => {
    setDeleteTarget(id);
    setShowDeleteModal(true);
  };

  const handleFormSubmit = async (formData) => {
    setIsSubmitting(true);
    setError('');
    try {
      if (editingCustomer) {
        await CustomerService.updateCustomer(editingCustomer.id, formData);
      } else {
        await CustomerService.createCustomer(formData);
      }
      setShowFormModal(false);
      fetchCustomers();
    } catch (err) {
      setError(err.message || 'Failed to save customer');
    } finally {
      setIsSubmitting(false);
    }
  };

  const confirmDelete = async () => {
    if (!deleteTarget) return;
    setIsSubmitting(true);
    setError('');
    try {
      await CustomerService.deleteCustomer(deleteTarget);
      setShowDeleteModal(false);
      fetchCustomers();
    } catch (err) {
      setError(err.message || 'Failed to delete customer');
    } finally {
      setIsSubmitting(false);
      setDeleteTarget(null);
    }
  };

  return (
    <div className="max-w-5xl mx-auto py-8">
      <div className="flex items-center justify-between mb-8">
        <h1 className="text-3xl font-bold text-blue-900">Customer Management</h1>
        <button className="btn btn-primary shadow-md" onClick={handleCreate}>Add Customer</button>
      </div>
      <div className="bg-white/80 backdrop-blur-xl rounded-2xl shadow-xl p-4">
        <CustomerTable
          customerList={customerList}
          onEdit={handleEdit}
          onDelete={handleDelete}
          isLoading={isLoading}
        />
      </div>
      <Modal
        isOpen={showFormModal}
        onClose={() => setShowFormModal(false)}
        title={editingCustomer ? 'Edit Customer' : 'Add Customer'}
      >
        <CustomerForm
          initialData={editingCustomer}
          onSubmit={handleFormSubmit}
          isSubmitting={isSubmitting}
          error={error}
        />
      </Modal>
      <Modal
        isOpen={showDeleteModal}
        onClose={() => setShowDeleteModal(false)}
        title="Delete Customer"
      >
        <p>Are you sure you want to delete this customer?</p>
        <div className="flex gap-2 mt-4">
          <button className="btn btn-danger" onClick={confirmDelete} disabled={isSubmitting}>Delete</button>
          <button className="btn btn-secondary" onClick={() => setShowDeleteModal(false)}>Cancel</button>
        </div>
      </Modal>
      {error && <div className="text-red-600 mt-4">{error}</div>}
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/PermissionListPage.jsx">
import React, { useState, useEffect } from 'react';
import { Container, Typography, Alert } from '@mui/material';
import PermissionService from '../../services/PermissionService';
import PermissionListTable from '../../components/admin/PermissionListTable';

function PermissionListPage() {
  const [permissions, setPermissions] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const loadPermissions = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const response = await PermissionService.getPermissions();
        setPermissions(response.permissions || []);
      } catch (err) {
        setError(err.message || 'Failed to load permissions');
        console.error('Error loading permissions:', err);
      } finally {
        setIsLoading(false);
      }
    };

    loadPermissions();
  }, []);

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        System Permissions
      </Typography>
      
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <PermissionListTable 
        permissions={permissions}
        isLoading={isLoading}
      />
    </Container>
  );
}

export default PermissionListPage;
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/RoleManagementPage.jsx">
import React, { useState, useEffect } from 'react';
import RoleService from '../../services/RoleService';
import PermissionService from '../../services/PermissionService';
import RoleTable from '../../components/admin/RoleTable';
import RoleForm from '../../components/admin/RoleForm';
import RolePermissionManager from '../../components/admin/RolePermissionManager';
import Modal from '../../components/common/Modal';

const RoleManagementPage = () => {
  // State
  const [roles, setRoles] = useState([]);
  const [allPermissions, setAllPermissions] = useState([]);
  const [selectedRole, setSelectedRole] = useState(null);
  const [assignedPermissions, setAssignedPermissions] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Modal states
  const [roleFormModalOpen, setRoleFormModalOpen] = useState(false);
  const [deleteConfirmModalOpen, setDeleteConfirmModalOpen] = useState(false);
  const [permissionModalOpen, setPermissionModalOpen] = useState(false);

  // Fetch roles and permissions on mount
  useEffect(() => {
    fetchRoles();
    fetchPermissions();
  }, []);

  // Fetch roles
  const fetchRoles = async () => {
    try {
      const data = await RoleService.getRoles();
      setRoles(data);
      setIsLoading(false);
    } catch (err) {
      setError('Failed to fetch roles');
      setIsLoading(false);
    }
  };

  // Fetch permissions
  const fetchPermissions = async () => {
    try {
      const data = await PermissionService.getPermissions();
      setAllPermissions(data);
    } catch (err) {
      setError('Failed to fetch permissions');
    }
  };

  // Fetch role permissions
  const fetchRolePermissions = async (roleId) => {
    try {
      const data = await RoleService.getRolePermissions(roleId);
      setAssignedPermissions(data);
    } catch (err) {
      setError('Failed to fetch role permissions');
    }
  };

  // Create role
  const handleCreate = () => {
    setSelectedRole(null);
    setRoleFormModalOpen(true);
  };

  // Edit role
  const handleEdit = (role) => {
    setSelectedRole(role);
    setRoleFormModalOpen(true);
  };

  // Delete role
  const handleDelete = (role) => {
    setSelectedRole(role);
    setDeleteConfirmModalOpen(true);
  };

  // Manage permissions
  const handleManagePermissions = async (role) => {
    setSelectedRole(role);
    await fetchRolePermissions(role.id);
    setPermissionModalOpen(true);
  };

  // Submit role form
  const handleRoleSubmit = async (formData) => {
    setIsSubmitting(true);
    setError('');

    try {
      if (selectedRole) {
        await RoleService.updateRole(selectedRole.id, formData);
      } else {
        await RoleService.createRole(formData);
      }
      await fetchRoles();
      setRoleFormModalOpen(false);
    } catch (err) {
      setError('Failed to save role');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Confirm role deletion
  const handleDeleteConfirm = async () => {
    setIsSubmitting(true);
    setError('');

    try {
      await RoleService.deleteRole(selectedRole.id);
      await fetchRoles();
      setDeleteConfirmModalOpen(false);
    } catch (err) {
      setError('Failed to delete role');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Assign permission to role
  const handleAssignPermission = async (permissionId) => {
    setIsSubmitting(true);
    setError('');

    try {
      await RoleService.assignPermissionToRole(selectedRole.id, permissionId);
      await fetchRolePermissions(selectedRole.id);
    } catch (err) {
      setError('Failed to assign permission');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Remove permission from role
  const handleRemovePermission = async (permissionId) => {
    setIsSubmitting(true);
    setError('');

    try {
      await RoleService.removePermissionFromRole(selectedRole.id, permissionId);
      await fetchRolePermissions(selectedRole.id);
    } catch (err) {
      setError('Failed to remove permission');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-semibold text-gray-900">Role Management</h1>
        <button
          onClick={handleCreate}
          className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
        >
          Create Role
        </button>
      </div>

      {error && (
        <div className="mb-4 bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error}
        </div>
      )}

      <RoleTable
        roles={roles}
        onEdit={handleEdit}
        onDelete={handleDelete}
        onManagePermissions={handleManagePermissions}
        isLoading={isLoading}
      />

      {/* Role Form Modal */}
      <Modal
        isOpen={roleFormModalOpen}
        onClose={() => setRoleFormModalOpen(false)}
        title={selectedRole ? 'Edit Role' : 'Create Role'}
      >
        <RoleForm
          initialData={selectedRole}
          onSubmit={handleRoleSubmit}
          isSubmitting={isSubmitting}
          error={error}
        />
      </Modal>

      {/* Delete Confirmation Modal */}
      <Modal
        isOpen={deleteConfirmModalOpen}
        onClose={() => setDeleteConfirmModalOpen(false)}
        title="Delete Role"
      >
        <div className="space-y-4">
          <p>Are you sure you want to delete the role "{selectedRole?.name}"?</p>
          <div className="flex justify-end space-x-4">
            <button
              onClick={() => setDeleteConfirmModalOpen(false)}
              className="px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-500"
            >
              Cancel
            </button>
            <button
              onClick={handleDeleteConfirm}
              disabled={isSubmitting}
              className="px-4 py-2 text-sm font-medium text-white bg-red-600 hover:bg-red-700 rounded-md"
            >
              {isSubmitting ? 'Deleting...' : 'Delete'}
            </button>
          </div>
        </div>
      </Modal>

      {/* Permission Management Modal */}
      <Modal
        isOpen={permissionModalOpen}
        onClose={() => setPermissionModalOpen(false)}
        title="Manage Permissions"
      >
        {selectedRole && (
          <RolePermissionManager
            role={selectedRole}
            allPermissions={allPermissions}
            assignedPermissions={assignedPermissions}
            onAssign={handleAssignPermission}
            onRemove={handleRemovePermission}
            isLoading={isSubmitting}
          />
        )}
      </Modal>
    </div>
  );
};

export default RoleManagementPage;
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/TruckManagementPage.jsx">
import React, { useEffect, useState } from 'react';
import FuelTruckService from '../../services/FuelTruckService';
import TruckForm from '../../components/admin/TruckForm';
import Modal from '../../components/common/Modal';
import { FaEdit, FaTrash } from 'react-icons/fa';

export default function TruckManagementPage() {
  const [trucks, setTrucks] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showFormModal, setShowFormModal] = useState(false);
  const [editingTruck, setEditingTruck] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const fetchTrucks = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await FuelTruckService.getFuelTrucks();
      setTrucks(data);
    } catch (e) {
      setError('Failed to load trucks.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTrucks();
  }, []);

  const handleDelete = async (id) => {
    if (!window.confirm('Are you sure you want to delete this truck?')) return;
    try {
      await FuelTruckService.deleteFuelTruck(id);
      fetchTrucks();
    } catch (e) {
      alert('Delete failed.');
    }
  };

  const handleFormSubmit = async (formData) => {
    setIsSubmitting(true);
    try {
      if (editingTruck && editingTruck.id) {
        await FuelTruckService.updateFuelTruck(editingTruck.id, formData);
      } else {
        await FuelTruckService.createFuelTruck(formData);
      }
      setShowFormModal(false);
      setEditingTruck(null);
      fetchTrucks();
    } catch (e) {
      alert('Save failed.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleEdit = (truck) => {
    setEditingTruck(truck);
    setShowFormModal(true);
  };

  const handleCreate = () => {
    setEditingTruck({});
    setShowFormModal(true);
  };

  const handleCloseModal = () => {
    setShowFormModal(false);
    setEditingTruck(null);
  };

  return (
    <div className="max-w-5xl mx-auto py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold text-blue-900">Fuel Truck Management</h1>
        <button className="btn btn-primary shadow-md" onClick={handleCreate}>Create New Truck</button>
      </div>
      <div className="bg-white/80 backdrop-blur-xl rounded-2xl shadow-xl p-4">
        {isLoading ? (
          <div className="py-8 text-center text-blue-600 animate-pulse">Loading trucks...</div>
        ) : error ? (
          <div className="text-red-600 py-8 text-center">{error}</div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm rounded-xl overflow-hidden">
              <thead className="sticky top-0 z-10 bg-blue-50/80">
                <tr>
                  <th className="px-4 py-2 font-semibold text-left">ID</th>
                  <th className="px-4 py-2 font-semibold text-left">Name</th>
                  <th className="px-4 py-2 font-semibold text-left">Active</th>
                  <th className="px-4 py-2 font-semibold text-center">Actions</th>
                </tr>
              </thead>
              <tbody>
                {trucks.map((truck, i) => (
                  <tr key={truck.id} className={i % 2 === 0 ? 'even:bg-gray-50' : ''}>
                    <td className="px-4 py-2 whitespace-nowrap">{truck.id}</td>
                    <td className="px-4 py-2 whitespace-nowrap">{truck.name}</td>
                    <td className="px-4 py-2 whitespace-nowrap">
                      <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${truck.is_active ? 'bg-green-100 text-green-700' : 'bg-gray-200 text-gray-500'}`}>{truck.is_active ? 'Yes' : 'No'}</span>
                    </td>
                    <td className="px-4 py-2 whitespace-nowrap text-center space-x-1">
                      <button
                        className="inline-flex items-center justify-center p-2 rounded hover:bg-blue-100 text-blue-700 transition"
                        title="Edit"
                        onClick={() => handleEdit(truck)}
                      >
                        <FaEdit />
                      </button>
                      <button
                        className="inline-flex items-center justify-center p-2 rounded hover:bg-red-100 text-red-700 transition"
                        title="Delete"
                        onClick={() => handleDelete(truck.id)}
                      >
                        <FaTrash />
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
      <Modal
        isOpen={showFormModal}
        onClose={handleCloseModal}
        title={editingTruck && editingTruck.id ? 'Edit Truck' : 'Create Truck'}
      >
        <TruckForm
          initialData={editingTruck}
          onSubmit={handleFormSubmit}
          onCancel={handleCloseModal}
          isSubmitting={isSubmitting}
        />
      </Modal>
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/admin/UserManagementPage.jsx">
import React, { useEffect, useState } from 'react';
import UserService from '../../services/UserService';
import RoleService from '../../services/RoleService';
import UserForm from '../../components/admin/UserForm';
import Modal from '../../components/common/Modal';
import { FaEdit, FaTrash } from 'react-icons/fa';

export default function UserManagementPage() {
  const [users, setUsers] = useState([]);
  const [availableRoles, setAvailableRoles] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showFormModal, setShowFormModal] = useState(false);
  const [editingUser, setEditingUser] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const fetchData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [usersData, rolesData] = await Promise.all([
        UserService.getUsers(),
        RoleService.getRoles()
      ]);
      setUsers(usersData);
      setAvailableRoles(rolesData.roles || []);
    } catch (e) {
      setError('Failed to load data.');
      console.error('Error loading data:', e);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleDelete = async (id) => {
    if (!window.confirm('Are you sure you want to delete this user?')) return;
    try {
      await UserService.deleteUser(id);
      fetchData();
    } catch (e) {
      alert('Delete failed.');
    }
  };

  const handleFormSubmit = async (formData) => {
    setIsSubmitting(true);
    try {
      if (editingUser && editingUser.id) {
        await UserService.updateUser(editingUser.id, formData);
      } else {
        await UserService.createUser(formData);
      }
      setShowFormModal(false);
      setEditingUser(null);
      fetchData();
    } catch (e) {
      alert('Save failed.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleEdit = (user) => {
    setEditingUser(user);
    setShowFormModal(true);
  };

  const handleCreate = () => {
    setEditingUser(null);
    setShowFormModal(true);
  };

  const handleCloseModal = () => {
    setShowFormModal(false);
    setEditingUser(null);
  };

  return (
    <div className="max-w-5xl mx-auto py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold text-blue-900">User Management</h1>
        <button className="btn btn-primary shadow-md" onClick={handleCreate}>Create New User</button>
      </div>
      <div className="bg-white/80 backdrop-blur-xl rounded-2xl shadow-xl p-4">
        {isLoading ? (
          <div className="py-8 text-center text-blue-600 animate-pulse">Loading users...</div>
        ) : error ? (
          <div className="text-red-600 py-8 text-center">{error}</div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm rounded-xl overflow-hidden">
              <thead className="sticky top-0 z-10 bg-blue-50/80">
                <tr>
                  <th className="px-4 py-2 font-semibold text-left">ID</th>
                  <th className="px-4 py-2 font-semibold text-left">Name</th>
                  <th className="px-4 py-2 font-semibold text-left">Email</th>
                  <th className="px-4 py-2 font-semibold text-left">Roles</th>
                  <th className="px-4 py-2 font-semibold text-left">Active</th>
                  <th className="px-4 py-2 font-semibold text-left">Created At</th>
                  <th className="px-4 py-2 font-semibold text-center">Actions</th>
                </tr>
              </thead>
              <tbody>
                {users.map((user, i) => (
                  <tr key={user.id} className={i % 2 === 0 ? 'even:bg-gray-50' : ''}>
                    <td className="px-4 py-2 whitespace-nowrap">{user.id}</td>
                    <td className="px-4 py-2 whitespace-nowrap">{user.name}</td>
                    <td className="px-4 py-2 whitespace-nowrap">{user.email}</td>
                    <td className="px-4 py-2">
                      <div className="flex flex-wrap gap-1">
                        {user.roles?.map(role => (
                          <span
                            key={role.id}
                            className="inline-block px-2 py-0.5 bg-blue-100 text-blue-800 rounded-full text-xs font-medium"
                          >
                            {role.name}
                          </span>
                        )) || 'No roles'}
                      </div>
                    </td>
                    <td className="px-4 py-2 whitespace-nowrap">
                      <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${user.is_active ? 'bg-green-100 text-green-700' : 'bg-gray-200 text-gray-500'}`}>
                        {user.is_active ? 'Yes' : 'No'}
                      </span>
                    </td>
                    <td className="px-4 py-2 whitespace-nowrap">
                      {user.created_at ? new Date(user.created_at).toLocaleString() : ''}
                    </td>
                    <td className="px-4 py-2 whitespace-nowrap text-center space-x-1">
                      <button
                        className="inline-flex items-center justify-center p-2 rounded hover:bg-blue-100 text-blue-700 transition"
                        title="Edit"
                        onClick={() => handleEdit(user)}
                      >
                        <FaEdit />
                      </button>
                      <button
                        className="inline-flex items-center justify-center p-2 rounded hover:bg-red-100 text-red-700 transition"
                        title="Delete"
                        onClick={() => handleDelete(user.id)}
                      >
                        <FaTrash />
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
      <Modal
        isOpen={showFormModal}
        onClose={handleCloseModal}
        title={editingUser ? 'Edit User' : 'Create User'}
      >
        <UserForm
          initialData={editingUser}
          onSubmit={handleFormSubmit}
          onCancel={handleCloseModal}
          isSubmitting={isSubmitting}
          isEditMode={!!editingUser}
          availableRoles={availableRoles}
        />
      </Modal>
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/lst/QueuedOrdersPage.jsx">
import React, { useEffect, useState } from 'react';
import apiService from '../../services/apiService';

export default function QueuedOrdersPage() {
  const [orders, setOrders] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [accepting, setAccepting] = useState(null);
  const [success, setSuccess] = useState('');

  useEffect(() => {
    async function fetchOrders() {
      setLoading(true);
      setError('');
      try {
        const res = await apiService.get('/api/orders/unassigned');
        setOrders(res.data.orders || []);
      } catch (err) {
        setError('Failed to fetch queued orders.');
      } finally {
        setLoading(false);
      }
    }
    fetchOrders();
  }, []);

  async function handleAccept(orderId) {
    setAccepting(orderId);
    setError('');
    setSuccess('');
    try {
      await apiService.post(`/api/orders/${orderId}/accept`);
      setOrders(orders.filter(o => o.id !== orderId));
      setSuccess('Order accepted!');
    } catch (err) {
      setError('Failed to accept order.');
    } finally {
      setAccepting(null);
    }
  }

  return (
    <div className="container mx-auto p-6 max-w-2xl">
      <h1 className="text-2xl font-bold mb-4">Queued Fuel Orders</h1>
      {loading && <div>Loading...</div>}
      {error && <div className="text-red-600 mb-2">{error}</div>}
      {success && <div className="text-green-600 mb-2">{success}</div>}
      {orders.length === 0 && !loading && (
        <div className="text-gray-500">No queued orders at this time.</div>
      )}
      <ul className="space-y-4">
        {orders.map(order => (
          <li key={order.id} className="bg-white dark:bg-gray-800 rounded shadow p-4 flex flex-col gap-2 border border-gray-100 dark:border-gray-700">
            <div className="flex justify-between items-center">
              <div>
                <div className="font-semibold">Tail #: {order.tail_number}</div>
                <div className="text-sm text-gray-500">Requested: {order.requested_amount} gal</div>
                <div className="text-sm text-gray-500">Location: {order.location_on_ramp}</div>
              </div>
              <button
                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
                onClick={() => handleAccept(order.id)}
                disabled={accepting === order.id}
              >
                {accepting === order.id ? 'Accepting...' : 'Accept'}
              </button>
            </div>
            <div className="text-xs text-gray-400">Created: {order.created_at}</div>
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="fbo-launchpad-frontend-csr/src/services/AircraftService.js">
import apiService from './apiService';

export const getAircraft = async (params = {}) => {
  try {
    // Placeholder for GET /api/admin/aircraft
    // Return mock structure
    return { aircraft: [], pagination: {} };
  } catch (error) {
    console.error('Error fetching aircraft:', error);
    throw { message: 'Failed to fetch aircraft' };
  }
};

export const getAircraftById = async (id) => {
  try {
    // Placeholder for GET /api/admin/aircraft/{id}
    return { aircraft: {} };
  } catch (error) {
    console.error('Error fetching aircraft by id:', error);
    throw { message: 'Failed to fetch aircraft' };
  }
};

export const createAircraft = async (aircraftData) => {
  try {
    // Placeholder for POST /api/admin/aircraft
    return { aircraft: {} };
  } catch (error) {
    console.error('Error creating aircraft:', error);
    throw { message: 'Failed to create aircraft' };
  }
};

export const updateAircraft = async (id, aircraftData) => {
  try {
    // Placeholder for PATCH /api/admin/aircraft/{id}
    return { aircraft: {} };
  } catch (error) {
    console.error('Error updating aircraft:', error);
    throw { message: 'Failed to update aircraft' };
  }
};

export const deleteAircraft = async (id) => {
  try {
    // Placeholder for DELETE /api/admin/aircraft/{id}
    return {};
  } catch (error) {
    console.error('Error deleting aircraft:', error);
    throw { message: 'Failed to delete aircraft' };
  }
};

const AircraftService = {
  getAircraft,
  getAircraftById,
  createAircraft,
  updateAircraft,
  deleteAircraft
};

export default AircraftService;
</file>

<file path="fbo-launchpad-frontend-csr/src/services/CustomerService.js">
import apiService from './apiService';

export const getCustomers = async (params = {}) => {
  try {
    // Placeholder for GET /api/admin/customers
    return { customers: [], pagination: {} };
  } catch (error) {
    console.error('Error fetching customers:', error);
    throw { message: 'Failed to fetch customers' };
  }
};

export const getCustomerById = async (id) => {
  try {
    // Placeholder for GET /api/admin/customers/{id}
    return { customer: {} };
  } catch (error) {
    console.error('Error fetching customer by id:', error);
    throw { message: 'Failed to fetch customer' };
  }
};

export const createCustomer = async (customerData) => {
  try {
    // Placeholder for POST /api/admin/customers
    return { customer: {} };
  } catch (error) {
    console.error('Error creating customer:', error);
    throw { message: 'Failed to create customer' };
  }
};

export const updateCustomer = async (id, customerData) => {
  try {
    // Placeholder for PATCH /api/admin/customers/{id}
    return { customer: {} };
  } catch (error) {
    console.error('Error updating customer:', error);
    throw { message: 'Failed to update customer' };
  }
};

export const deleteCustomer = async (id) => {
  try {
    // Placeholder for DELETE /api/admin/customers/{id}
    return {};
  } catch (error) {
    console.error('Error deleting customer:', error);
    throw { message: 'Failed to delete customer' };
  }
};

const CustomerService = {
  getCustomers,
  getCustomerById,
  createCustomer,
  updateCustomer,
  deleteCustomer
};

export default CustomerService;
</file>

<file path="fbo-launchpad-frontend-csr/src/services/PermissionService.js">
import apiService from './apiService';

class PermissionService {
  async getPermissions() {
    try {
      const response = await apiService.get('/api/admin/permissions');
      return response.data;
    } catch (error) {
      throw error;
    }
  }
}

export default new PermissionService();
</file>

<file path="fbo-launchpad-frontend-csr/src/services/RoleService.js">
import apiService from './apiService';

class RoleService {
  async getRoles() {
    try {
      const response = await apiService.get('/api/admin/roles');
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async createRole(data) {
    try {
      const response = await apiService.post('/api/admin/roles', data);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async getRoleById(id) {
    try {
      const response = await apiService.get(`/api/admin/roles/${id}`);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async updateRole(id, data) {
    try {
      const response = await apiService.put(`/api/admin/roles/${id}`, data);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async deleteRole(id) {
    try {
      const response = await apiService.delete(`/api/admin/roles/${id}`);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async getRolePermissions(id) {
    try {
      const response = await apiService.get(`/api/admin/roles/${id}/permissions`);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async assignPermissionToRole(roleId, permissionId) {
    try {
      const response = await apiService.post(`/api/admin/roles/${roleId}/permissions/${permissionId}`);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async removePermissionFromRole(roleId, permissionId) {
    try {
      const response = await apiService.delete(`/api/admin/roles/${roleId}/permissions/${permissionId}`);
      return response.data;
    } catch (error) {
      throw error;
    }
  }
}

export default new RoleService();
</file>

<file path="fbo-launchpad-frontend-csr/src/utils/jwt.js">
import { jwtDecode } from 'jwt-decode';

export function decodeJWT(token) {
  if (!token) return null;
  try {
    return jwtDecode(token);
  } catch (e) {
    return null;
  }
}
</file>

<file path="fbo-launchpad-frontend-csr/tasks/active_Context.md">
# Active Context

## Current Development Focus
- CSR Dashboard implementation
- Real-time order tracking
- Frontend-backend integration

## Recent Changes and Learnings

Admin User Management (2025-04-25)

- Admin section now includes fully functional User Management page for Admins.
- Users can be listed, created, edited (name, email, role, is_active), and deleted.
- Password is only required for creation, not for editing.
- Admin User Management section is complete, establishing a pattern for CRUD operations within the admin area.
- Admin Aircraft and Customer Management sections are now scaffolded in the frontend, mirroring the User/Truck admin pattern. This includes placeholder API services, reusable forms, placeholder tables, full page components, and admin routing. Ready for backend API integration.
- UI/UX and component structure matches the Truck Management pattern for consistency.
- All code changes documented in progress.md.

### Dashboard Component Migration (2024-03-26)
1. **Component Replacement Strategy**
   - MISCONCEPTION: Initially attempted to add new Dashboard component alongside existing implementation
   - RESOLUTION: Needed to completely replace old implementation in DashboardPage
   - LEARNING: When replacing core functionality, ensure clean transition rather than parallel implementation

2. **Routing Structure Understanding**
   - MISCONCEPTION: Assumed MainLayout children prop was correct approach
   - RESOLUTION: Updated to use react-router-dom's `Outlet` component
   - LEARNING: In React Router v6, nested routes require `Outlet` for child route rendering

3. **Component Architecture**
   - Previous: Complex state management in DashboardPage
   - Current: Moved to modular components with clear responsibilities
   - Benefits: Better separation of concerns, improved maintainability

### Implementation Details
1. **Component Structure**
   ```
   DashboardPage
   └── Dashboard
       ├── OrderStatusCard (x3)
       └── FuelOrdersTable
   ```

2. **State Management**
   - Moved from page-level to component-level state
   - Implemented custom hooks for data fetching
   - Centralized order status tracking

3. **UI Components**
   - Created reusable status cards
   - Implemented responsive table layout
   - Added consistent loading states

### Current Technical Decisions
1. **Component Architecture**
   - Using functional components with TypeScript
   - Implementing custom hooks for data fetching
   - Following atomic design principles

2. **State Management**
   - React hooks for local state
   - Custom hooks for shared logic
   - JWT token in localStorage
   - Real-time updates via API polling

3. **UI/UX Patterns**
   - Consistent color scheme for status indicators
   - Responsive design for all screen sizes
   - Clear loading and error states
   - Intuitive action buttons

## Important Notes for Other AI Agents
1. **Component Replacement**
   - When implementing new versions of existing components:
     - Don't try to maintain both versions
     - Ensure clean replacement strategy
     - Update all related components and routes
     - Verify proper cleanup of old implementation

2. **React Router v6 Patterns**
   - Always use `Outlet` for nested routes
   - Don't use children prop in layout components
   - Maintain proper route hierarchy
   - Protected routes should wrap layout components

3. **State Management**
   - Prefer component-level state when possible
   - Use custom hooks for shared logic
   - Implement proper error boundaries
   - Consider data fetching patterns

4. **Common Pitfalls to Avoid**
   - Don't mix old and new implementations
   - Don't assume children prop for route-based layouts
   - Don't duplicate state management
   - Don't skip proper component hierarchy

## Next Steps
1. Implement order filtering and sorting
2. Add pagination to orders table
3. Enhance error handling
4. Add loading skeletons
5. Implement real-time updates

## Current Issues
1. Need to verify API integration
2. Consider implementing websockets
3. Add proper error boundaries
4. Enhance loading states

## Development Notes
- Run npm commands from frontend directory
- Ensure proper route protection
- Maintain consistent state management
- Follow established component patterns

## Active Decisions
1. Component Architecture
   - Using functional components with TypeScript
   - Implementing custom hooks for data fetching
   - Utilizing Tailwind CSS for styling
   - Following atomic design principles

2. State Management
   - Using React hooks for local state
   - Implementing custom hooks for shared logic
   - JWT token stored in localStorage
   - Real-time updates through API polling

3. UI/UX Patterns
   - Consistent color scheme for status indicators
   - Responsive design for all screen sizes
   - Loading states and error messages
   - Action buttons with clear visual hierarchy

## Current Considerations
1. Performance
   - Monitoring API response times
   - Optimizing component re-renders
   - Implementing proper loading states
   - Considering pagination for large datasets

2. Security
   - JWT token management
   - API endpoint protection
   - Input validation
   - Error handling

3. User Experience
   - Clear status indicators
   - Intuitive navigation
   - Responsive feedback
   - Accessible design

## Project Insights
1. Component Organization
   - Separate concerns between presentation and logic
   - Reusable components for common patterns
   - Consistent naming conventions
   - Clear component hierarchy

2. Data Flow
   - API integration through custom hooks
   - Centralized error handling
   - Consistent data transformation
   - Type safety with TypeScript

3. Development Patterns
   - Component-first development
   - Test-driven development (planned)
   - Consistent code style
   - Documentation-driven development

### Current Issues
1. **Styling Not Applying**
   - Styles defined but not visible in the UI
   - PostCSS plugins installed and configured
   - Build process may need investigation
   - Vite configuration may need review
   - Style injection in development mode needs verification

### Development Notes
- Run npm commands from frontend directory (`fbo-launchpad-frontend-csr`)
- PostCSS configuration updated to use proper plugins
- Using postcss-nesting for CSS nesting support
- Using postcss-import for proper CSS imports
- Config files use ES module syntax
- Need to investigate why styles aren't being applied despite proper configuration

### Next Steps
1. Investigate why styles aren't applying:
   - Check Vite's style handling configuration
   - Verify style injection in development mode
   - Review build process for CSS
   - Check for style conflicts or overrides
   - Verify correct loading order of styles

2. Once styles are working:
   - Complete component styling migration
   - Implement responsive design
   - Add loading states
   - Enhance error handling

// ... existing code ...
</file>

<file path="fbo-launchpad-frontend-csr/tasks/progress.md">
# Project Progress & Agent Guidance

## Table of Contents (TOC)
- [Project Overview](#project-overview)
- [Key Milestones](#key-milestones)
- [Potential Error Sources](#potential-error-sources)
- [Current Blockers & Technical Debt](#current-blockers--technical-debt)
- [Actionable Next Steps](#actionable-next-steps)
- [Cross-References](#cross-references)
- [Future Agent Guidance](#future-agent-guidance)

---

## Project Overview
- Modern React SPA for FBO order management
- Auth: JWT, role-based
- API: RESTful, Axios
- Styling: Tailwind CSS, PostCSS
- See [projectbrief.md](projectbrief.md) for structure, stack, and security

## Key Milestones
- **Auth & Routing**: AuthContext, token persistence, protected routes
- **Order Management**: CRUD, filters, pagination, CSV export
- [x] Admin User Management frontend complete and tested.
- [x] Admin Truck Management frontend complete and tested.
- [x] Admin Aircraft Management frontend structure scaffolded (placeholder service, form, table, page, routing).
- [x] Admin Customer Management frontend structure scaffolded (placeholder service, form, table, page, routing).
- **Testing**: Vitest, React Testing Library, backend pytest
- **UI/UX**: Responsive, loading/error states, modular components
- **Styling**: Tailwind/PostCSS config (see [ui_implementation.md](ui_implementation.md))

## Potential Error Sources
- **JWT Handling**: Token not decoded/persisted; see `src/contexts/AuthContext.jsx`, `src/utils/jwt.js`
- **API Endpoints**: Trailing slash required; see `/services/*Service.js`, backend Flask config
- **CORS**: Must match frontend origin; see backend `src/app.py`
- **User Model**: Uses `username`, not `name`; check all user code
- **Styling**: Tailwind/PostCSS build issues block all styles (see [ui_implementation.md](ui_implementation.md))
- **Routing**: React Router v6 requires `Outlet` for nesting; avoid `children` prop
- **Error Boundaries**: Not implemented; see [testingContext.md](testingContext.md)
- **Form Validation**: Minimal; production needs robust validation
- **JWT Expiry**: No refresh/expiry handling

## Current Blockers & Technical Debt
- [ ] Styles not applying (verify Vite/PostCSS/Tailwind config, import order)
- [ ] No error boundary (app can crash on error)
- [ ] No loading skeletons (poor UX during API fetch)
- [ ] No E2E tests (critical flows untested)
- [ ] JWT refresh/expiration not handled
- [ ] No websockets for real-time updates
- [ ] Incomplete test coverage ([testingContext.md](testingContext.md))

## Actionable Next Steps
- QA the Admin User Management flows (CRUD, validation, error handling)
- Connect to live backend and verify integration
- Debug and fix Tailwind/PostCSS/Vite config for styling
- Implement error boundary at root
- Add loading skeletons to major components
- Add E2E tests for login, order creation, and dashboard flows
- Implement JWT refresh/expiration logic
- Evaluate WebSocket integration for real-time updates
- Expand component/unit/integration test coverage

## Cross-References
- [Active Context](activeContext.md): Current focus, immediate blockers
- [Project Brief](projectbrief.md): Structure, stack, security
- [System Patterns](systemPatterns.md): Architecture, component/data patterns
- [Technical Context](techContext.md): Stack, workflow, deployment
- [Testing Context](testingContext.md): Test/QC status
- [UI Implementation](ui_implementation.md): Styling, accessibility, UI priorities

## Future Agent Guidance
- Cross-check backend/frontend model fields for naming consistency
- Update both API service and backend routes when adding endpoints
- Use this file as a high-level index; deep dives are in specialized memory-bank files
- Keep all memory-bank files concise, non-redundant, and cross-linked
- Avoid duplicating details—link to the relevant file instead
- Always document new error sources, blockers, and technical debt here and in the relevant specialized file

---

**For deep dives, see:**
- [activeContext.md](activeContext.md)
- [projectbrief.md](projectbrief.md)
- [systemPatterns.md](systemPatterns.md)
- [techContext.md](techContext.md)
- [testingContext.md](testingContext.md)
- [ui_implementation.md](ui_implementation.md)

- [2024-05-01] Backend refactor: Implemented LST auto-assign (-1) in POST /api/fuel-orders, added GET /api/fuel-orders/stats/status-counts endpoint, updated docstrings and OpenAPI docs, and removed obsolete queue/global assign logic. Frontend should use -1 for auto-assign and the new stats endpoint for dashboard counts.
</file>

<file path="tasks/active_context.md">
# Active Context

## Current Focus
- Completed frontend PBAC integration
- Removed all role-based UI checks and conditional rendering
- Updated components to rely on backend permission enforcement
- Simplified frontend authorization logic

## Recent Changes
1. Frontend PBAC Integration:
   - Removed AdminRoute component and role-based route protection
   - Updated AuthContext to store complete user data
   - Removed role-based UI conditionals from Navbar and AdminLayout
   - Updated OrderCreatePage to use permission-based filtering
   - Simplified frontend authorization by relying on backend permission checks

## Current State
- Backend enforces authorization via granular permissions
- Frontend no longer performs role-based access control
- UI components rely on backend 403 responses for unauthorized actions
- Navigation and UI elements are shown/hidden based on backend permissions

## Next Steps
1. Test all admin routes to ensure proper handling of 403 responses
2. Verify error message display for unauthorized actions
3. Update user documentation to reflect the new permission-based system
4. Consider implementing frontend permission caching if needed for performance

## Known Issues
- None currently identified

## Dependencies
- Backend PBAC implementation complete and functional
- Frontend error handling system in place for 403 responses

## Current Status

### PBAC Frontend Implementation (Phase 4)
- Completed Role Management UI implementation:
  - Created API services for roles and permissions
  - Built reusable components for role management:
    - RoleTable: List and manage roles
    - RoleForm: Create/edit role details
    - RolePermissionManager: Assign/remove permissions
  - Implemented RoleManagementPage with full functionality:
    - Role CRUD operations
    - Permission assignment/removal
    - Error handling and loading states
  - Added navigation and routing:
    - New /admin/roles route
    - Sidebar and tab navigation
    - Integration with existing admin layout
- Next focus: User-Role Assignment UI implementation
  - Will extend UserManagementPage
  - Need to integrate with role assignment endpoints

### Previous Milestones

### PBAC Migration Script Verification
- Completed verification of PBAC migration script (05eadf8716a5)
- Confirmed correct implementation of:
  - Permission seeding (21 permissions)
  - Role creation and permission assignments
  - User role migration
- No discrepancies found in the implementation
- Migration logic handles edge cases appropriately
- Operations are performed in correct order
</file>

<file path="tasks/tasks_plan.md">
# Tasks Plan

## Completed Tasks
- [x] Phase 4: Frontend PBAC Integration
  - [x] Step 1: Update Admin UI components for PBAC
  - [x] Step 2: Implement permission-based UI rendering
  - [x] Step 3: Update route protection
  - [x] Step 4: Remove legacy role-based checks
    - [x] Remove AdminRoute component
    - [x] Update AuthContext to store complete user data
    - [x] Remove role-based UI conditionals
    - [x] Update API calls to use permission-based filtering

## Current Tasks
- [ ] Testing and Validation
  - [ ] Test admin routes for proper 403 handling
  - [ ] Verify error message display
  - [ ] Update user documentation

## Upcoming Tasks
- [ ] Performance Optimization
  - [ ] Consider implementing frontend permission caching
  - [ ] Optimize API calls for permission checks

## Backlog
- [ ] User documentation updates
- [ ] System monitoring implementation
- [ ] Performance metrics collection

### PBAC Implementation (Phase 4)
- [x] Step 1: Implement Admin Role Management UI
  - [x] Created RoleService and PermissionService for API integration
  - [x] Implemented RoleTable, RoleForm, and RolePermissionManager components
  - [x] Created RoleManagementPage with full CRUD and permission management
  - [x] Added routing and navigation in AdminLayout
  - Result: Complete role management interface with permission assignment capabilities

### Next Steps
- [ ] Step 2: Implement User-Role Assignment UI
  - [ ] Create UserRoleManager component
  - [ ] Update UserManagementPage to include role assignments
  - [ ] Integrate with backend role assignment endpoints

### Completed Tasks

### Pytest Fix Plan (Phase 1)
- [x] Step 3: Verify PBAC migration script implementation
  - [x] Analyzed permission seeding logic
  - [x] Verified role creation and permission assignments
  - [x] Confirmed user role migration process
  - [x] Validated operation order and edge case handling
  - Result: All implementations correct, no fixes needed
</file>

<file path="fbo-launchpad-backend/.cursor/rules/error-documentation.mdc">
---
description: Error documentation
globs: 
alwaysApply: false
---
# Error Documentation

## Database Transaction Management

### Pattern: SQLAlchemy Session Rollback
When handling database operations that may fail, always:
1. Wrap operations in try-except blocks
2. Catch specific exceptions (IntegrityError, SQLAlchemyError)
3. Roll back the session on error
4. Return appropriate error status codes

Example from RoleService:
```python
try:
    # Database operations...
    db.session.commit()
except IntegrityError:
    db.session.rollback()
    return None, "Role name must be unique", 409
except SQLAlchemyError as e:
    db.session.rollback()
    return None, f"Database error: {str(e)}", 500
```

### Pattern: Many-to-Many Relationship Management
When managing many-to-many relationships:
1. Clear relationships before deletion (e.g., `role.permissions = []`)
2. Check for existing relationships before adding (e.g., `permission in role.permissions`)
3. Verify both entities exist before establishing relationship
4. Handle removal of non-existent relationships gracefully

Example from RoleService:
```python
# Before deleting role
role.permissions = []  # Clear relationships
db.session.delete(role)

# Before adding relationship
if permission in role.permissions:
    return role, "Permission already assigned to role", 200
```

### Pattern: Cascading Delete Protection
Before deleting entities that may have dependent relationships:
1. Check for existing dependencies
2. Return appropriate error if dependencies exist
3. Clear relationships if deletion is allowed

Example from RoleService:
```python
if role.users.first():
    return False, "Cannot delete role: Users are currently assigned to this role", 409
```

## Input Validation

### Pattern: Required Field Validation
Always validate required fields before database operations:
```python
if not data.get('name'):
    return None, "Role name is required", 400
```

### Pattern: Uniqueness Validation
When updating unique fields:
1. Check for duplicates excluding current entity
2. Use appropriate filters in query
3. Handle IntegrityError as backup

Example:
```python
existing_role = Role.query.filter(
    Role.name == data['name'],
    Role.id != role_id
).first()
if existing_role:
    return None, f"Role with name '{data['name']}' already exists", 409
```
</file>

<file path="fbo-launchpad-backend/.cursor/rules/lessons-learned.mdc">
---
description: 
globs: 
alwaysApply: false
---
# Lessons Learned

## SQLAlchemy Best Practices

### Many-to-Many Relationship Management
1. **Eager Loading**
   - Use `selectinload` for many-to-many relationships to prevent N+1 queries
   - Example from UserService:
   ```python
   User.query.options(db.selectinload(User.roles))
   ```
   - Prefer `selectinload` over `joinedload` for collections unless you need filtering

2. **Relationship Assignment**
   - Directly assign lists of model objects to relationship attributes
   - SQLAlchemy handles the association table updates automatically
   - Example:
   ```python
   user.roles = roles  # SQLAlchemy manages user_roles table inserts/deletes
   ```

3. **Input Validation**
   - Validate both format and content of relationship IDs
   - Check for list type and non-empty requirements
   - Verify all IDs exist before assignment
   - Example from UserService:
   ```python
   if not isinstance(role_ids, list):
       return None, "Invalid role_ids format, must be a list", 400
   roles = Role.query.filter(Role.id.in_(role_ids)).all()
   if len(roles) != len(set(role_ids)):
       found_ids = {role.id for role in roles}
       invalid_ids = set(role_ids) - found_ids
       return None, f"Invalid role IDs provided: {list(invalid_ids)}", 400
   ```

4. **Empty Relationship Handling**
   - Allow explicit clearing of relationships with empty lists
   - Validate business rules for required relationships
   - Example:
   ```python
   if not role_ids:  # Empty list check
       return None, "At least one role must be assigned", 400
   ```

## API Design Patterns

### Request/Response Structure
1. **Consistent Return Format**
   - Use tuple pattern: (result, message, status_code)
   - Return None for data on errors
   - Include descriptive error messages
   - Example:
   ```python
   return user, "User created successfully", 201
   return None, "Invalid role IDs provided", 400
   ```

2. **Input Validation Hierarchy**
   - Validate format before content
   - Check required fields first
   - Validate relationships after basic fields
   - Example order:
   ```python
   # 1. Required fields
   if not all(key in data for key in ['email', 'password', 'role_ids']):
       return None, "Missing required fields", 400
   # 2. Format validation
   if not isinstance(role_ids, list):
       return None, "Invalid format", 400
   # 3. Content validation
   if User.query.filter_by(email=data['email']).first():
       return None, "Email already registered", 409
   # 4. Relationship validation
   roles = Role.query.filter(Role.id.in_(role_ids)).all()
   ```

## Migration Strategies

### Enum to Many-to-Many Migration
1. **Staged Approach**
   - First create new tables and relationships
   - Then migrate data from old to new structure
   - Finally remove old fields/tables
   - Keep backward compatibility during transition

2. **Data Validation**
   - Verify all data is migrated correctly
   - Ensure no access is lost during migration
   - Maintain data integrity throughout process

3. **Code Updates**
   - Update service layer first
   - Then update route handlers
   - Finally update frontend integration
   - Test thoroughly at each stage
</file>

<file path="fbo-launchpad-backend/migrations/versions/1a764e4d3fa2_add_fuel_truck_customer_aircraft_fuel_.py">
"""Add fuel truck, customer, aircraft, fuel order tables

Revision ID: 1a764e4d3fa2
Revises: 1ba38c67c062
Create Date: 2025-04-23 02:31:11.923838

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '1a764e4d3fa2'
down_revision = '1ba38c67c062'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('customers',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=150), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('fuel_trucks',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('aircraft',
    sa.Column('tail_number', sa.String(length=20), nullable=False),
    sa.Column('customer_id', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ),
    sa.PrimaryKeyConstraint('tail_number')
    )
    op.create_table('fuel_orders',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('status', sa.Enum('DISPATCHED', 'ACKNOWLEDGED', 'EN_ROUTE', 'FUELING', 'COMPLETED', 'REVIEWED', 'CANCELLED', name='fuelorderstatus'), nullable=False),
    sa.Column('tail_number', sa.String(length=20), nullable=False),
    sa.Column('customer_id', sa.Integer(), nullable=True),
    sa.Column('fuel_type', sa.String(length=50), nullable=False),
    sa.Column('additive_requested', sa.Boolean(), nullable=True),
    sa.Column('requested_amount', sa.Numeric(precision=10, scale=2), nullable=True),
    sa.Column('assigned_lst_user_id', sa.Integer(), nullable=True),
    sa.Column('assigned_truck_id', sa.Integer(), nullable=True),
    sa.Column('location_on_ramp', sa.String(length=100), nullable=True),
    sa.Column('csr_notes', sa.Text(), nullable=True),
    sa.Column('lst_notes', sa.Text(), nullable=True),
    sa.Column('start_meter_reading', sa.Numeric(precision=12, scale=2), nullable=True),
    sa.Column('end_meter_reading', sa.Numeric(precision=12, scale=2), nullable=True),
    sa.Column('calculated_gallons_dispensed', sa.Numeric(precision=10, scale=2), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('dispatch_timestamp', sa.DateTime(), nullable=True),
    sa.Column('acknowledge_timestamp', sa.DateTime(), nullable=True),
    sa.Column('en_route_timestamp', sa.DateTime(), nullable=True),
    sa.Column('fueling_start_timestamp', sa.DateTime(), nullable=True),
    sa.Column('completion_timestamp', sa.DateTime(), nullable=True),
    sa.Column('reviewed_timestamp', sa.DateTime(), nullable=True),
    sa.Column('reviewed_by_csr_user_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['assigned_lst_user_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['assigned_truck_id'], ['fuel_trucks.id'], ),
    sa.ForeignKeyConstraint(['customer_id'], ['customers.id'], ),
    sa.ForeignKeyConstraint(['reviewed_by_csr_user_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['tail_number'], ['aircraft.tail_number'], ),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_fuel_orders_assigned_lst_user_id'), ['assigned_lst_user_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_assigned_truck_id'), ['assigned_truck_id'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_status'), ['status'], unique=False)
        batch_op.create_index(batch_op.f('ix_fuel_orders_tail_number'), ['tail_number'], unique=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('fuel_orders', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_fuel_orders_tail_number'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_status'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_assigned_truck_id'))
        batch_op.drop_index(batch_op.f('ix_fuel_orders_assigned_lst_user_id'))

    op.drop_table('fuel_orders')
    op.drop_table('aircraft')
    op.drop_table('fuel_trucks')
    op.drop_table('customers')
    # ### end Alembic commands ###
</file>

<file path="fbo-launchpad-backend/migrations/versions/1ba38c67c062_create_user_table.py">
"""Create user table

Revision ID: 1ba38c67c062
Revises: 
Create Date: 2025-04-23 01:51:39.793455

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '1ba38c67c062'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.Column('role', sa.Enum('LST', 'CSR', 'ADMIN', name='userrole'), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=False),
    sa.Column('updated_at', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_users_email'), ['email'], unique=True)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_users_email'))

    op.drop_table('users')
    # ### end Alembic commands ###
</file>

<file path="fbo-launchpad-backend/migrations/alembic.ini">
# A generic, single database configuration.

[alembic]
# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false


# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic,flask_migrate

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[logger_flask_migrate]
level = INFO
handlers =
qualname = flask_migrate

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="fbo-launchpad-backend/migrations/env.py">
import logging
from logging.config import fileConfig
import os

from flask import current_app

from alembic import context

# Import all models here for Alembic to detect them
from src.models.user import User
from src.models.role import Role
from src.models.permission import Permission
from src.models.aircraft import Aircraft
from src.models.customer import Customer
from src.models.fuel_truck import FuelTruck
from src.models.fuel_order import FuelOrder

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return current_app.config['SQLALCHEMY_DATABASE_URI']
    except RuntimeError:
        return os.environ.get('SQLALCHEMY_DATABASE_URI') or \
            'postgresql://fbo_user:fbo_password@db:5432/fbo_launchpad_test'


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = get_engine_url()
    context.configure(
        url=url,
        target_metadata=get_metadata(),
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="fbo-launchpad-backend/migrations/README">
Single-database configuration for Flask.
</file>

<file path="fbo-launchpad-backend/migrations/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}
</file>

<file path="fbo-launchpad-backend/src/models/__init__.py">
from .base import Base
from .permission import Permission
from .role import Role
from .role_permission import role_permissions, user_roles
from .user import User, UserRole
from .aircraft import Aircraft
from .customer import Customer
from .fuel_truck import FuelTruck
from .fuel_order import FuelOrder, FuelOrderStatus

__all__ = [
    'Base',
    'Permission',
    'Role',
    'role_permissions',
    'user_roles',
    'User',
    'UserRole',
    'Aircraft',
    'Customer',
    'FuelTruck',
    'FuelOrder',
    'FuelOrderStatus'
]
</file>

<file path="fbo-launchpad-backend/src/models/aircraft.py">
from datetime import datetime
from ..extensions import db

class Aircraft(db.Model):
    """Aircraft model representing an aircraft in the system."""
    __tablename__ = 'aircraft'

    # Primary key - using tail number as per MVP requirements
    tail_number = db.Column(db.String(20), primary_key=True)
    
    # New column for aircraft type
    aircraft_type = db.Column(db.String(50), nullable=False)

    # New column for fuel type
    fuel_type = db.Column(db.String(20), nullable=False)

    # Timestamps
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'tail_number': self.tail_number,
            'aircraft_type': self.aircraft_type,
            'fuel_type': self.fuel_type,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

    def __repr__(self):
        """Return string representation of the aircraft."""
        return f'<Aircraft {self.tail_number}>'
</file>

<file path="fbo-launchpad-backend/src/models/customer.py">
from datetime import datetime
from ..extensions import db


class Customer(db.Model):
    """Model representing a customer in the system (MVP version).
    Note: This is a simplified version for MVP and will be expanded significantly in the CRM module."""
    
    __tablename__ = 'customers'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    phone = db.Column(db.String(20))
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'phone': self.phone,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

    def __repr__(self):
        return f'<Customer {self.name}>'
</file>

<file path="fbo-launchpad-backend/src/models/fuel_order.py">
import enum
from datetime import datetime
from sqlalchemy import Integer, String, Boolean, DateTime, Enum, Text, Numeric, ForeignKey
from sqlalchemy.ext.hybrid import hybrid_property
from ..extensions import db

class FuelOrderStatus(enum.Enum):
    DISPATCHED = 'Dispatched'
    ACKNOWLEDGED = 'Acknowledged'
    EN_ROUTE = 'En Route'
    FUELING = 'Fueling'
    COMPLETED = 'Completed'
    REVIEWED = 'Reviewed'
    CANCELLED = 'Cancelled'

class FuelOrder(db.Model):
    __tablename__ = 'fuel_orders'

    # Primary Key
    id = db.Column(db.Integer, primary_key=True)

    # Status and Core Fields
    status = db.Column(db.Enum(FuelOrderStatus), nullable=False, default=FuelOrderStatus.DISPATCHED, index=True)
    tail_number = db.Column(db.String(20), db.ForeignKey('aircraft.tail_number'), nullable=False, index=True)
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True)
    fuel_type = db.Column(db.String(50), nullable=False)
    additive_requested = db.Column(db.Boolean, default=False)
    requested_amount = db.Column(db.Numeric(10, 2), nullable=True)

    # Assignment Fields
    assigned_lst_user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True, index=True)
    assigned_truck_id = db.Column(db.Integer, db.ForeignKey('fuel_trucks.id'), nullable=True, index=True)
    location_on_ramp = db.Column(db.String(100), nullable=True)
    
    # Notes Fields
    csr_notes = db.Column(db.Text, nullable=True)
    lst_notes = db.Column(db.Text, nullable=True)

    # Metering Fields
    start_meter_reading = db.Column(db.Numeric(12, 2), nullable=True)
    end_meter_reading = db.Column(db.Numeric(12, 2), nullable=True)

    # Timestamps
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    dispatch_timestamp = db.Column(db.DateTime, nullable=True)
    acknowledge_timestamp = db.Column(db.DateTime, nullable=True)
    en_route_timestamp = db.Column(db.DateTime, nullable=True)
    fueling_start_timestamp = db.Column(db.DateTime, nullable=True)
    completion_timestamp = db.Column(db.DateTime, nullable=True)
    reviewed_timestamp = db.Column(db.DateTime, nullable=True)
    
    # Review Fields
    reviewed_by_csr_user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)

    # Relationships
    aircraft = db.relationship('Aircraft', backref=db.backref('fuel_orders', lazy='dynamic'))
    customer = db.relationship('Customer', backref=db.backref('fuel_orders', lazy='dynamic'))
    assigned_lst = db.relationship('User', foreign_keys=[assigned_lst_user_id], 
                                 backref=db.backref('assigned_fuel_orders', lazy='dynamic'))
    assigned_truck = db.relationship('FuelTruck', backref=db.backref('fuel_orders', lazy='dynamic'))
    reviewed_by_csr = db.relationship('User', foreign_keys=[reviewed_by_csr_user_id], 
                                    backref=db.backref('reviewed_fuel_orders', lazy='dynamic'))

    @hybrid_property
    def calculated_gallons_dispensed(self):
        if self.start_meter_reading is not None and self.end_meter_reading is not None:
            return float(self.end_meter_reading - self.start_meter_reading)
        return None

    def __repr__(self):
        return f'<FuelOrder {self.id} - {self.tail_number}>'
</file>

<file path="fbo-launchpad-backend/src/models/fuel_truck.py">
from datetime import datetime
from ..extensions import db


class FuelTruck(db.Model):
    """Model representing a fuel truck in the system."""
    
    __tablename__ = 'fuel_trucks'

    id = db.Column(db.Integer, primary_key=True)
    truck_number = db.Column(db.String(20), unique=True, nullable=False)
    fuel_type = db.Column(db.String(50), nullable=False)
    capacity = db.Column(db.Numeric(10, 2), nullable=False)
    current_meter_reading = db.Column(db.Numeric(12, 2), nullable=False, default=0)
    is_active = db.Column(db.Boolean, nullable=False, default=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'truck_number': self.truck_number,
            'fuel_type': self.fuel_type,
            'capacity': float(self.capacity),
            'current_meter_reading': float(self.current_meter_reading),
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

    def __repr__(self):
        return f'<FuelTruck {self.truck_number}>'
</file>

<file path="fbo-launchpad-backend/src/models/user.py">
from datetime import datetime, timedelta
from enum import Enum
from flask import current_app, g, has_request_context
from sqlalchemy import exists
from sqlalchemy.orm import joinedload
from werkzeug.security import generate_password_hash, check_password_hash
import jwt

from ..extensions import db
from ..models.permission import Permission
from ..models.role import Role
from ..models.role_permission import role_permissions, user_roles

class UserRole(Enum):
    """
    Enumeration of user roles for backward compatibility with role-based decorators.
    """
    ADMIN = "ADMIN"
    CSR = "CSR"
    LST = "LST"

class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    name = db.Column(db.String(120), nullable=True)
    password_hash = db.Column(db.String(128))
    is_active = db.Column(db.Boolean, nullable=False, default=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)
    roles = db.relationship(
        'Role',
        secondary=user_roles,
        backref=db.backref('users', lazy='dynamic'),
        lazy='dynamic'
    )

    def set_password(self, password):
        self.password_hash = generate_password_hash(password, method='pbkdf2:sha256')

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def to_dict(self):
        """Convert user object to dictionary."""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'name': self.name,
            'roles': [role.name for role in self.roles.all()],
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat()
        }

    @property
    def role_list(self):
        """Get list of roles for this user."""
        return self.roles.all()

    def __repr__(self):
        return f'<User {self.username}>'

    def has_permission(self, permission_name: str) -> bool:
        """
        Check if the user has a specific permission through any of their assigned roles.
        
        Args:
            permission_name (str): The name of the permission to check for.
            
        Returns:
            bool: True if the user has the permission through any role, False otherwise.
            
        Note:
            This method uses SQLAlchemy's EXISTS subquery for efficient permission checking
            and caches results for the duration of the request.
        """
        if not self.is_active:
            return False
            
        # Use request-level caching if available
        if has_request_context():
            # Initialize permission cache if it doesn't exist
            if not hasattr(g, '_permission_cache'):
                g._permission_cache = {}
            
            cache_key = f'user_{self.id}_perm_{permission_name}'
            if cache_key in g._permission_cache:
                return g._permission_cache[cache_key]
            
            # Check permission and cache result
            result = db.session.query(exists().where(
                db.and_(
                    User.id == self.id,
                    User.roles.any(Role.permissions.any(Permission.name == permission_name))
                )
            )).scalar()
            
            g._permission_cache[cache_key] = result
            return result
            
        # If no request context, perform check without caching
        return db.session.query(exists().where(
            db.and_(
                User.id == self.id,
                User.roles.any(Role.permissions.any(Permission.name == permission_name))
            )
        )).scalar()

    def generate_token(self, expires_in=3600):
        """
        Generate a JWT token for the user.
        
        Args:
            expires_in (int): Token expiration time in seconds (default: 1 hour)
            
        Returns:
            str: The generated JWT token
            
        Note:
            The token includes user ID, roles, and expiration time.
            Uses the app's JWT_SECRET_KEY for signing.
        """
        now = datetime.utcnow()
        payload = {
            'user_id': self.id,
            'username': self.username,
            'roles': [role.name for role in self.roles],
            'is_active': self.is_active,
            'exp': now + timedelta(seconds=expires_in),
            'iat': now
        }
        return jwt.encode(
            payload,
            current_app.config['JWT_SECRET_KEY'],
            algorithm='HS256'
        )

    @staticmethod
    def verify_token(token):
        """Verify a JWT token and return the user."""
        try:
            payload = jwt.decode(
                token,
                current_app.config['JWT_SECRET_KEY'],
                algorithms=['HS256']
            )
            user_id = payload['user_id']
            return User.query.get(user_id)
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
</file>

<file path="fbo-launchpad-backend/src/routes/__init__.py">
from .fuel_order_routes import fuel_order_bp
from .auth_routes import auth_bp
from .user_routes import user_bp
from .fuel_truck_routes import truck_bp

__all__ = ['fuel_order_bp', 'auth_bp', 'user_bp', 'truck_bp']
</file>

<file path="fbo-launchpad-backend/src/routes/auth_routes.py">
from flask import Blueprint, request, jsonify, current_app
from ..services.auth_service import AuthService
from flask_jwt_extended import create_access_token
from ..schemas import (
    RegisterRequestSchema,
    RegisterResponseSchema,
    LoginRequestSchema,
    LoginSuccessResponseSchema,
    ErrorResponseSchema
)
from ..models.user import User
from ..models.role import Role
from ..extensions import db, jwt
from marshmallow import ValidationError
from functools import wraps
import time
from datetime import datetime, timedelta
import jwt as pyjwt
from src.utils.rate_limiting import rate_limit

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

# Rate limiting state
login_attempts = {}
RATE_LIMIT = 5  # attempts
RATE_WINDOW = 300  # seconds (5 minutes)

def reset_rate_limits():
    """Reset rate limiting state (for testing)."""
    global login_attempts
    login_attempts = {}

@auth_bp.route('/register', methods=['POST'])
def register():
    """Register a new user.
    ---
    tags:
      - Authentication
    requestBody:
      required: true
      content:
        application/json:
          schema: RegisterRequestSchema
    responses:
      201:
        description: User registered successfully
        content:
          application/json:
            schema: RegisterResponseSchema
      400:
        description: Bad Request (e.g., missing fields, invalid email/password format)
        content:
          application/json:
            schema: ErrorResponseSchema
      409:
        description: Conflict (e.g., email already registered)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    schema = RegisterRequestSchema()
    try:
        data = schema.load(request.json)
    except:
        return jsonify({'error': 'Invalid request data'}), 400

    if User.query.filter_by(email=data['email']).first():
        return jsonify({'error': 'Email already registered'}), 409

    user = User(
        username=data['username'],
        email=data['email'],
        name=data['name'],
        is_active=True
    )
    user.set_password(data['password'])

    db.session.add(user)
    db.session.commit()

    return jsonify({
        'message': 'User registered successfully',
        'user': {
            'id': user.id,
            'email': user.email,
            'name': user.name
        }
    }), 201

@auth_bp.route('/login', methods=['POST'])
@rate_limit(limit=5, window=300)
def login():
    """Login endpoint that returns a JWT token on successful authentication
    ---
    tags:
      - Authentication
    requestBody:
      required: true
      content:
        application/json:
          schema: LoginRequestSchema
    responses:
      200:
        description: Login successful
        content:
          application/json:
            schema: LoginSuccessResponseSchema
      400:
        description: Bad Request (e.g., missing fields)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (e.g., invalid credentials)
        content:
          application/json:
            schema: ErrorResponseSchema
      429:
        description: Too Many Requests (rate limit exceeded)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    try:
        # Validate request data
        schema = LoginRequestSchema()
        data = request.get_json()
        
        if not data:
            return jsonify({
                'error': 'Missing required fields',
                'details': 'Request body is empty'
            }), 400
            
        try:
            data = schema.load(data)
        except ValidationError as err:
            return jsonify({
                'error': 'Missing required fields',
                'details': err.messages
            }), 400
        
        # Find user by email
        user = User.query.filter_by(email=data['email']).first()
        
        if not user:
            return jsonify({'error': 'Invalid email or password'}), 401
            
        if not user.is_active:
            return jsonify({'error': 'User account is inactive'}), 401
            
        # Check password
        if not user.check_password(data['password']):
            return jsonify({'error': 'Invalid email or password'}), 401
            
        # Generate access token with user roles and status
        access_token = create_access_token(
            identity=user.id,
            additional_claims={
                'username': user.username,
                'roles': [role.name for role in user.roles],
                'is_active': user.is_active
            }
        )
        
        # Generate response
        response_schema = LoginSuccessResponseSchema()
        return response_schema.dump({
            'user': user.to_dict(),
            'token': access_token
        }), 200
        
    except Exception as e:
        import traceback
        tb = traceback.format_exc()
        print(f"[LOGIN ERROR] {str(e)}\nTraceback:\n{tb}")
        return jsonify({
            'error': 'Internal server error',
            'details': str(e)
        }), 500
</file>

<file path="fbo-launchpad-backend/src/routes/fuel_order_routes.py">
from flask import Blueprint, request, jsonify, g, Response
from decimal import Decimal
from datetime import datetime
from ..utils.decorators import token_required, require_permission
from ..models.user import UserRole
from ..models.fuel_order import FuelOrder, FuelOrderStatus
from ..services.fuel_order_service import FuelOrderService
from ..schemas import OrderStatusCountsResponseSchema, ErrorResponseSchema
from ..extensions import db

# Create the blueprint for fuel order routes
fuel_order_bp = Blueprint('fuel_order_bp', __name__)

# Special value for auto-assigning LST
AUTO_ASSIGN_LST_ID = -1  # If this value is provided, backend will auto-select least busy LST

@fuel_order_bp.route('/stats/status-counts', methods=['GET'])
@token_required
@require_permission('VIEW_ORDER_STATS')
def get_status_counts():
    """Get counts of fuel orders by status groups.
    Requires VIEW_ORDER_STATS permission. Returns counts for Pending, In Progress, Completed.
    ---
    tags:
      - Fuel Orders Stats
    security:
      - bearerAuth: []
    responses:
      200:
        description: Status counts retrieved successfully
        content:
          application/json:
            schema: OrderStatusCountsResponseSchema
      401:
        description: Unauthorized
      403:
        description: Forbidden
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    counts, message, status_code = FuelOrderService.get_status_counts(current_user=g.current_user)
    if counts is not None:
        return jsonify({"message": message, "counts": counts}), status_code
    else:
        return jsonify({"error": message}), status_code


@fuel_order_bp.route('/', methods=['POST'])
@token_required
@require_permission('CREATE_ORDER')
def create_fuel_order():
    import logging
    logger = logging.getLogger(__name__)
    from flask import current_app
    logger.info('[DEBUG] JWT_SECRET_KEY in create_fuel_order: %s', current_app.config.get('JWT_SECRET_KEY'))
    logger.info('[DEBUG] JWT_ALGORITHM in create_fuel_order: %s', current_app.config.get('JWT_ALGORITHM', 'HS256'))
    logger.info('Entered create_fuel_order')
    logger.info('Request data: %s', request.get_json())
    """Create a new fuel order.
    Requires CREATE_ORDER permission. If assigned_lst_user_id is -1, the backend will auto-assign the least busy active LST.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelOrderCreateRequestSchema
    responses:
      201:
        description: Fuel order created successfully
        content:
          application/json:
            schema: FuelOrderCreateResponseSchema
      400:
        description: Bad Request (e.g., missing fields, validation error, invalid related IDs)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    data = request.get_json()
    
    # Check if data exists and is a dictionary
    if not data or not isinstance(data, dict):
        return jsonify({"error": "Invalid request data"}), 400
    
    # Required fields validation
    required_fields = {
        'tail_number': str,
        'fuel_type': str,
        'assigned_lst_user_id': int,
        'assigned_truck_id': int,
        'requested_amount': float,
        'location_on_ramp': str
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            logger.error('Step 2.1: Missing required field: %s', field)
            return jsonify({"error": f"Missing required field: {field}"}), 400
        # Type check (allow -1 for assigned_lst_user_id)
        if field == 'assigned_lst_user_id':
            try:
                data[field] = int(data[field])
            except Exception:
                return jsonify({"error": f"Invalid type for field: {field} (must be integer or -1)"}), 400
        else:
            if not isinstance(data[field], field_type):
                return jsonify({"error": f"Invalid type for field: {field}"}), 400
        try:
            from src.services.user_service import UserService
            from src.models.user import UserRole
            # Get all active LST users
            lst_users, _, _ = UserService.get_users({'role': UserRole.LST, 'is_active': True})
            if not lst_users:
                logger.error('No active LST users found for auto-assignment')
                return jsonify({"error": "No active LST users available for auto-assignment"}), 400
            # Find the LST with the fewest active/in-progress orders
            from src.models.fuel_order import FuelOrderStatus, FuelOrder
            least_busy = None
            min_orders = None
            for lst in lst_users:
                count = FuelOrder.query.filter(
                    FuelOrder.assigned_lst_user_id == lst.id,
                    FuelOrder.status.in_([
                        FuelOrderStatus.DISPATCHED,
                        FuelOrderStatus.ACKNOWLEDGED,
                        FuelOrderStatus.EN_ROUTE,
                        FuelOrderStatus.FUELING
                    ])
                ).count()
                if min_orders is None or count < min_orders:
                    min_orders = count
                    least_busy = lst
            if not least_busy:
                logger.error('Auto-assign logic failed to select an LST')
                return jsonify({"error": "Auto-assign failed to select an LST"}), 400
            data['assigned_lst_user_id'] = least_busy.id
            logger.info(f"Auto-assigned LST user_id {least_busy.id} (username={least_busy.username}) with {min_orders} active orders.")
        except Exception as e:
            logger.error(f"Error during auto-assignment of LST: {str(e)}")
            return jsonify({"error": f"Error during auto-assignment of LST: {str(e)}"}), 500
    # --- END AUTO-ASSIGN ---

    # Optional fields validation
    optional_fields = {
        'customer_id': int,
        'additive_requested': bool,
        'csr_notes': str
    }
    
    for field, field_type in optional_fields.items():
        if field in data:
            try:
                # Convert to expected type if necessary
                if field_type == int:
                    data[field] = int(data[field])
                elif field_type == bool and not isinstance(data[field], bool):
                    data[field] = bool(data[field])
                elif field_type == str and not isinstance(data[field], str):
                    data[field] = str(data[field])
            except (ValueError, TypeError):
                logger.error('Step 3.1: Invalid type for optional field %s. Value: %s', field, data[field])
                return jsonify({"error": f"Invalid type for field {field}. Expected {field_type.__name__}"}), 400
    logger.info('Step 3: Passed optional fields validation')
    
    # Create the fuel order
    try:
        logger.info('Step 4: Creating FuelOrder with data: %s', data)
        fuel_order = FuelOrder(
            tail_number=data['tail_number'],
            customer_id=data.get('customer_id'),
            fuel_type=data['fuel_type'],
            additive_requested=data.get('additive_requested', False),
            requested_amount=data['requested_amount'],
            assigned_lst_user_id=data['assigned_lst_user_id'],
            assigned_truck_id=data['assigned_truck_id'],
            location_on_ramp=data['location_on_ramp'],
            csr_notes=data.get('csr_notes')
        )
        logger.info('Step 5: FuelOrder object created')
        db.session.add(fuel_order)
        logger.info('Step 6: FuelOrder added to session')
        db.session.commit()
        logger.info('Step 7: FuelOrder committed')
        return jsonify({
            'id': fuel_order.id,
            'tail_number': fuel_order.tail_number,
            'customer_id': fuel_order.customer_id,
            'fuel_type': fuel_order.fuel_type,
            'additive_requested': fuel_order.additive_requested,
            'requested_amount': fuel_order.requested_amount,
            'assigned_lst_user_id': fuel_order.assigned_lst_user_id,
            'assigned_truck_id': fuel_order.assigned_truck_id,
            'location_on_ramp': fuel_order.location_on_ramp,
            'csr_notes': fuel_order.csr_notes,
            'status': fuel_order.status.value,
            'created_at': fuel_order.created_at.isoformat()
        }), 201
    except Exception as e:
        db.session.rollback()
        logger.exception("Exception in create_fuel_order")
        return jsonify({"error": f"Error creating fuel order: {str(e)}"}), 500

@fuel_order_bp.route('/', methods=['GET'])
@token_required
def get_fuel_orders():
    """Get a list of fuel orders.
    LSTs see only their assigned orders. CSRs/Admins see all. Supports filtering and pagination.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: query
        name: status
        schema:
          type: string
          enum: [DISPATCHED, ACKNOWLEDGED, EN_ROUTE, FUELING, COMPLETED, REVIEWED, CANCELLED]
        required: false
        description: Filter orders by status (case-insensitive)
      - in: query
        name: page
        schema:
          type: integer
          default: 1
        required: false
        description: Page number for pagination
      - in: query
        name: per_page
        schema:
          type: integer
          default: 20
        required: false
        description: Number of items per page (max 100)
    responses:
      200:
        description: List of fuel orders retrieved successfully
        content:
          application/json:
            schema: FuelOrderListResponseSchema
      400:
        description: Bad Request (e.g., invalid status filter value)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Extract and validate filter/pagination parameters
    filters = {
        'status': request.args.get('status', None, type=str),
        'page': request.args.get('page', 1, type=int),
        'per_page': request.args.get('per_page', 20, type=int)
        # Add other potential filters here later (e.g., date_from, date_to, tail_number)
    }

    # Basic validation/sanitization
    if filters['page'] < 1: filters['page'] = 1
    if filters['per_page'] < 1: filters['per_page'] = 1
    if filters['per_page'] > 100: filters['per_page'] = 100  # Match service limit

    # Call service method with current user and filters
    paginated_result, message = FuelOrderService.get_fuel_orders(
        current_user=g.current_user,
        filters=filters
    )

    # Handle the result
    if paginated_result is not None:
        # Serialize the orders
        orders_list = []
        for order in paginated_result.items:
            orders_list.append({
                "id": order.id,
                "status": order.status.value,
                "tail_number": order.tail_number,
                "customer_id": order.customer_id,
                "fuel_type": order.fuel_type,
                "additive_requested": order.additive_requested,
                "requested_amount": str(order.requested_amount) if order.requested_amount else None,
                "assigned_lst_user_id": order.assigned_lst_user_id,
                "assigned_truck_id": order.assigned_truck_id,
                "location_on_ramp": order.location_on_ramp,
                "start_meter_reading": str(order.start_meter_reading) if order.start_meter_reading else None,
                "end_meter_reading": str(order.end_meter_reading) if order.end_meter_reading else None,
                "calculated_gallons_dispensed": str(order.calculated_gallons_dispensed) if order.calculated_gallons_dispensed else None,
                "created_at": order.created_at.isoformat(),
                "dispatch_timestamp": order.dispatch_timestamp.isoformat() if order.dispatch_timestamp else None,
                "acknowledge_timestamp": order.acknowledge_timestamp.isoformat() if order.acknowledge_timestamp else None,
                "en_route_timestamp": order.en_route_timestamp.isoformat() if order.en_route_timestamp else None,
                "fueling_start_timestamp": order.fueling_start_timestamp.isoformat() if order.fueling_start_timestamp else None,
                "completion_timestamp": order.completion_timestamp.isoformat() if order.completion_timestamp else None,
                "reviewed_timestamp": order.reviewed_timestamp.isoformat() if order.reviewed_timestamp else None,
                "reviewed_by_csr_user_id": order.reviewed_by_csr_user_id
            })

        # Construct response with orders and pagination metadata
        response = {
            "message": message,
            "fuel_orders": orders_list,
            "pagination": {
                "page": paginated_result.page,
                "per_page": paginated_result.per_page,
                "total_pages": paginated_result.pages,
                "total_items": paginated_result.total,
                "has_next": paginated_result.has_next,
                "has_prev": paginated_result.has_prev
            }
        }
        return jsonify(response), 200
    else:
        # Handle error cases
        status_code = 500 if "Database error" in message else (403 if "Forbidden" in message else 400)
        return jsonify({"error": message}), status_code 

@fuel_order_bp.route('/<int:order_id>', methods=['GET'])
@token_required
def get_fuel_order(order_id):
    """Get details of a specific fuel order.
    LST must be assigned to the order. CSR/Admin can view any.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order to retrieve
    responses:
      200:
        description: Fuel order details retrieved successfully
        content:
          application/json:
            schema: FuelOrderResponseSchema # Use full schema here
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (user not allowed to view this order)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Not Found (fuel order with the given ID does not exist)
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Call service method to get the fuel order
    order, message, status_code = FuelOrderService.get_fuel_order_by_id(
        order_id=order_id,
        current_user=g.current_user
    )

    # Handle the result based on whether the order was found
    if order is not None:
        # Serialize the full order details
        order_details = {
            "id": order.id,
            "status": order.status.value,
            "tail_number": order.tail_number,
            "customer_id": order.customer_id,  # Consider joining/fetching customer name later
            "fuel_type": order.fuel_type,
            "additive_requested": order.additive_requested,
            "requested_amount": str(order.requested_amount) if order.requested_amount else None,
            "assigned_lst_user_id": order.assigned_lst_user_id,  # Consider joining/fetching LST name later
            "assigned_truck_id": order.assigned_truck_id,  # Consider joining/fetching truck name later
            "location_on_ramp": order.location_on_ramp,
            "csr_notes": order.csr_notes,
            "start_meter_reading": str(order.start_meter_reading) if order.start_meter_reading else None,
            "end_meter_reading": str(order.end_meter_reading) if order.end_meter_reading else None,
            "calculated_gallons_dispensed": str(order.calculated_gallons_dispensed) if order.calculated_gallons_dispensed else None,
            "lst_notes": order.lst_notes,
            "created_at": order.created_at.isoformat(),
            "dispatch_timestamp": order.dispatch_timestamp.isoformat() if order.dispatch_timestamp else None,
            "acknowledge_timestamp": order.acknowledge_timestamp.isoformat() if order.acknowledge_timestamp else None,
            "en_route_timestamp": order.en_route_timestamp.isoformat() if order.en_route_timestamp else None,
            "fueling_start_timestamp": order.fueling_start_timestamp.isoformat() if order.fueling_start_timestamp else None,
            "completion_timestamp": order.completion_timestamp.isoformat() if order.completion_timestamp else None,
            "reviewed_timestamp": order.reviewed_timestamp.isoformat() if order.reviewed_timestamp else None,
            "reviewed_by_csr_user_id": order.reviewed_by_csr_user_id  # Consider joining/fetching CSR name later
        }
        return jsonify({"message": message, "fuel_order": order_details}), status_code
    else:
        # Return error message and status code from service
        return jsonify({"error": message}), status_code

@fuel_order_bp.route('/<int:order_id>/status', methods=['PATCH'])
@token_required
def update_fuel_order_status(order_id):
    """Update a fuel order's status.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order to update
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelOrderUpdateRequestSchema
    responses:
      200:
        description: Fuel order updated successfully
        content:
          application/json:
            schema: FuelOrderUpdateResponseSchema
      400:
        description: Bad Request (e.g., invalid status)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel order not found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error (e.g., database error)
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    data = request.get_json()
    
    # Check if data exists and is a dictionary
    if not data or not isinstance(data, dict):
        return jsonify({"error": "Invalid request data"}), 400
    
    # Required fields validation
    required_fields = {
        'status': str,
        'assigned_truck_id': int
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400
        try:
            # Convert to expected type if necessary
            if field_type == int:
                data[field] = int(data[field])
            elif field_type == str and not isinstance(data[field], str):
                data[field] = str(data[field])
            
            # Additional validation for specific fields
            if field_type == str and not data[field].strip():
                return jsonify({"error": f"Field {field} cannot be empty"}), 400
        except (ValueError, TypeError):
            return jsonify({"error": f"Invalid type for field {field}. Expected {field_type.__name__}"}), 400
    
    # Get the fuel order
    fuel_order = FuelOrder.query.get(order_id)
    if not fuel_order:
        return jsonify({"error": "Fuel order not found"}), 404
    
    # Update the fuel order
    try:
        # Convert status to uppercase for enum lookup
        status_value = data['status'].upper()
        print(f"Attempting to update status to: {status_value}")
        if status_value not in FuelOrderStatus.__members__:
            print(f"Invalid status value: {data['status']}")
            print(f"Valid status values: {list(FuelOrderStatus.__members__.keys())}")
            return jsonify({"error": f"Invalid status value: {data['status']}"}), 400
            
        fuel_order.status = FuelOrderStatus[status_value]
        fuel_order.assigned_truck_id = data['assigned_truck_id']
        db.session.commit()
        
        return jsonify({
            'id': fuel_order.id,
            'tail_number': fuel_order.tail_number,
            'customer_id': fuel_order.customer_id,
            'fuel_type': fuel_order.fuel_type,
            'additive_requested': fuel_order.additive_requested,
            'requested_amount': fuel_order.requested_amount,
            'assigned_lst_user_id': fuel_order.assigned_lst_user_id,
            'assigned_truck_id': fuel_order.assigned_truck_id,
            'location_on_ramp': fuel_order.location_on_ramp,
            'csr_notes': fuel_order.csr_notes,
            'status': fuel_order.status.value,
            'updated_at': fuel_order.updated_at.isoformat()
        }), 200
    except Exception as e:
        db.session.rollback()
        print(f"Error updating fuel order: {str(e)}")
        print(f"Data: {data}")
        print(f"Status value: {data['status']}")
        return jsonify({"error": f"Error updating fuel order: {str(e)}"}), 500

@fuel_order_bp.route('/<int:order_id>/submit-data', methods=['PUT'])
@token_required
@require_permission('COMPLETE_ORDER')
def submit_fuel_data(order_id):
    """Submit fuel meter readings and notes for a fuel order.
    Requires COMPLETE_ORDER permission. Order must be in FUELING status.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order
    requestBody:
      required: true
      content:
        application/json:
          schema: FuelOrderCompleteRequestSchema
    responses:
      200:
        description: Fuel data submitted successfully
        content:
          application/json:
            schema: FuelOrderUpdateResponseSchema
      400:
        description: Bad Request (e.g., invalid meter readings, validation error)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized (invalid/missing token)
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission or not assigned to order)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Fuel order not found
        content:
          application/json:
            schema: ErrorResponseSchema
      422:
        description: Order not in correct status
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Get the fuel order
    fuel_order = FuelOrder.query.get_or_404(order_id)
    
    # Verify the LST is assigned to this order
    if fuel_order.assigned_lst_user_id != g.current_user.id:
        return jsonify({
            "error": "You are not authorized to submit data for this fuel order"
        }), 403
    
    # Verify order is in FUELING status
    if fuel_order.status != FuelOrderStatus.FUELING:
        return jsonify({
            "error": "Fuel order must be in FUELING status to submit meter readings"
        }), 422
    
    # Get and validate request data
    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400
        
    # Validate required fields
    required_fields = {
        'start_meter_reading': float,
        'end_meter_reading': float
    }
    
    for field, field_type in required_fields.items():
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400
        try:
            value = field_type(data[field])
            if value < 0:
                return jsonify({"error": f"{field} cannot be negative"}), 400
            data[field] = value
        except (ValueError, TypeError):
            return jsonify({"error": f"Invalid type for field {field}. Expected {field_type.__name__}"}), 400
            
    # Validate meter readings
    if data['end_meter_reading'] <= data['start_meter_reading']:
        return jsonify({
            "error": "End meter reading must be greater than start meter reading"
        }), 400
    
    try:
        # Update the fuel order
        fuel_order.start_meter_reading = data['start_meter_reading']
        fuel_order.end_meter_reading = data['end_meter_reading']
        fuel_order.lst_notes = data.get('lst_notes')  # Optional field
        fuel_order.status = FuelOrderStatus.COMPLETED
        fuel_order.completion_timestamp = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            "message": "Fuel data submitted successfully",
            "fuel_order": {
                "id": fuel_order.id,
                "status": fuel_order.status.value,
                "tail_number": fuel_order.tail_number,
                "start_meter_reading": str(fuel_order.start_meter_reading),
                "end_meter_reading": str(fuel_order.end_meter_reading),
                "calculated_gallons_dispensed": str(fuel_order.calculated_gallons_dispensed),
                "lst_notes": fuel_order.lst_notes,
                "completion_timestamp": fuel_order.completion_timestamp.isoformat()
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": f"Error submitting fuel data: {str(e)}"}), 500

@fuel_order_bp.route('/<int:order_id>/review', methods=['PATCH'])
@token_required
@require_permission('REVIEW_ORDERS')
def review_fuel_order(order_id):
    """Mark a completed fuel order as reviewed.
    Requires REVIEW_ORDERS permission. Order must be in COMPLETED state.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    parameters:
      - in: path
        name: order_id
        schema:
          type: integer
        required: true
        description: ID of the fuel order to review
    responses:
      200:
        description: Fuel order marked as reviewed successfully
        content:
          application/json:
            schema: FuelOrderUpdateResponseSchema # Use schema that returns updated order
      400:
        description: Bad Request (order not in COMPLETED state)
        content:
          application/json:
            schema: ErrorResponseSchema
      401:
        description: Unauthorized
        content:
          application/json:
            schema: ErrorResponseSchema
      403:
        description: Forbidden (missing permission)
        content:
          application/json:
            schema: ErrorResponseSchema
      404:
        description: Not Found
        content:
          application/json:
            schema: ErrorResponseSchema
      500:
        description: Server error
        content:
          application/json:
            schema: ErrorResponseSchema
    """
    # Call service method to review the order
    reviewed_order, message, status_code = FuelOrderService.review_fuel_order(
        order_id=order_id,
        reviewer_user=g.current_user
    )
    
    # Handle the result from the service
    if reviewed_order is not None:
        # Serialize the reviewed order details for the response
        order_details = {
            "id": reviewed_order.id,
            "status": reviewed_order.status.value,  # Should be REVIEWED
            "reviewed_by_csr_user_id": reviewed_order.reviewed_by_csr_user_id,
            "reviewed_timestamp": reviewed_order.reviewed_timestamp.isoformat() if reviewed_order.reviewed_timestamp else None
        }
        return jsonify({"message": message, "fuel_order": order_details}), status_code  # Use status_code from service (should be 200)
    else:
        return jsonify({"error": message}), status_code  # Use status_code from service (e.g., 400, 404, 500) 

@fuel_order_bp.route('/export', methods=['GET'])
@token_required
@require_permission('EXPORT_ORDERS_CSV')
def export_fuel_orders_csv():
    """Export fuel orders to a CSV file.
    Requires EXPORT_ORDERS_CSV permission.
    ---
    tags:
      - Fuel Orders
    security:
      - bearerAuth: []
    responses:
      200:
        description: CSV file exported successfully
      401:
        description: Unauthorized
      403:
        description: Forbidden (missing permission)
      500:
        description: Server error
    """
    # Extract filter parameters from request.args
    filters = {
        'status': request.args.get('status', None, type=str)
        # TODO: Add date_from, date_to filters later
    }

    # Call service method to generate CSV data
    csv_data, message, status_code = FuelOrderService.export_fuel_orders_to_csv(
        current_user=g.current_user,
        filters=filters
    )

    # Handle the result from the service
    if csv_data is not None and status_code == 200:
        # Check if we got an empty list (no data found)
        if isinstance(csv_data, list) and len(csv_data) == 0:
            return jsonify({"message": message}), 200

        # Generate dynamic filename with timestamp
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        filename = f"fuel_orders_export_{timestamp}.csv"

        # Create response with CSV data and appropriate headers
        response = Response(
            csv_data,
            mimetype='text/csv',
            headers={
                "Content-Disposition": f"attachment; filename={filename}"
            }
        )
        return response
    else:
        # Return error message and status code from service
        return jsonify({"error": message}), status_code
</file>

<file path="fbo-launchpad-backend/src/schemas/__init__.py">
from .auth_schemas import (
    RegisterRequestSchema, UserResponseSchema, RegisterResponseSchema,
    LoginRequestSchema, LoginSuccessResponseSchema, ErrorResponseSchema
)

from .fuel_order_schemas import (
    FuelOrderCreateRequestSchema, FuelOrderStatusUpdateRequestSchema,
    FuelOrderCompleteRequestSchema, FuelOrderResponseSchema,
    FuelOrderBriefResponseSchema, FuelOrderCreateResponseSchema,
    FuelOrderUpdateResponseSchema, PaginationSchema, FuelOrderListResponseSchema,
    OrderStatusCountsSchema, OrderStatusCountsResponseSchema
) # Ensure all schemas are imported

from .fuel_truck_schemas import (
    FuelTruckSchema, FuelTruckListResponseSchema,
    FuelTruckCreateRequestSchema, FuelTruckCreateResponseSchema
)

from .admin_schemas import (
    AdminAircraftSchema, AdminAircraftListResponseSchema,
    AdminCustomerSchema, AdminCustomerListResponseSchema
)

from .role_schemas import (
    RoleSchema, RoleListResponseSchema,
    RoleCreateRequestSchema, RoleUpdateRequestSchema,
    RoleAssignPermissionRequestSchema
)

from .permission_schemas import PermissionSchema

from marshmallow import Schema, fields, validate

class ErrorResponseSchema(Schema):
    error = fields.String(required=True)
    details = fields.Dict(keys=fields.String(), values=fields.List(fields.String()), required=False)

class UserBaseSchema(Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=False)
    email = fields.Email(required=True)
    role = fields.String(required=True, validate=validate.OneOf(['ADMIN', 'CSR', 'LST']))
    is_active = fields.Boolean(dump_only=True)
    created_at = fields.DateTime(dump_only=True)

class UserCreateRequestSchema(UserBaseSchema):
    password = fields.String(required=True, load_only=True)
    is_active = fields.Boolean(required=False, load_only=True)

class UserUpdateRequestSchema(Schema):
    name = fields.String(required=False)
    role = fields.String(required=False, validate=validate.OneOf(['ADMIN', 'CSR', 'LST']))
    is_active = fields.Boolean(required=False)
    password = fields.String(required=False, load_only=True)

class UserResponseSchema(Schema):
    message = fields.String(required=True)
    user = fields.Nested(UserBaseSchema)

class UserListResponseSchema(Schema):
    message = fields.String(required=True)
    users = fields.List(fields.Nested(UserBaseSchema), required=True)

__all__ = [
    'RegisterRequestSchema', 'UserResponseSchema', 'RegisterResponseSchema',
    'LoginRequestSchema', 'LoginSuccessResponseSchema', 'ErrorResponseSchema',
    'FuelOrderCreateRequestSchema', 'FuelOrderStatusUpdateRequestSchema',
    'FuelOrderCompleteRequestSchema', 'FuelOrderResponseSchema',
    'FuelOrderBriefResponseSchema', 'FuelOrderCreateResponseSchema',
    'FuelOrderUpdateResponseSchema', 'PaginationSchema', 'FuelOrderListResponseSchema',
    'FuelTruckSchema', 'FuelTruckListResponseSchema',
    'FuelTruckCreateRequestSchema',
    'FuelTruckCreateResponseSchema',
    'UserBaseSchema',
    'UserCreateRequestSchema',
    'UserUpdateRequestSchema',
    'UserListResponseSchema',
    'OrderStatusCountsSchema', 'OrderStatusCountsResponseSchema',
    'AdminAircraftSchema', 'AdminAircraftListResponseSchema',
    'AdminCustomerSchema', 'AdminCustomerListResponseSchema',
    'RoleSchema', 'RoleListResponseSchema',
    'RoleCreateRequestSchema', 'RoleUpdateRequestSchema',
    'RoleAssignPermissionRequestSchema',
    'PermissionSchema'
] # Ensure schemas are exported
</file>

<file path="fbo-launchpad-backend/src/schemas/auth_schemas.py">
from marshmallow import Schema, fields, validate

class RegisterRequestSchema(Schema):
    """Schema for user registration request"""
    email = fields.Email(required=True)
    password = fields.String(required=True, validate=validate.Length(min=8))
    name = fields.String(required=False)  # Optional name field
    username = fields.String(required=False)  # Optional username field

class UserResponseSchema(Schema):
    id = fields.Int(dump_only=True)
    username = fields.Str(dump_only=True)
    email = fields.Email(dump_only=True)
    role = fields.Str(dump_only=True)
    is_active = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)

class RegisterResponseSchema(Schema):
    """Schema for user registration response"""
    message = fields.String(required=True)
    user = fields.Dict(keys=fields.String(), values=fields.Raw(), required=True)

class LoginRequestSchema(Schema):
    """Schema for login request"""
    email = fields.Email(required=True)
    password = fields.String(required=True)

class LoginSuccessResponseSchema(Schema):
    """Schema for successful login response"""
    token = fields.String(required=True)
    message = fields.String(required=True)

class ErrorResponseSchema(Schema):
    """Schema for error responses"""
    error = fields.String(required=True)
    details = fields.Dict(keys=fields.String(), values=fields.Raw(), required=False)
</file>

<file path="fbo-launchpad-backend/src/services/__init__.py">
from .auth_service import AuthService
from .aircraft_service import AircraftService
from .customer_service import CustomerService
from .fuel_order_service import FuelOrderService
from .user_service import UserService
from .fuel_truck_service import FuelTruckService
from .role_service import RoleService
from .permission_service import PermissionService

__all__ = ['AuthService', 'AircraftService', 'CustomerService', 'FuelOrderService', 'UserService', 'FuelTruckService', 'RoleService', 'PermissionService']
</file>

<file path="fbo-launchpad-backend/src/services/auth_service.py">
from typing import Union, Tuple
from ..models.user import User, UserRole
from ..extensions import db
from datetime import datetime, timedelta
import jwt
from flask import current_app

class AuthService:
    @classmethod
    def register_user(cls, email: str, password: str) -> User:
        """
        Register a new user if the email is not already taken.
        
        Args:
            email (str): The user's email address
            password (str): The user's password (will be hashed before storage)
            
        Returns:
            User: The newly created user object
            
        Raises:
            ValueError: If email already exists
        """
        print(f"Registering user with email: {email}")
        
        # Check if user already exists with this email
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            print(f"User with email {email} already exists")
            raise ValueError("Email already registered")
            
        # Generate username from email (part before @)
        username = email.split('@')[0]
        print(f"Generated username: {username}")
        
        # If username exists, append a number
        base_username = username
        counter = 1
        while User.query.filter_by(username=username).first():
            username = f"{base_username}{counter}"
            counter += 1
            print(f"Username {base_username} exists, trying {username}")
            
        try:
            # Create new user instance with default role LST
            new_user = User(
                username=username,
                email=email,
                role=UserRole.LST,
                is_active=True
            )
            print(f"Created user object: {new_user}")
            
            # Set password (will be automatically hashed by the User model)
            new_user.set_password(password)
            print("Set password hash")
            
            # Add user to database and commit transaction
            db.session.add(new_user)
            print("Added user to session")
            db.session.commit()
            print("Committed transaction")
            return new_user
        except Exception as e:
            db.session.rollback()
            print(f"Error registering user: {str(e)}")
            # In a production environment, you would want to log the error here
            raise Exception(f"Database error: {str(e)}")

    @classmethod
    def authenticate_user(cls, email: str, password: str) -> str:
        """
        Authenticate a user with their email and password.
        
        Args:
            email (str): The user's email
            password (str): The user's password
            
        Returns:
            str: JWT token string if authentication successful
            
        Raises:
            ValueError: If credentials are invalid or account is inactive
            Exception: If there's a server error
        """
        # Find user by email
        user = User.query.filter_by(email=email).first()
        print(f"Authenticating user with email: {email}")
        print(f"Found user: {user}")
        
        # Check if user exists and password is correct
        if not user:
            print("User not found")
            raise ValueError("Invalid email or password")
            
        if not user.check_password(password):
            print("Password check failed")
            raise ValueError("Invalid email or password")
            
        # Check if user account is active
        if not user.is_active:
            print("User account is inactive")
            raise ValueError("User account is inactive")
            
        # Return user object for token creation in route
        return user
</file>

<file path="fbo-launchpad-backend/src/services/fuel_order_service.py">
from datetime import datetime
from decimal import Decimal
import csv
import io
from src.models import (
    FuelOrder,
    FuelOrderStatus,
    Aircraft,
    User,
    UserRole,
    FuelTruck,
    Customer
)
from src.extensions import db
from flask import current_app
from typing import Optional, Tuple, List, Dict, Any, Union

class FuelOrderService:
    @classmethod
    def get_order_status_counts(cls, current_user):
        """
        Calculate and return counts of fuel orders by status groups for dashboard cards.
        CSR, ADMIN, and LST roles are allowed (global counts).
        Returns: (dict, message, status_code)
        """
        from src.models import FuelOrderStatus, UserRole, FuelOrder
        from sqlalchemy import func, case
        from src.extensions import db
        if current_user.role not in [UserRole.CSR, UserRole.ADMIN, UserRole.LST]:
            return None, "Forbidden: Insufficient permissions for status counts.", 403
        try:
            pending_statuses = [FuelOrderStatus.DISPATCHED]
            in_progress_statuses = [FuelOrderStatus.ACKNOWLEDGED, FuelOrderStatus.EN_ROUTE, FuelOrderStatus.FUELING]
            completed_statuses = [FuelOrderStatus.COMPLETED]
            counts = db.session.query(
                func.count(case((FuelOrder.status.in_(pending_statuses), FuelOrder.id))).label('pending'),
                func.count(case((FuelOrder.status.in_(in_progress_statuses), FuelOrder.id))).label('in_progress'),
                func.count(case((FuelOrder.status.in_(completed_statuses), FuelOrder.id))).label('completed')
            ).one_or_none()
            result_counts = {
                'pending': counts[0] if counts else 0,
                'in_progress': counts[1] if counts else 0,
                'completed': counts[2] if counts else 0,
            }
            return result_counts, "Status counts retrieved successfully.", 200
        except Exception as e:
            db.session.rollback()
            from flask import current_app
            current_app.logger.error(f"Error retrieving fuel order status counts: {str(e)}")
            return None, f"Database error retrieving status counts: {str(e)}", 500

    @classmethod
    def get_status_counts(cls, current_user):
        """
        Calculate and return counts of fuel orders by status groups for dashboard cards.
        CSR, ADMIN, and LST roles are allowed (global counts).
        Returns: (dict, message, status_code)
        """
        return cls.get_order_status_counts(current_user)

    @classmethod
    def create_fuel_order(cls, order_data: dict) -> Tuple[Union[FuelOrder, None], Union[str, None]]:
        from src.models import User, UserRole, FuelOrder, FuelOrderStatus
        from src.extensions import db
        import logging
        logger = logging.getLogger(__name__)

        # --- NEW: Check if any users exist ---
        user_count = User.query.count()
        if user_count == 0:
            return (
                None,
                "No users exist in the system. Please create an ADMIN user via the CLI or database to access the admin panel and create LST users.",
                400
            )

        """
        Create a new fuel order after validating all required entities exist and are valid.

        - If assigned_lst_user_id == -1, auto-assign the least busy active LST.
        - Otherwise, validate the provided LST ID.
        - Truck assignment logic is unchanged.

        Args:
            order_data (dict): Dictionary containing the validated order data from the route handler
                Required keys:
                - tail_number (str): Aircraft tail number
                - fuel_type (str): Type of fuel to be dispensed
                - assigned_lst_user_id (int): ID of the LST user assigned to the order (or -1 for auto-assign)
                - assigned_truck_id (int): ID of the fuel truck assigned to the order
                Optional keys:
                - customer_id (int): ID of the customer if applicable
                - additive_requested (bool): Whether fuel additive was requested
                - requested_amount (float): Amount of fuel requested
                - location_on_ramp (str): Location of the aircraft on the ramp
                - csr_notes (str): Notes from the CSR
        Returns:
            tuple[FuelOrder | None, str | None]: Returns either:
                - (FuelOrder, None) on success
                - (None, error_message) on failure
        """
        from src.models import User, UserRole, FuelOrder, FuelOrderStatus
        from src.extensions import db
        import logging
        logger = logging.getLogger(__name__)
        tail_number = order_data.get('tail_number')
        fuel_type = order_data.get('fuel_type')
        assigned_lst_user_id = order_data.get('assigned_lst_user_id')
        assigned_truck_id = order_data.get('assigned_truck_id')
        customer_id = order_data.get('customer_id')

        # Check for required fields
        if not all([tail_number, fuel_type, assigned_lst_user_id is not None, assigned_truck_id is not None]):
            return None, "Missing required fields."

        # --- LST Assignment Logic ---
        if assigned_lst_user_id == -1:
            # Auto-assign the least busy active LST
            active_lsts = User.query.filter(User.role == UserRole.LST, User.is_active == True).all()
            logger.debug(f"[DEBUG] Found {len(active_lsts)} active LST users: {[{'id': u.id, 'username': u.username, 'role': u.role, 'is_active': u.is_active} for u in active_lsts]}")
            if not active_lsts:
                all_lsts = User.query.filter(User.role == UserRole.LST).all()
                logger.debug(f"[DEBUG] All LST users (regardless of active): {[{'id': u.id, 'username': u.username, 'role': u.role, 'is_active': u.is_active} for u in all_lsts]}")
                logger.debug(f"[DEBUG] All users: {[{'id': u.id, 'username': u.username, 'role': u.role, 'is_active': u.is_active} for u in User.query.all()]}")
                return None, "No available LST found for auto-assignment.", 400
            min_count = None
            chosen_lst = None
            active_statuses = [
                FuelOrderStatus.DISPATCHED,
                FuelOrderStatus.ACKNOWLEDGED,
                FuelOrderStatus.EN_ROUTE,
                FuelOrderStatus.FUELING
            ]
            for lst in active_lsts:
                count = FuelOrder.query.filter(
                    FuelOrder.assigned_lst_user_id == lst.id,
                    FuelOrder.status.in_(active_statuses)
                ).count()
                if min_count is None or count < min_count:
                    min_count = count
                    chosen_lst = lst
            if not chosen_lst:
                return None, "No available LST found for auto-assignment.", 400
            logger.info(f"Auto-assigned LST user: {chosen_lst.id} (Active orders: {min_count})")
            assigned_lst_user_id = chosen_lst.id
            order_data['assigned_lst_user_id'] = assigned_lst_user_id
        else:
            # Manual assignment: validate LST exists, is LST, and active
            lst_user = User.query.filter_by(id=assigned_lst_user_id, role=UserRole.LST, is_active=True).first()
            if not lst_user:
                return None, f"Assigned LST user {assigned_lst_user_id} does not exist, is not active, or is not an LST.", 400

        # Truck assignment logic (unchanged)
        # ... (existing validation for truck)

        # Create the FuelOrder (existing logic)
        try:
            new_order = FuelOrder(
                tail_number=tail_number,
                fuel_type=fuel_type,
                assigned_lst_user_id=assigned_lst_user_id,
                assigned_truck_id=assigned_truck_id,
                customer_id=customer_id,
                additive_requested=order_data.get('additive_requested', False),
                requested_amount=order_data.get('requested_amount'),
                location_on_ramp=order_data.get('location_on_ramp'),
                csr_notes=order_data.get('csr_notes'),
                status=FuelOrderStatus.DISPATCHED
            )
            db.session.add(new_order)
            db.session.commit()
            return new_order, None
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error creating fuel order: {str(e)}")
            return None, f"Database error creating fuel order: {str(e)}"
            return None, "Missing required fields: tail_number, fuel_type, assigned_lst_user_id, and assigned_truck_id are required"

        # Check if aircraft exists
        aircraft = Aircraft.query.get(tail_number)
        if not aircraft:
            return None, f"Aircraft with tail number {tail_number} not found"

        # Check if LST user exists and is valid
        lst_user = User.query.get(assigned_lst_user_id)
        if not lst_user:
            return None, f"User with ID {assigned_lst_user_id} not found"
        if lst_user.role != UserRole.LST:
            return None, f"User {assigned_lst_user_id} is not an LST"
        if not lst_user.is_active:
            return None, f"LST user {assigned_lst_user_id} is not active"

        # Check if fuel truck exists and is active
        truck = FuelTruck.query.get(assigned_truck_id)
        if not truck:
            return None, f"Fuel truck with ID {assigned_truck_id} not found"
        if not truck.is_active:
            return None, f"Fuel truck {assigned_truck_id} is not active"

        # Check customer if provided
        if customer_id:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None, f"Customer with ID {customer_id} not found"

        # Create new FuelOrder instance
        try:
            new_order = FuelOrder(
                tail_number=tail_number,
                fuel_type=fuel_type,
                assigned_lst_user_id=assigned_lst_user_id,
                assigned_truck_id=assigned_truck_id,
                customer_id=customer_id,  # This is optional, will be None if not provided
                additive_requested=order_data.get('additive_requested', False),
                requested_amount=order_data.get('requested_amount'),
                location_on_ramp=order_data.get('location_on_ramp'),
                csr_notes=order_data.get('csr_notes'),
                # Set initial status and timestamps
                status=FuelOrderStatus.DISPATCHED,
                dispatch_timestamp=datetime.utcnow()
                # created_at will be set automatically by model default
            )

            # Add and commit to database
            db.session.add(new_order)
            db.session.commit()
            
            return new_order, None  # Return the created order with no error message
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating fuel order: {str(e)}")
            return None, f"Database error while creating fuel order: {str(e)}"

    @classmethod
    def get_fuel_orders(
        cls,
        current_user: User,
        filters: Optional[Dict[str, Any]] = None
    ) -> Tuple[Optional[Any], str]:
        """
        Retrieve paginated fuel orders based on user role and optional filters.
        
        Args:
            current_user (User): The authenticated user making the request
            filters (Optional[Dict[str, Any]]): Optional dictionary containing filter parameters
                - status (str): Filter by order status
                - page (int): Page number (default: 1)
                - per_page (int): Items per page (default: 20, max: 100)
                - Other filters can be added as needed
        
        Returns:
            Tuple[Optional[Any], str]: A tuple containing:
                - Pagination object if successful (contains items, page metadata), None if error
                - Success/error message
        """
        # Initialize base query
        query = FuelOrder.query

        # Apply role-based filtering
        if current_user.role == UserRole.LST:
            # LSTs can only see orders assigned to them
            query = query.filter(FuelOrder.assigned_lst_user_id == current_user.id)
        elif current_user.role in [UserRole.CSR, UserRole.ADMIN]:
            # CSRs and Admins can see all orders
            pass
        else:
            current_app.logger.error(f"Unexpected user role encountered: {current_user.role}")
            return None, "Forbidden: User role cannot access orders"
        
        # Apply filtering based on request parameters
        if filters:
            # Filter by status
            status_filter = filters.get('status')
            if status_filter:
                try:
                    # Convert string status from filter to FuelOrderStatus enum member
                    status_enum = FuelOrderStatus[status_filter.upper()]
                    query = query.filter(FuelOrder.status == status_enum)
                except KeyError:
                    # Invalid status string provided in filter
                    return None, f"Invalid status value provided: {status_filter}"

            # TODO: Add other filters here (e.g., date range, tail_number)

        # Extract and validate pagination parameters
        try:
            page = int(filters.get('page', 1))
            per_page = int(filters.get('per_page', 20))
            
            # Validate pagination parameters
            if page < 1:
                page = 1
            if per_page < 1:
                per_page = 20
            if per_page > 100:  # Maximum limit to prevent abuse
                per_page = 100
                
        except (ValueError, TypeError):
            # Handle invalid pagination parameters
            page = 1
            per_page = 20

        try:
            # Apply default sorting and pagination
            paginated_orders = query.order_by(FuelOrder.created_at.desc()).paginate(
                page=page,
                per_page=per_page,
                error_out=False
            )
            return paginated_orders, "Orders retrieved successfully"
            
        except Exception as e:
            current_app.logger.error(f"Error retrieving fuel orders: {str(e)}")
            return None, f"Database error while retrieving orders: {str(e)}"

    @classmethod
    def get_fuel_order_by_id(
        cls,
        order_id: int,
        current_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Retrieve a specific fuel order by ID after performing authorization checks.
        
        Args:
            order_id (int): The ID of the order to retrieve
            current_user (User): The authenticated user making the request
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 403, 404)
        """
        # Basic fetch for now. Add joinedload/selectinload options later for optimization if needed.
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Perform Authorization Check
        if current_user.role == UserRole.LST:
            # LST can only view orders assigned to them
            if order.assigned_lst_user_id != current_user.id:
                return None, "Forbidden: You are not assigned to this fuel order.", 403  # Forbidden
        elif current_user.role in [UserRole.CSR, UserRole.ADMIN]:
            # CSRs and Admins can view any order
            pass  # No additional check needed for these roles
        else:
            # Should not happen due to auth middleware, but let's be thorough
            return None, "Forbidden: Invalid user role.", 403

        # Return the order object
        return order, "Fuel order retrieved successfully.", 200  # OK

    @classmethod
    def update_order_status(
        cls,
        order_id: int,
        new_status: FuelOrderStatus,
        current_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Update the status of a fuel order after performing authorization checks.
        
        Args:
            order_id (int): The ID of the order to update
            new_status (FuelOrderStatus): The target status to update to
            current_user (User): The authenticated user performing the action
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The updated FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 403, 404)
        """
        # Fetch the fuel order by ID
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Check if the user is the assigned LST for this order
        if current_user.role == UserRole.LST:
            if order.assigned_lst_user_id != current_user.id:
                return None, "Forbidden: You are not assigned to this fuel order.", 403  # Forbidden
        elif current_user.role in [UserRole.CSR, UserRole.ADMIN]:
            # Restrict status changes strictly to LSTs for MVP workflow
            return None, "Forbidden: Only the assigned LST can update the status via this method.", 403
        else:
            # Should not happen due to auth middleware, but let's be thorough
            return None, "Forbidden: Invalid user role.", 403

        # Define allowed transitions for LST updates via this endpoint
        allowed_transitions = {
            FuelOrderStatus.DISPATCHED: [FuelOrderStatus.ACKNOWLEDGED],
            FuelOrderStatus.ACKNOWLEDGED: [FuelOrderStatus.EN_ROUTE],
            FuelOrderStatus.EN_ROUTE: [FuelOrderStatus.FUELING]
            # Note: Fueling -> Completed will be handled by a separate 'complete_order' endpoint
            # Note: Cancellation will be handled by a separate endpoint with different permissions
        }

        # Validate the requested transition
        if order.status not in allowed_transitions or new_status not in allowed_transitions[order.status]:
            return None, f"Invalid status transition from {order.status.value} to {new_status.value}.", 400  # Bad Request

        try:
            # Update the order status
            order.status = new_status

            # Update corresponding timestamp field based on the new status
            if new_status == FuelOrderStatus.ACKNOWLEDGED:
                order.acknowledge_timestamp = datetime.utcnow()
            elif new_status == FuelOrderStatus.EN_ROUTE:
                order.en_route_timestamp = datetime.utcnow()
            elif new_status == FuelOrderStatus.FUELING:
                order.fueling_start_timestamp = datetime.utcnow()

            # Commit the changes
            db.session.commit()

            return order, f"Order status successfully updated to {new_status.value}.", 200  # OK

        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating fuel order status: {str(e)}")
            return None, f"Database error while updating order status: {str(e)}", 500  # Internal Server Error

    @classmethod
    def complete_fuel_order(
        cls,
        order_id: int,
        completion_data: Dict[str, Any],
        current_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Complete a fuel order by updating its status and recording completion details.
        
        Args:
            order_id (int): The ID of the order to complete
            completion_data (Dict[str, Any]): Dictionary containing completion details
                Required keys:
                - start_meter_reading (str/Decimal): Starting meter reading
                - end_meter_reading (str/Decimal): Ending meter reading
                Optional keys:
                - lst_notes (str): Additional notes from the LST
            current_user (User): The authenticated user performing the action
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The updated FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 400, 403, 404)
        """
        # Fetch the fuel order by ID
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Perform Authorization Check: Ensure the user is the assigned LST
        if not (current_user.role == UserRole.LST and order.assigned_lst_user_id == current_user.id):
            # Also allow Admin/CSR maybe? For MVP, let's stick to LST.
            return None, "Forbidden: Only the assigned LST can complete this fuel order.", 403  # Forbidden

        # Perform Status Check: Ensure the order is in a state ready for completion
        if order.status != FuelOrderStatus.FUELING:
            # We could allow completion from other states like EN_ROUTE, ACKNOWLEDGED
            # but requiring FUELING enforces the workflow more strictly.
            return None, f"Order cannot be completed from its current status ({order.status.value}). Must be 'Fueling'.", 400  # Bad Request

        # Extract and validate meter readings
        try:
            start_meter = Decimal(completion_data['start_meter_reading'])
            end_meter = Decimal(completion_data['end_meter_reading'])
            if end_meter < start_meter:
                return None, "End meter reading cannot be less than start meter reading.", 400  # Bad Request
            # Add checks for negative values if necessary
            if start_meter < 0 or end_meter < 0:
                return None, "Meter readings cannot be negative.", 400
        except (KeyError, ValueError, TypeError):
            return None, "Invalid or missing meter reading values.", 400

        lst_notes = completion_data.get('lst_notes')  # Optional notes

        # Calculate gallons dispensed
        gallons_dispensed = end_meter - start_meter

        # Update order fields
        order.start_meter_reading = start_meter
        order.end_meter_reading = end_meter
        order.calculated_gallons_dispensed = gallons_dispensed
        order.lst_notes = lst_notes  # Update notes (will be None if not provided)
        order.status = FuelOrderStatus.COMPLETED  # Set status to Completed
        order.completion_timestamp = datetime.utcnow()  # Record completion time

        try:
            db.session.commit()
            return order, "Fuel order completed successfully.", 200  # OK
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error completing fuel order: {str(e)}")
            return None, f"Database error while completing order: {str(e)}", 500  # Internal Server Error

    @classmethod
    def review_fuel_order(
        cls,
        order_id: int,
        reviewer_user: User
    ) -> Tuple[Optional[FuelOrder], str, int]:
        """
        Review a completed fuel order.
        
        Args:
            order_id (int): The ID of the order to review
            reviewer_user (User): The authenticated CSR or Admin user performing the review
            
        Returns:
            Tuple[Optional[FuelOrder], str, int]: A tuple containing:
                - The updated FuelOrder if successful, None if failed
                - A success/error message
                - HTTP status code (200, 400, 404)
        """
        # Fetch the fuel order by ID
        order = FuelOrder.query.get(order_id)
        if not order:
            return None, f"Fuel order with ID {order_id} not found.", 404  # Not Found

        # Perform Status Check: Ensure the order is 'COMPLETED' before it can be reviewed
        if order.status != FuelOrderStatus.COMPLETED:
            return None, f"Order cannot be reviewed. Current status is '{order.status.value}', must be 'Completed'.", 400  # Bad Request

        # Update order fields with review information
        order.status = FuelOrderStatus.REVIEWED
        order.reviewed_by_csr_user_id = reviewer_user.id
        order.reviewed_timestamp = datetime.utcnow()

        try:
            db.session.commit()
            return order, "Fuel order marked as reviewed.", 200  # OK
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error reviewing fuel order: {str(e)}")
            return None, f"Database error while marking order as reviewed: {str(e)}", 500  # Internal Server Error

    @classmethod
    def export_fuel_orders_to_csv(
        cls,
        current_user: User,
        filters: Optional[Dict[str, Any]] = None
    ) -> Tuple[Optional[str], str, int]:
        """
        Fetch fuel orders for CSV export based on filters and format them into a CSV string.
        
        Args:
            current_user (User): The authenticated user requesting the export
            filters (Optional[Dict[str, Any]]): Optional dictionary containing filter parameters
                - status (str): Override default REVIEWED status filter
                - date_from (str): Filter orders from this date (TODO)
                - date_to (str): Filter orders until this date (TODO)
                
        Returns:
            Tuple[Optional[str], str, int]: A tuple containing:
                - CSV data string if successful, None if failed
                - A success/error message
                - HTTP status code (200, 400, 500)
        """
        # Authorization check: Only CSR and Admin can export
        if current_user.role not in [UserRole.CSR, UserRole.ADMIN]:
            return None, "Forbidden: Only CSR and Admin users can export fuel orders.", 403

        # Initialize base query
        query = FuelOrder.query

        # Apply default status filter (REVIEWED) or override from filters
        target_status = FuelOrderStatus.REVIEWED  # Default export status
        if filters and filters.get('status'):
            try:
                # Allow overriding default status via filter
                target_status = FuelOrderStatus[filters['status'].upper()]
            except KeyError:
                return None, f"Invalid status value provided for export: {filters['status']}", 400

        query = query.filter(FuelOrder.status == target_status)

        try:
            # Fetch all orders matching the criteria, ordered by review timestamp
            orders_to_export = query.order_by(FuelOrder.reviewed_timestamp.desc()).all()

            if not orders_to_export:
                return [], "No orders found matching the criteria for export.", 200

            # Create in-memory text stream for CSV writing
            output = io.StringIO()
            writer = csv.writer(output)

            # Define and write the header row
            header = [
                'Order ID', 'Status', 'Tail Number', 'Customer ID',
                'Fuel Type', 'Additive Requested', 'Requested Amount',
                'Assigned LST ID', 'Assigned Truck ID',
                'Location on Ramp', 'CSR Notes',
                'Start Meter', 'End Meter', 'Gallons Dispensed', 'LST Notes',
                'Created At (UTC)', 'Dispatch Timestamp (UTC)', 'Acknowledge Timestamp (UTC)',
                'En Route Timestamp (UTC)', 'Fueling Start Timestamp (UTC)',
                'Completion Timestamp (UTC)', 'Reviewed Timestamp (UTC)', 'Reviewed By CSR ID'
            ]
            writer.writerow(header)

            # Helper function to format values safely
            def format_value(value):
                if value is None:
                    return ''
                if isinstance(value, datetime):
                    return value.strftime('%Y-%m-%d %H:%M:%S')  # Consistent UTC format
                if isinstance(value, Decimal):
                    return str(value)  # Convert Decimal to string
                if isinstance(value, bool):
                    return 'Yes' if value else 'No'
                if isinstance(value, FuelOrderStatus):
                    return value.value  # Get enum string value
                return str(value)

            # Write each order as a row in the CSV
            for order in orders_to_export:
                row = [
                    order.id,
                    format_value(order.status),
                    order.tail_number,
                    format_value(order.customer_id),
                    order.fuel_type,
                    format_value(order.additive_requested),
                    format_value(order.requested_amount),
                    format_value(order.assigned_lst_user_id),
                    format_value(order.assigned_truck_id),
                    order.location_on_ramp or '',  # Use empty string for None strings
                    order.csr_notes or '',
                    format_value(order.start_meter_reading),
                    format_value(order.end_meter_reading),
                    format_value(order.calculated_gallons_dispensed),
                    order.lst_notes or '',
                    format_value(order.created_at),
                    format_value(order.dispatch_timestamp),
                    format_value(order.acknowledge_timestamp),
                    format_value(order.en_route_timestamp),
                    format_value(order.fueling_start_timestamp),
                    format_value(order.completion_timestamp),
                    format_value(order.reviewed_timestamp),
                    format_value(order.reviewed_by_csr_user_id)
                ]
                writer.writerow(row)

            # Get the CSV string and close the stream
            csv_data = output.getvalue()
            output.close()

            return csv_data, "CSV data generated successfully.", 200

        except Exception as e:
            current_app.logger.error(f"Error generating CSV export: {str(e)}")
            return None, f"Error generating CSV export: {str(e)}", 500
</file>

<file path="fbo-launchpad-backend/src/utils/__init__.py">
"""
Utility functions and decorators for the FBO LaunchPad backend.
"""
</file>

<file path="fbo-launchpad-backend/src/utils/decorators.py">
"""
Authentication decorators for protecting API routes.
"""
from functools import wraps
from flask import request, jsonify, current_app, g
import jwt
from ..models.user import User, UserRole


def token_required(f):
    """
    A decorator that protects routes by verifying the JWT token in the Authorization header.
    
    The token must be provided in the format: 'Bearer <token>'.
    On successful verification, the authenticated user is stored in g.current_user.
    
    Args:
        f: The route function to be decorated.
        
    Returns:
        decorated_function: The wrapped function that performs token verification.
        
    Raises:
        401 Unauthorized: If the token is missing, invalid, expired, or the user is not found/inactive.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = None
        auth_header = request.headers.get('Authorization')
        
        print(f"Auth header: {auth_header}")
        
        # Check if Authorization header exists and follows Bearer scheme
        if auth_header:
            try:
                # Extract token from "Bearer <token>"
                token_parts = auth_header.split()
                if len(token_parts) == 2 and token_parts[0].lower() == 'bearer':
                    token = token_parts[1]
                print(f"Token parts: {token_parts}")
            except Exception as e:
                print(f"Error parsing auth header: {e}")
                return jsonify({"error": "Invalid Authorization header format"}), 401
        
        if not token:
            return jsonify({"error": "Authentication token is missing!"}), 401
            
        try:
            # Decode and verify the token
            print(f"Decoding token: {token}")
            payload = jwt.decode(
                token,
                current_app.config['JWT_SECRET_KEY'],
                algorithms=[current_app.config.get('JWT_ALGORITHM', 'HS256')]
            )
            print(f"Token payload: {payload}")
            
            # Get user from database
            user_id = payload['sub']
            if not isinstance(user_id, str):
                user_id = str(user_id)
            current_user = User.query.get(int(user_id))
            print(f"Found user: {current_user}")
            
            # Verify user exists and is active
            if not current_user or not current_user.is_active:
                return jsonify({"error": "User not found or inactive"}), 401
                
            # Store user in request context
            g.current_user = current_user
            
        except jwt.ExpiredSignatureError:
            print("Token expired")
            return jsonify({"error": "Token has expired!"}), 401
        except jwt.InvalidTokenError as e:
            print(f"Invalid token: {e}")
            return jsonify({"error": "Invalid token!"}), 401
        except Exception as e:
            print(f"Token processing error: {e}")
            return jsonify({"error": "Token processing error"}), 401
            
        return f(*args, **kwargs)
        
    return decorated_function 

def require_permission(permission_name: str):
    """
    Decorator to ensure the logged-in user has the specified permission.
    Must be applied AFTER @token_required.
    """
    def _decorator(f):
        @wraps(f)
        def _wrapper(*args, **kwargs):
            # 1. Check if user context exists (from @token_required)
            if not hasattr(g, 'current_user') or not g.current_user:
                # Log this internal server error
                print(f"ERROR: g.current_user not found in @require_permission('{permission_name}'). Check decorator order.")
                return jsonify({"error": "Internal Server Error: Authentication context missing"}), 500

            # 2. Check if the user has the required permission
            if not g.current_user.has_permission(permission_name):
                return jsonify({"error": f"Forbidden: Requires permission '{permission_name}'"}), 403

            # 3. Permission granted, proceed to the route function
            return f(*args, **kwargs)
        return _wrapper
    return _decorator
</file>

<file path="fbo-launchpad-backend/src/utils/README.md">
# Authentication Decorators

This module provides authentication decorators for protecting API routes in the FBO LaunchPad backend.

## `@token_required` Decorator

The `@token_required` decorator provides JWT-based authentication for Flask routes. It verifies the presence and validity of a JWT token in the request's Authorization header and makes the authenticated user available to the route handler.

### Configuration

Before using the decorator, ensure your Flask application has the following configuration:

```python
app.config['SECRET_KEY'] = 'your-secure-secret-key'  # Use a strong secret key in production
```

### Usage

Import and apply the decorator to your route handlers:

```python
from src.utils.decorators import token_required

@app.route('/api/protected')
@token_required
def protected_route():
    # Access the authenticated user from Flask's g object
    current_user = g.current_user
    return jsonify({
        "message": f"Hello {current_user.name}!",
        "user_id": current_user.id
    })
```

### Authentication Flow

1. **Token Format**: The client must include the JWT token in the Authorization header using the Bearer scheme:
   ```
   Authorization: Bearer <your-jwt-token>
   ```

2. **Validation Process**:
   - Verifies the presence of the Authorization header
   - Validates the Bearer scheme format
   - Decodes and verifies the JWT signature
   - Checks token expiration
   - Retrieves and validates the user from the database
   - Makes the user object available via `g.current_user`

3. **Error Handling**: The decorator returns appropriate 401 Unauthorized responses for various failure cases:

   | Error Case | Response |
   |------------|----------|
   | Missing Authorization header | `{"error": "Authentication token is missing!"}` |
   | Invalid header format | `{"error": "Invalid Authorization header format"}` |
   | Expired token | `{"error": "Token has expired!"}` |
   | Invalid token signature | `{"error": "Invalid token!"}` |
   | User not found/inactive | `{"error": "User not found or inactive"}` |
   | Other token errors | `{"error": "Token processing error"}` |

### Example Client Usage

```python
import requests

def make_authenticated_request(token, endpoint):
    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    response = requests.get(
        f'https://api.fbolaunchpad.com{endpoint}',
        headers=headers
    )
    return response

# Example usage
token = "your.jwt.token"
response = make_authenticated_request(token, '/api/protected')
if response.status_code == 200:
    print("Success:", response.json())
else:
    print("Error:", response.json())
```

### Security Considerations

1. **Token Storage**: 
   - Store tokens securely on the client side (e.g., HttpOnly cookies for web applications)
   - Never store tokens in localStorage or sessionStorage due to XSS vulnerabilities

2. **Token Expiration**:
   - Use short-lived tokens (e.g., 15-60 minutes)
   - Implement token refresh mechanisms for longer sessions

3. **HTTPS**:
   - Always use HTTPS in production to prevent token interception
   - Consider adding additional security headers (e.g., HSTS)

4. **Error Messages**:
   - The decorator provides generic error messages to avoid leaking sensitive information
   - In development, you may want to enable more detailed error messages

### Dependencies

- Flask
- PyJWT
- SQLAlchemy (via Flask-SQLAlchemy)

### Best Practices

1. **Route Protection**:
   ```python
   # Protect all routes in a Blueprint
   @blueprint.before_request
   @token_required
   def before_request():
       pass
   ```

2. **Role-Based Access**:
   ```python
   from functools import wraps
   from flask import g

   def admin_required(f):
       @wraps(f)
       @token_required
       def decorated(*args, **kwargs):
           if g.current_user.role != UserRole.ADMIN:
               return jsonify({"error": "Admin access required"}), 403
           return f(*args, **kwargs)
       return decorated

   # Usage
   @app.route('/admin/dashboard')
   @admin_required
   def admin_dashboard():
       return jsonify({"message": "Welcome, Admin!"})
   ```

3. **Error Handling**:
   ```python
   from flask import Blueprint
   
   api = Blueprint('api', __name__)
   
   @api.errorhandler(401)
   def handle_unauthorized(error):
       return jsonify({
           "error": "Unauthorized",
           "message": "Please authenticate to access this resource"
       }), 401
   ```

### Testing

When writing tests for protected routes, you'll need to create valid JWT tokens:

```python
import jwt
import datetime

def create_test_token(user_id):
    return jwt.encode(
        {
            'sub': user_id,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=30)
        },
        current_app.config['SECRET_KEY'],
        algorithm='HS256'
    )

def test_protected_route(client, test_user):
    token = create_test_token(test_user.id)
    headers = {'Authorization': f'Bearer {token}'}
    response = client.get('/api/protected', headers=headers)
    assert response.status_code == 200
```
</file>

<file path="fbo-launchpad-backend/src/__init__.py">
"""
FBO LaunchPad Backend Package
"""

from flask import Flask
from flask_cors import CORS
from .config import config
from .extensions import db, migrate, jwt

def create_app(config_name='default'):
    app = Flask(__name__)
    
    # Load config
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)
    
    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    CORS(app)
    
    # Import models to ensure they are registered with SQLAlchemy
    from .models.user import User
    from .models.aircraft import Aircraft
    from .models.customer import Customer
    from .models.fuel_truck import FuelTruck
    from .models.fuel_order import FuelOrder
    
    # Register blueprints
    from .routes.auth_routes import auth_bp
    from .routes.admin.routes import admin_bp
    from .routes.user_routes import user_bp
    from .routes.fuel_order_routes import fuel_order_bp
    from .routes.fuel_truck_routes import truck_bp
    from .routes.aircraft_routes import aircraft_bp
    from .routes.customer_routes import customer_bp
    
    app.register_blueprint(auth_bp)
    app.register_blueprint(admin_bp)
    app.register_blueprint(user_bp, url_prefix='/api/users')
    app.register_blueprint(fuel_order_bp, url_prefix='/api/fuel-orders')
    app.register_blueprint(truck_bp, url_prefix='/api/fuel-trucks')
    app.register_blueprint(aircraft_bp, url_prefix='/api/aircraft')
    app.register_blueprint(customer_bp, url_prefix='/api/customers')
    
    return app
</file>

<file path="fbo-launchpad-backend/src/app.py">
import os
from flask import Flask, jsonify, current_app
from flask_cors import CORS
from apispec.ext.marshmallow import MarshmallowPlugin
from apispec_webframeworks.flask import FlaskPlugin

from src.config import config
from src.extensions import db, migrate, jwt, apispec, marshmallow_plugin
from src.cli import init_app as init_cli  # Import CLI initialization
from src.schemas import (
    RegisterRequestSchema,
    UserResponseSchema,
    RegisterResponseSchema,
    LoginRequestSchema,
    LoginSuccessResponseSchema,
    ErrorResponseSchema,
    FuelOrderCreateRequestSchema,
    FuelOrderStatusUpdateRequestSchema,
    FuelOrderCompleteRequestSchema,
    FuelOrderResponseSchema,
    FuelOrderBriefResponseSchema,
    FuelOrderCreateResponseSchema,
    FuelOrderUpdateResponseSchema,
    PaginationSchema,
    FuelOrderListResponseSchema,
    FuelTruckSchema,
    FuelTruckListResponseSchema,
    FuelTruckCreateRequestSchema,
    FuelTruckCreateResponseSchema,
    OrderStatusCountsSchema,
    OrderStatusCountsResponseSchema
)

def create_app(config_name=None):
    """Application factory function."""
    if config_name is None:
        config_name = os.getenv('FLASK_ENV', 'development')

    # Create Flask app instance
    app = Flask(__name__)

    # TROUBLESHOOTING: Allow all origins and headers to isolate CORS issues
    CORS(
        app,
        origins="*",
        allow_headers="*",
        expose_headers="*",
        methods=["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
        supports_credentials=True
    )

    # Load config
    app.config.from_object(config[config_name])

    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    init_cli(app)

    # Initialize API documentation with apispec
    flask_plugin = FlaskPlugin()
    apispec.plugins = [flask_plugin, marshmallow_plugin]

    # Re-initialize resolver for marshmallow plugin with updated plugins
    marshmallow_plugin.init_spec(apispec)
    
    # Add security scheme for JWT
    apispec.components.security_scheme(
        "bearerAuth",
        {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    )

    # Import blueprints here to avoid circular imports
    from src.routes.auth_routes import auth_bp
    from src.routes.fuel_order_routes import fuel_order_bp
    from src.routes.user_routes import user_bp
    from src.routes.fuel_truck_routes import truck_bp
    from src.routes.aircraft_routes import aircraft_bp
    from src.routes.customer_routes import customer_bp
    from src.routes.admin.routes import admin_bp

    # Register blueprints
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(fuel_order_bp, url_prefix='/api/fuel-orders')
    app.register_blueprint(user_bp, url_prefix='/api/users')
    app.register_blueprint(truck_bp, url_prefix='/api/fuel-trucks')
    app.register_blueprint(aircraft_bp, url_prefix='/api/aircraft')
    app.register_blueprint(customer_bp, url_prefix='/api/customers')
    app.register_blueprint(admin_bp)

    # Register schemas and paths with apispec
    with app.app_context():
        # Attach spec to app for use in other modules
        app.spec = apispec

        # Register Auth Schemas
        apispec.components.schema("RegisterRequestSchema", schema=RegisterRequestSchema)
        apispec.components.schema("UserResponseSchema", schema=UserResponseSchema)
        apispec.components.schema("RegisterResponseSchema", schema=RegisterResponseSchema)
        apispec.components.schema("LoginRequestSchema", schema=LoginRequestSchema)
        apispec.components.schema("LoginSuccessResponseSchema", schema=LoginSuccessResponseSchema)
        apispec.components.schema("ErrorResponseSchema", schema=ErrorResponseSchema)

        # Register User Admin Schemas
        from src.schemas.user_schemas import (
            UserCreateRequestSchema, UserUpdateRequestSchema,
            UserDetailSchema, UserListResponseSchema, UserBriefSchema,
            RoleBriefSchema
        )
        apispec.components.schema("RoleBriefSchema", schema=RoleBriefSchema)
        apispec.components.schema("UserBriefSchema", schema=UserBriefSchema)
        apispec.components.schema("UserCreateRequestSchema", schema=UserCreateRequestSchema)
        apispec.components.schema("UserUpdateRequestSchema", schema=UserUpdateRequestSchema)
        apispec.components.schema("UserDetailSchema", schema=UserDetailSchema)
        apispec.components.schema("UserListResponseSchema", schema=UserListResponseSchema)

        # Register Fuel Order Schemas
        apispec.components.schema("FuelOrderCreateRequestSchema", schema=FuelOrderCreateRequestSchema)
        apispec.components.schema("FuelOrderStatusUpdateRequestSchema", schema=FuelOrderStatusUpdateRequestSchema)
        apispec.components.schema("FuelOrderCompleteRequestSchema", schema=FuelOrderCompleteRequestSchema)
        apispec.components.schema("FuelOrderResponseSchema", schema=FuelOrderResponseSchema)
        apispec.components.schema("FuelOrderBriefResponseSchema", schema=FuelOrderBriefResponseSchema)
        apispec.components.schema("FuelOrderCreateResponseSchema", schema=FuelOrderCreateResponseSchema)
        apispec.components.schema("FuelOrderUpdateResponseSchema", schema=FuelOrderUpdateResponseSchema)
        apispec.components.schema("PaginationSchema", schema=PaginationSchema)
        apispec.components.schema("FuelOrderListResponseSchema", schema=FuelOrderListResponseSchema)
        apispec.components.schema("OrderStatusCountsSchema", schema=OrderStatusCountsSchema)
        apispec.components.schema("OrderStatusCountsResponseSchema", schema=OrderStatusCountsResponseSchema)

        # Register Fuel Truck Schemas
        apispec.components.schema("FuelTruckSchema", schema=FuelTruckSchema)
        apispec.components.schema("FuelTruckListResponseSchema", schema=FuelTruckListResponseSchema)
        apispec.components.schema("FuelTruckCreateRequestSchema", schema=FuelTruckCreateRequestSchema)
        apispec.components.schema("FuelTruckCreateResponseSchema", schema=FuelTruckCreateResponseSchema)

        # Register Aircraft Schemas
        from src.schemas.aircraft_schemas import (
            AircraftCreateSchema,
            AircraftUpdateSchema,
            AircraftResponseSchema,
            AircraftListSchema,
            ErrorResponseSchema as AircraftErrorResponseSchema
        )
        apispec.components.schema("AircraftCreateSchema", schema=AircraftCreateSchema)
        apispec.components.schema("AircraftUpdateSchema", schema=AircraftUpdateSchema)
        apispec.components.schema("AircraftResponseSchema", schema=AircraftResponseSchema)
        apispec.components.schema("AircraftListSchema", schema=AircraftListSchema)
        apispec.components.schema("AircraftErrorResponseSchema", schema=AircraftErrorResponseSchema)

        # Register Customer Schemas
        from src.schemas.customer_schemas import (
            CustomerCreateSchema,
            CustomerUpdateSchema,
            CustomerResponseSchema,
            CustomerListSchema,
            ErrorResponseSchema as CustomerErrorResponseSchema
        )
        apispec.components.schema("CustomerCreateSchema", schema=CustomerCreateSchema)
        apispec.components.schema("CustomerUpdateSchema", schema=CustomerUpdateSchema)
        apispec.components.schema("CustomerResponseSchema", schema=CustomerResponseSchema)
        apispec.components.schema("CustomerListSchema", schema=CustomerListSchema)
        apispec.components.schema("CustomerErrorResponseSchema", schema=CustomerErrorResponseSchema)

        # Register Admin Schemas
        from src.schemas.admin_schemas import (
            AdminAircraftSchema, AdminAircraftListResponseSchema,
            AdminCustomerSchema, AdminCustomerListResponseSchema
        )
        apispec.components.schema("AdminAircraftSchema", schema=AdminAircraftSchema)
        apispec.components.schema("AdminAircraftListResponseSchema", schema=AdminAircraftListResponseSchema)
        apispec.components.schema("AdminCustomerSchema", schema=AdminCustomerSchema)
        apispec.components.schema("AdminCustomerListResponseSchema", schema=AdminCustomerListResponseSchema)

        # Register Permission Schemas
        from src.routes.admin.permission_admin_routes import PermissionListResponseSchema
        from src.schemas import PermissionSchema
        apispec.components.schema("PermissionSchema", schema=PermissionSchema)
        apispec.components.schema("PermissionListResponseSchema", schema=PermissionListResponseSchema)

        # Register Auth Views
        from src.routes.auth_routes import register, login
        apispec.path(view=register, bp=auth_bp)
        apispec.path(view=login, bp=auth_bp)

        # Register User Views
        from src.routes.user_routes import get_users
        apispec.path(view=get_users, bp=user_bp)

        # Register Fuel Order Views
        from src.routes.fuel_order_routes import (
            create_fuel_order, get_fuel_orders, get_fuel_order,
            update_fuel_order_status, submit_fuel_data, review_fuel_order,
            export_fuel_orders_csv, get_status_counts
        )
        apispec.path(view=create_fuel_order, bp=fuel_order_bp)
        apispec.path(view=get_fuel_orders, bp=fuel_order_bp)
        apispec.path(view=get_fuel_order, bp=fuel_order_bp)
        apispec.path(view=update_fuel_order_status, bp=fuel_order_bp)
        apispec.path(view=submit_fuel_data, bp=fuel_order_bp)
        apispec.path(view=review_fuel_order, bp=fuel_order_bp)
        apispec.path(view=export_fuel_orders_csv, bp=fuel_order_bp)
        apispec.path(view=get_status_counts, bp=fuel_order_bp)

        # Register Fuel Truck Views
        from src.routes.fuel_truck_routes import get_fuel_trucks, create_fuel_truck
        apispec.path(view=get_fuel_trucks, bp=truck_bp)
        apispec.path(view=create_fuel_truck, bp=truck_bp)

        # Register Aircraft Views
        from src.routes.aircraft_routes import list_aircraft, create_aircraft, get_aircraft, update_aircraft, delete_aircraft
        apispec.path(view=list_aircraft, bp=aircraft_bp)
        apispec.path(view=create_aircraft, bp=aircraft_bp)
        apispec.path(view=get_aircraft, bp=aircraft_bp)
        apispec.path(view=update_aircraft, bp=aircraft_bp)
        apispec.path(view=delete_aircraft, bp=aircraft_bp)

        # Register Admin Views
        from src.routes.admin.aircraft_admin_routes import list_aircraft as admin_list_aircraft, create_aircraft as admin_create_aircraft, get_aircraft as admin_get_aircraft, update_aircraft as admin_update_aircraft, delete_aircraft as admin_delete_aircraft
        from src.routes.admin.customer_admin_routes import list_customers as admin_list_customers, create_customer as admin_create_customer, get_customer as admin_get_customer, update_customer as admin_update_customer, delete_customer as admin_delete_customer
        from src.routes.admin.permission_admin_routes import get_permissions
        from src.routes.admin.user_admin_routes import get_users as admin_get_users, create_user as admin_create_user, get_user as admin_get_user, update_user as admin_update_user, delete_user as admin_delete_user
        from src.routes.admin.role_admin_routes import get_roles, create_role, get_role, update_role, delete_role, get_role_permissions

        # Register Admin Aircraft Views
        apispec.path(view=admin_list_aircraft, bp=admin_bp)
        apispec.path(view=admin_create_aircraft, bp=admin_bp)
        apispec.path(view=admin_get_aircraft, bp=admin_bp)
        apispec.path(view=admin_update_aircraft, bp=admin_bp)
        apispec.path(view=admin_delete_aircraft, bp=admin_bp)

        # Register Admin Customer Views
        apispec.path(view=admin_list_customers, bp=admin_bp)
        apispec.path(view=admin_create_customer, bp=admin_bp)
        apispec.path(view=admin_get_customer, bp=admin_bp)
        apispec.path(view=admin_update_customer, bp=admin_bp)
        apispec.path(view=admin_delete_customer, bp=admin_bp)

        # Register Admin User Views
        apispec.path(view=admin_get_users, bp=admin_bp)
        apispec.path(view=admin_create_user, bp=admin_bp)
        apispec.path(view=admin_get_user, bp=admin_bp)
        apispec.path(view=admin_update_user, bp=admin_bp)
        apispec.path(view=admin_delete_user, bp=admin_bp)

        # Register Admin Role Views
        apispec.path(view=get_roles, bp=admin_bp)
        apispec.path(view=create_role, bp=admin_bp)
        apispec.path(view=get_role, bp=admin_bp)
        apispec.path(view=update_role, bp=admin_bp)
        apispec.path(view=delete_role, bp=admin_bp)
        apispec.path(view=get_role_permissions, bp=admin_bp)

        # Register Admin Permission Views
        apispec.path(view=get_permissions, bp=admin_bp)

    @app.route('/')
    def root():
        """Root endpoint."""
        return jsonify({"status": "ok", "message": "FBO LaunchPad API is running"})

    @app.route('/health')
    def health_check():
        """Basic health check endpoint."""
        return jsonify({'status': 'healthy', 'message': 'FBO LaunchPad API is running'})

    @app.route('/api/swagger.json')
    def create_swagger_spec():
        """Serve the swagger specification."""
        return jsonify(app.spec.to_dict())

    # Add global CORS headers to every response (including errors)
    @app.after_request
    def add_cors_headers(response):
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Headers'] = '*'
        response.headers['Access-Control-Allow-Methods'] = 'GET,POST,PUT,DELETE,OPTIONS'
        return response

    return app

if __name__ == '__main__':
    app = create_app()
    app.run()
</file>

<file path="fbo-launchpad-backend/src/config.py">
import os
from dotenv import load_dotenv
from datetime import timedelta

# Load environment variables from .env file
load_dotenv()

class Config:
    """Base configuration class."""
    # Flask
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard-to-guess-string'
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'jwt-secret-string'
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)
    JWT_ALGORITHM = 'HS256'
    JWT_TOKEN_LOCATION = ['headers']
    JWT_HEADER_NAME = 'Authorization'
    JWT_HEADER_TYPE = 'Bearer'
    FLASK_ENV = os.getenv('FLASK_ENV', 'development')
    DEBUG = os.getenv('DEBUG', 'True').lower() == 'true'

    # Database
    SQLALCHEMY_DATABASE_URI = os.getenv('SQLALCHEMY_DATABASE_URI')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ECHO = os.getenv('SQLALCHEMY_ECHO', 'False').lower() == 'true'

    # Application specific
    APP_NAME = os.getenv('APP_NAME', 'FBO LaunchPad')
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'DEBUG')

    @staticmethod
    def init_app(app):
        pass

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'postgresql://fbo_user:fbo_password@db:5432/fbo_launchpad_dev'

class ProductionConfig(Config):
    """Production configuration."""
    DEBUG = False
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'postgresql://fbo_user:fbo_password@db:5432/fbo_launchpad'

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    # Use environment variable if set, otherwise use Docker service name
    SQLALCHEMY_DATABASE_URI = os.environ.get('SQLALCHEMY_DATABASE_URI') or \
        'postgresql://fbo_user:fbo_password@db:5432/fbo_launchpad_test'
    # Keep test output clean
    SQLALCHEMY_ECHO = False
    # Disable CSRF for testing if using Flask-WTF
    WTF_CSRF_ENABLED = False
    # Disable error catching during request handling
    PROPAGATE_EXCEPTIONS = True
    # Disable Flask-DebugToolbar if installed
    DEBUG_TB_ENABLED = False

    @classmethod
    def init_app(cls, app):
        """Initialize the testing configuration."""
        Config.init_app(app)
        # Ensure SQLAlchemy always uses the test database URL
        app.config['SQLALCHEMY_DATABASE_URI'] = cls.SQLALCHEMY_DATABASE_URI

# Configuration dictionary
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}
</file>

<file path="fbo-launchpad-backend/src/extensions.py">
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from apispec import APISpec
from apispec.ext.marshmallow import MarshmallowPlugin
from flask_jwt_extended import JWTManager

# Database
db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()

# API documentation
marshmallow_plugin = MarshmallowPlugin()
apispec = APISpec(
    title="FBO LaunchPad API",
    version="1.0.0",
    openapi_version="3.0.2",
    plugins=[marshmallow_plugin],
    info=dict(description="API for FBO LaunchPad")
)

# Initialize resolver for marshmallow plugin
marshmallow_plugin.init_spec(apispec)
</file>

<file path="fbo-launchpad-backend/.gitignore">
# Environment variables
.env

# Python virtual environment
venv/
*/venv/

# Python cache files
__pycache__/
*.py[cod]
*$py.class

# Docker
docker-compose.override.yml

# IDE / Editor specific
.vscode/
.idea/
*.swp
</file>

<file path="fbo-launchpad-backend/docker-compose.yml">
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "5001:5000"
    volumes:
      - ./src:/app/src
      - ./migrations:/app/migrations
      - ./tests:/app/tests
    env_file:
      - .env
    depends_on:
      - db
    environment:
      - FLASK_APP=src/app.py
      - FLASK_ENV=development
    restart: unless-stopped

  db:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    environment:
      - POSTGRES_USER=fbo_user
      - POSTGRES_PASSWORD=fbo_password
      - POSTGRES_DB=fbo_launchpad_dev
    ports:
      - "5433:5432"
    restart: unless-stopped

volumes:
  postgres_data:
</file>

<file path="fbo-launchpad-backend/Dockerfile">
# Use Python 3.10 slim image as base
FROM python:3.10-slim

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    FLASK_APP=src/app.py \
    PYTHONDONTWRITEBYTECODE=1

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements file
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application
COPY src/ src/
COPY migrations/ migrations/

# Expose the application port
EXPOSE 5000

# Command to run the application
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "src.app:create_app()", "--workers", "4", "--reload"]
</file>

<file path="fbo-launchpad-backend/requirements.txt">
Flask==3.0.2
Flask-Cors==5.0.1
Flask-Migrate==4.0.5
Flask-SQLAlchemy==3.1.1
PyJWT>=2.0.0,<3.0.0
apispec>=6.0.0,<7.0.0
apispec-webframeworks>=0.5.0,<1.0.0
gunicorn==21.2.0
marshmallow>=3.0.0,<4.0.0
psycopg2-binary==2.9.9
pytest==8.0.2
pytest-env==1.1.3
pytest-flask==1.3.0
python-dotenv==1.0.1
flask_jwt_extended
</file>

<file path="fbo-launchpad-frontend-csr/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="fbo-launchpad-frontend-csr/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="fbo-launchpad-frontend-csr/src/components/auth/Login.jsx">
import { useState, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../../contexts/AuthContext';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { login } = useContext(AuthContext);
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (isSubmitting) return;

    setIsSubmitting(true);
    setError('');

    try {
      await login(email, password);
      navigate('/dashboard');
    } catch (err) {
      setError(err.message || 'Invalid credentials');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} noValidate>
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
          disabled={isSubmitting}
        />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
          disabled={isSubmitting}
        />
      </div>
      {error && (
        <div role="alert" className="error-message">
          {error}
        </div>
      )}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
};

export default Login;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/auth/Login.test.jsx">
import { describe, it, expect, vi } from 'vitest';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { renderWithProviders } from '../../test/utils';
import Login from './Login';
import { AuthContext } from '../../contexts/AuthContext';
import { mockApiResponses } from '../../test/utils';

// Mock the auth service
vi.mock('../../services/authService', () => ({
  login: vi.fn(() => Promise.resolve(mockApiResponses.login)),
  getStoredToken: vi.fn(() => null),
  logoutUser: vi.fn(),
  loginUser: vi.fn(() => Promise.resolve(mockApiResponses.login))
}));

describe('Login Component', () => {
  it('renders login form', () => {
    renderWithProviders(<Login />);
    
    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();
  });

  it('handles successful login', async () => {
    const mockLogin = vi.fn(() => Promise.resolve());
    
    renderWithProviders(
      <AuthContext.Provider value={{ login: mockLogin }}>
        <Login />
      </AuthContext.Provider>
    );

    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole('button', { name: /login/i });

    fireEvent.change(usernameInput, { target: { value: 'testuser' } });
    fireEvent.change(passwordInput, { target: { value: 'password123' } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockLogin).toHaveBeenCalledWith('testuser', 'password123');
    });
  });

  it('displays error message on login failure', async () => {
    const mockLogin = vi.fn(() => Promise.reject(new Error('Invalid credentials')));
    
    renderWithProviders(
      <AuthContext.Provider value={{ login: mockLogin }}>
        <Login />
      </AuthContext.Provider>
    );

    const submitButton = screen.getByRole('button', { name: /login/i });
    fireEvent.click(submitButton);

    await waitFor(() => {
      const errorMessage = screen.getByRole('alert');
      expect(errorMessage).toHaveTextContent(/invalid credentials/i);
    });
  });
});
</file>

<file path="fbo-launchpad-frontend-csr/src/components/common/Icons.tsx">
import React from 'react';

interface IconProps {
  className?: string;
}

export const IconClock: React.FC<IconProps> = ({ className = '' }) => (
  <svg
    className={className}
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <circle cx="12" cy="12" r="10" />
    <polyline points="12 6 12 12 16 14" />
  </svg>
);

export const IconPlane: React.FC<IconProps> = ({ className = '' }) => (
  <svg
    className={className}
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <path d="M22 2L11 13" />
    <path d="M22 2L15 22L11 13L2 9L22 2Z" />
  </svg>
);

export const IconCheck: React.FC<IconProps> = ({ className = '' }) => (
  <svg
    className={className}
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <polyline points="20 6 9 17 4 12" />
  </svg>
);
</file>

<file path="fbo-launchpad-frontend-csr/src/components/common/PaginationControls.jsx">
import React from 'react';
import PropTypes from 'prop-types';

function PaginationControls({ paginationData, onPageChange }) {
  if (!paginationData || paginationData.total_pages <= 1) {
    return null;
  }

  const { page, total_pages, has_prev, has_next, total_items } = paginationData;

  return (
    <div className="px-4 py-3 flex items-center justify-between border-t border-gray-200 sm:px-6">
      <div className="flex-1 flex justify-between sm:hidden">
        <button
          onClick={() => has_prev && onPageChange(page - 1)}
          disabled={!has_prev}
          className={`relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md ${
            has_prev
              ? 'bg-white text-gray-700 hover:bg-gray-50'
              : 'bg-gray-100 text-gray-500 cursor-not-allowed'
          }`}
        >
          Previous
        </button>
        <button
          onClick={() => has_next && onPageChange(page + 1)}
          disabled={!has_next}
          className={`ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md ${
            has_next
              ? 'bg-white text-gray-700 hover:bg-gray-50'
              : 'bg-gray-100 text-gray-500 cursor-not-allowed'
          }`}
        >
          Next
        </button>
      </div>
      <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
        <div>
          <p className="text-sm text-gray-700">
            Showing page <span className="font-medium">{page}</span> of{' '}
            <span className="font-medium">{total_pages}</span> ({' '}
            <span className="font-medium">{total_items}</span> total items )
          </p>
        </div>
        <div>
          <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
            <button
              onClick={() => has_prev && onPageChange(page - 1)}
              disabled={!has_prev}
              className={`relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 text-sm font-medium ${
                has_prev
                  ? 'bg-white text-gray-500 hover:bg-gray-50'
                  : 'bg-gray-100 text-gray-400 cursor-not-allowed'
              }`}
            >
              <span className="sr-only">Previous</span>
              <svg
                className="h-5 w-5"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                aria-hidden="true"
              >
                <path
                  fillRule="evenodd"
                  d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
            
            {/* Current Page Number */}
            <span className="relative inline-flex items-center px-4 py-2 border border-gray-300 bg-white text-sm font-medium text-gray-700">
              Page {page}
            </span>

            <button
              onClick={() => has_next && onPageChange(page + 1)}
              disabled={!has_next}
              className={`relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 text-sm font-medium ${
                has_next
                  ? 'bg-white text-gray-500 hover:bg-gray-50'
                  : 'bg-gray-100 text-gray-400 cursor-not-allowed'
              }`}
            >
              <span className="sr-only">Next</span>
              <svg
                className="h-5 w-5"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                aria-hidden="true"
              >
                <path
                  fillRule="evenodd"
                  d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
          </nav>
        </div>
      </div>
    </div>
  );
}

PaginationControls.propTypes = {
  paginationData: PropTypes.shape({
    page: PropTypes.number.isRequired,
    total_pages: PropTypes.number.isRequired,
    has_prev: PropTypes.bool.isRequired,
    has_next: PropTypes.bool.isRequired,
    total_items: PropTypes.number.isRequired,
  }),
  onPageChange: PropTypes.func.isRequired,
};

export default PaginationControls;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/common/ProtectedRoute.jsx">
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';

const ProtectedRoute = () => {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <Outlet />;
};

export default ProtectedRoute;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/layout/MainLayout.jsx">
import React from 'react';
import { Outlet } from 'react-router-dom';
import Navbar from './Navbar';
import DarkModeToggle from '../common/DarkModeToggle';

const MainLayout = () => {
  return (
    <div className="min-h-screen flex flex-col bg-gray-50">
      <Navbar />
      <main className="flex-1 max-w-7xl mx-auto w-full py-8 px-4 md:px-8">
        <Outlet />
      </main>
      <footer className="bg-white border-t border-gray-200 mt-auto">
        <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
          <p className="text-center text-sm text-gray-500">
            © {new Date().getFullYear()} FBO LaunchPad. All rights reserved.
          </p>
        </div>
      </footer>
    </div>
  );
};

export default MainLayout;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/Dashboard.tsx">
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { OrderStatusCard } from './OrderStatusCard';
import { FuelOrdersTable } from './FuelOrdersTable';
import { OrderStatus } from '../../types/orders';
import { useOrders } from '../../hooks/useOrders';

const Dashboard: React.FC = () => {
  const navigate = useNavigate();
  const { orders, loading, error } = useOrders();
  
  const [stats, setStats] = useState({
    pending: 0,
    inProgress: 0,
    completed: 0
  });

  useEffect(() => {
    if (orders) {
      setStats({
        pending: orders.filter(order => order.status === OrderStatus.PENDING).length,
        inProgress: orders.filter(order => order.status === OrderStatus.IN_PROGRESS).length,
        completed: orders.filter(order => order.status === OrderStatus.COMPLETED).length
      });
    }
  }, [orders]);

  return (
    <div className="p-6">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-semibold">CSR Dashboard</h1>
        <div className="text-sm text-gray-500">Welcome, Super User</div>
      </div>

      {/* Order Status Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <OrderStatusCard
          title="Pending Orders"
          description="Orders waiting for fueling"
          count={stats.pending}
          icon="clock"
          onViewAll={() => navigate('/orders?status=pending')}
        />
        <OrderStatusCard
          title="In Progress"
          description="Orders currently being fueled"
          count={stats.inProgress}
          icon="plane"
          onViewAll={() => navigate('/orders?status=in-progress')}
        />
        <OrderStatusCard
          title="Completed Orders"
          description="Recently completed fuel orders"
          count={stats.completed}
          icon="check"
          onViewAll={() => navigate('/orders?status=completed')}
        />
      </div>

      {/* Fuel Orders Section */}
      <div className="bg-white rounded-lg shadow">
        <div className="p-6 border-b border-gray-200">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold">Fuel Orders</h2>
            <div className="flex gap-4">
              <button
                onClick={() => navigate('/orders/export')}
                className="text-gray-600 hover:text-gray-800 flex items-center gap-2"
              >
                <span>Export</span>
              </button>
              <button
                onClick={() => navigate('/orders/new')}
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-2"
              >
                <span>New Order</span>
              </button>
            </div>
          </div>
        </div>
        
        <FuelOrdersTable orders={orders} loading={loading} error={error} />
      </div>
    </div>
  );
};

export default Dashboard;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/FuelOrdersTable.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { FuelOrder, OrderStatus } from '../../types/orders';

interface FuelOrdersTableProps {
  orders: FuelOrder[] | null;
  loading: boolean;
  error: Error | null;
}

export const FuelOrdersTable: React.FC<FuelOrdersTableProps> = ({
  orders,
  loading,
  error,
}) => {
  const navigate = useNavigate();

  if (loading) {
    return (
      <div className="p-6 text-center text-gray-500">
        Loading orders...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6 text-center text-red-500">
        Error loading orders: {error.message}
      </div>
    );
  }

  if (!orders || orders.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        No orders found
      </div>
    );
  }

  const getStatusClass = (status: OrderStatus) => {
    switch (status) {
      case OrderStatus.PENDING:
        return 'bg-yellow-100 text-yellow-800';
      case OrderStatus.IN_PROGRESS:
        return 'bg-blue-100 text-blue-800';
      case OrderStatus.COMPLETED:
        return 'bg-green-100 text-green-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Aircraft</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Customer</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Fuel Type</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Quantity</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Created</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {orders.map((order) => (
            <tr key={order.id} className="hover:bg-gray-50">
              <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">#{order.id}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{order.aircraft}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{order.customer}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{order.fuelType}</td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{order.quantity} gal</td>
              <td className="px-6 py-4 whitespace-nowrap">
                <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${getStatusClass(order.status)}`}>
                  {order.status}
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {new Date(order.created).toLocaleDateString()}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <button
                  onClick={() => navigate(`/orders/${order.id}`)}
                  className="text-blue-600 hover:text-blue-900"
                >
                  View
                </button>
                {order.status === OrderStatus.COMPLETED && (
                  <button
                    onClick={() => navigate(`/orders/${order.id}/receipt`)}
                    className="ml-4 text-blue-600 hover:text-blue-900"
                  >
                    View Receipt
                  </button>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/OrderFilters.jsx">
import React from 'react';
import PropTypes from 'prop-types';

// Define possible statuses for filtering (match backend enum names/values)
const statusOptions = [
  { value: '', label: 'All Statuses' },
  { value: 'DISPATCHED', label: 'Dispatched' },
  { value: 'ACKNOWLEDGED', label: 'Acknowledged' },
  { value: 'EN_ROUTE', label: 'En Route' },
  { value: 'FUELING', label: 'Fueling' },
  { value: 'COMPLETED', label: 'Completed' },
  { value: 'REVIEWED', label: 'Reviewed' },
  { value: 'CANCELLED', label: 'Cancelled' },
];

// Basic styling (inline for simplicity)
const styles = {
  container: { 
    marginBottom: '15px', 
    display: 'flex', 
    gap: '10px', 
    alignItems: 'center',
    padding: '10px',
    backgroundColor: '#f5f5f5',
    borderRadius: '4px',
  },
  label: { 
    marginRight: '5px',
    fontWeight: '500',
    color: '#333',
  },
  select: { 
    padding: '8px 12px',
    borderRadius: '4px',
    border: '1px solid #ddd',
    backgroundColor: 'white',
    minWidth: '200px',
    cursor: 'pointer',
  },
};

function OrderFilters({ currentFilters, onFilterChange }) {
  const handleStatusChange = (event) => {
    onFilterChange('status', event.target.value);
  };

  return (
    <div className="flex flex-wrap gap-4 items-center">
      <div className="flex items-center space-x-2">
        <label htmlFor="statusFilter" className="text-sm font-medium text-gray-700">
          Status:
        </label>
        <select
          id="statusFilter"
          value={currentFilters?.status || ''}
          onChange={handleStatusChange}
          className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
        >
          {statusOptions.map(option => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      </div>
      {/* Additional filters can be added here */}
    </div>
  );
}

OrderFilters.propTypes = {
  currentFilters: PropTypes.shape({
    status: PropTypes.string,
  }),
  onFilterChange: PropTypes.func.isRequired,
};

OrderFilters.defaultProps = {
  currentFilters: {
    status: '',
  },
};

export default OrderFilters;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/OrderGrid.jsx">
import React from 'react';
import PropTypes from 'prop-types';
import { formatDisplayValue } from '../../utils/formatters';

const statusColors = {
  DISPATCHED: 'bg-yellow-100 text-yellow-800',
  ACKNOWLEDGED: 'bg-blue-100 text-blue-800',
  EN_ROUTE: 'bg-purple-100 text-purple-800',
  FUELING: 'bg-orange-100 text-orange-800',
  COMPLETED: 'bg-green-100 text-green-800',
  REVIEWED: 'bg-gray-100 text-gray-800',
  CANCELLED: 'bg-red-100 text-red-800',
};

function OrderGrid({ orders, isLoading, error, onViewDetails }) {
  if (isLoading) {
    return (
      <div className="min-h-[400px] flex items-center justify-center">
        <div className="flex flex-col items-center space-y-4">
          <svg
            className="animate-spin h-8 w-8 text-blue-600"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          <p className="text-sm text-gray-500">Loading orders...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-[400px] flex items-center justify-center">
        <div className="text-center">
          <svg
            className="mx-auto h-12 w-12 text-red-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
            />
          </svg>
          <h3 className="mt-2 text-sm font-medium text-gray-900">Error loading orders</h3>
          <p className="mt-1 text-sm text-gray-500">{error}</p>
        </div>
      </div>
    );
  }

  if (!orders || orders.length === 0) {
    return (
      <div className="min-h-[400px] flex items-center justify-center">
        <div className="text-center">
          <svg
            className="mx-auto h-12 w-12 text-gray-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z"
            />
          </svg>
          <h3 className="mt-2 text-sm font-medium text-gray-900">No fuel orders found</h3>
          <p className="mt-1 text-sm text-gray-500">Get started by creating a new fuel order.</p>
        </div>
      </div>
    );
  }

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              ID
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Status
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Tail Number
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Assigned LST
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Created At
            </th>
            <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
              Actions
            </th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {orders.map((order) => (
            <tr key={order.id} className="hover:bg-gray-50">
              <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                {order.id}
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                  statusColors[order.status] || 'bg-gray-100 text-gray-800'
                }`}>
                  {order.status}
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {order.tail_number}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {order.assigned_lst_user_id || 'N/A'}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {formatDisplayValue(order.created_at, 'datetime')}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <button
                  onClick={() => onViewDetails(order.id)}
                  className="text-blue-600 hover:text-blue-900 focus:outline-none focus:underline"
                >
                  View Details
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

OrderGrid.propTypes = {
  orders: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      status: PropTypes.string.isRequired,
      tail_number: PropTypes.string.isRequired,
      assigned_lst_user_id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      created_at: PropTypes.string.isRequired,
    })
  ).isRequired,
  isLoading: PropTypes.bool,
  error: PropTypes.string,
  onViewDetails: PropTypes.func.isRequired,
};

OrderGrid.defaultProps = {
  isLoading: false,
  error: null,
};

export default OrderGrid;
</file>

<file path="fbo-launchpad-frontend-csr/src/components/orders/OrderStatusCard.tsx">
import React from 'react';
import { IconClock, IconPlane, IconCheck } from '../../components/common/Icons';

interface OrderStatusCardProps {
  title: string;
  description: string;
  count: number;
  icon: 'clock' | 'plane' | 'check';
  onViewAll: () => void;
}

const iconMap = {
  clock: IconClock,
  plane: IconPlane,
  check: IconCheck,
};

export const OrderStatusCard: React.FC<OrderStatusCardProps> = ({
  title,
  description,
  count,
  icon,
  onViewAll,
}) => {
  const Icon = iconMap[icon];

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-full bg-blue-100 flex items-center justify-center">
            <Icon className="w-5 h-5 text-blue-600" />
          </div>
          <div>
            <h3 className="text-lg font-semibold">{count}</h3>
            <p className="text-sm text-gray-500">{title}</p>
          </div>
        </div>
      </div>
      <p className="text-sm text-gray-600 mb-4">{description}</p>
      <button
        onClick={onViewAll}
        className="text-blue-600 hover:text-blue-800 text-sm font-medium"
      >
        View All
      </button>
    </div>
  );
};
</file>

<file path="fbo-launchpad-frontend-csr/src/contexts/AuthContext.jsx">
import { createContext, useContext, useState, useEffect } from 'react';
import { loginUser, logoutUser, getStoredToken } from '../services/authService';
import { decodeJWT } from '../utils/jwt';

export const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const token = getStoredToken();
    if (token) {
      const decoded = decodeJWT(token);
      if (decoded) {
        setIsAuthenticated(true);
        // Store all user data from JWT without filtering specific fields
        setUser(decoded);
      } else {
        // Invalid token, force logout
        logoutUser();
        setIsAuthenticated(false);
        setUser(null);
      }
    } else {
      setIsAuthenticated(false);
      setUser(null);
    }
    setLoading(false);
  }, []);

  const login = async (email, password) => {
    try {
      const data = await loginUser(email, password);
      setIsAuthenticated(true);
      const decoded = decodeJWT(data.token);
      if (decoded) {
        // Store all user data from JWT without filtering
        setUser(decoded);
      } else {
        setUser(null);
      }
      return data;
    } catch (error) {
      throw error;
    }
  };

  const logout = () => {
    logoutUser();
    setIsAuthenticated(false);
    setUser(null);
  };

  if (loading) {
    return null; // Or a loading spinner component
  }

  return (
    <AuthContext.Provider
      value={{
        isAuthenticated,
        user,
        login,
        logout
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="fbo-launchpad-frontend-csr/src/hooks/useOrders.ts">
import { useState, useEffect } from 'react';
import apiService, { getApiUrl } from '../services/apiService';
import { FuelOrder } from '../types/orders';

export const useOrders = () => {
  const [orders, setOrders] = useState<FuelOrder[] | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchOrders = async () => {
      try {
        const response = await apiService.get(getApiUrl('/fuel-orders/'));
        setOrders(response.data.fuel_orders || response.data.data || []);
        setError(null);
      } catch (err: any) {
        setError(err instanceof Error ? err : new Error('Failed to fetch orders'));
        setOrders(null);
      } finally {
        setLoading(false);
      }
    };

    fetchOrders();
  }, []);

  return { orders, loading, error };
};
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/DashboardPage.jsx">
import React from 'react';
import Dashboard from '../components/orders/Dashboard';

const DashboardPage = () => {
  return <Dashboard />;
};

export default DashboardPage;
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/LoginPage.jsx">
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

const LoginPage = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const navigate = useNavigate();
  const { login } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      await login(email, password);
      navigate('/');
    } catch (err) {
      setError(err.message || 'Failed to login. Please check your credentials.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h1 className="text-center text-3xl font-extrabold text-gray-900">
            FBO LaunchPad
          </h1>
          <h2 className="mt-6 text-center text-2xl font-bold text-gray-900">
            Sign in to your account
          </h2>
        </div>
        
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="email" className="sr-only">
                Email address
              </label>
              <input
                id="email"
                name="email"
                type="email"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                disabled={loading}
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                disabled={loading}
              />
            </div>
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="flex-shrink-0">
                  <svg className="h-5 w-5 text-red-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                  </svg>
                </div>
                <div className="ml-3">
                  <p className="text-sm font-medium text-red-800">{error}</p>
                </div>
              </div>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className={`group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white ${
                loading
                  ? 'bg-blue-400 cursor-not-allowed'
                  : 'bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500'
              }`}
            >
              {loading ? (
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              ) : null}
              {loading ? 'Signing in...' : 'Sign in'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default LoginPage;
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/NotFoundPage.jsx">
import React from 'react';
import { Link } from 'react-router-dom';

const NotFoundPage = () => {
  return (
    <div className="not-found-page">
      <h1>404 - Page Not Found</h1>
      <p>The page you are looking for does not exist.</p>
      <Link to="/">Return to Dashboard</Link>
    </div>
  );
};

export default NotFoundPage;
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/OrderCreatePage.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { getUsers } from '../services/UserService';
import { getFuelTrucks } from '../services/FuelTruckService';
import { createFuelOrder } from '../services/FuelOrderService';

function OrderCreatePage() {
  const [autoAssignEnabled, setAutoAssignEnabled] = useState(true); // Global admin setting
  const [autoAssign, setAutoAssign] = useState(true); // Per-order toggle (only if enabled)
  const [settingLoading, setSettingLoading] = useState(true);
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    tail_number: '',
    fuel_type: 'Jet A', // Default value
    assigned_lst_user_id: '',
    assigned_truck_id: '',
    requested_amount: '',
    location_on_ramp: '',
    additive_requested: false,
    csr_notes: '',
    customer_id: null // Optional
  });

  const [lsts, setLsts] = useState([]);
  const [trucks, setTrucks] = useState([]);
  const [isLoadingData, setIsLoadingData] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);
  const [submitSuccess, setSubmitSuccess] = useState(false);

  // Fetch global assignment setting on mount
  useEffect(() => {
    async function fetchSetting() {
      setSettingLoading(true);
      try {
        const res = await import('../services/apiService').then(m => m.default.get('/api/admin/assignment-settings'));
        setAutoAssignEnabled(res.data.auto_assign_enabled);
        setAutoAssign(res.data.auto_assign_enabled); // default to ON if enabled
      } catch {
        setAutoAssignEnabled(true); // fallback
      } finally {
        setSettingLoading(false);
      }
    }
    fetchSetting();
  }, []);

  // Fetch LSTs and Trucks on mount
    const loadDropdownData = async () => {
      setIsLoadingData(true);
      setError(null);
      try {
        const [lstData, truckData] = await Promise.all([
          getUsers({ is_active: 'true' }),
          getFuelTrucks({ is_active: 'true' })
        ]);
        setLsts(lstData);
        setTrucks(truckData);
      } catch (err) {
        setError('Failed to load LSTs or Trucks. Please try again.');
        console.error(err);
      }
    };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const validateForm = () => {
    if (!formData.tail_number || !formData.fuel_type) {
      setError('Please fill in all required fields: Tail Number and Fuel Type.');
      return false;
    }
    if (!autoAssign) {
      if (!formData.assigned_lst_user_id || !formData.assigned_truck_id) {
        setError('Please assign both an LST and a Fuel Truck, or enable auto-assign.');
        return false;
      }
    }
    setError(null);
    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!validateForm()) return;

    setIsSubmitting(true);
    setError(null);
    setSubmitSuccess(false);

    let assignedLST = formData.assigned_lst_user_id;
    let assignedTruck = formData.assigned_truck_id;

    // If auto-assign is enabled, set assigned_lst_user_id to -1 for backend auto-assignment
    if (autoAssign) {
      assignedLST = -1; // Backend will auto-assign
      assignedTruck = null; // Leave truck as null (or handle similarly if backend supports)
    } else {
      assignedLST = parseInt(assignedLST, 10);
      assignedTruck = parseInt(assignedTruck, 10);
    }

    // Fallback: If backend does not assign, do a simple least-busy pick
    async function getLeastBusy(items, key = 'id') {
      // For demo: just pick the first (could enhance with real logic)
      return items.length > 0 ? items[0][key] : null;
    }

    let orderData = {
      ...formData,
      requested_amount: formData.requested_amount || null,
      customer_id: formData.customer_id || null,
      assigned_lst_user_id: assignedLST,
      assigned_truck_id: assignedTruck,
    };

    // If autoAssign, remove assigned_lst_user_id and assigned_truck_id if null
    if (autoAssign) {
      delete orderData.assigned_lst_user_id;
      delete orderData.assigned_truck_id;
    }

    try {
      let result = await createFuelOrder(orderData);
      // If backend did not assign, fallback to frontend assignment
      if (autoAssign && (!result.assigned_lst_user_id || !result.assigned_truck_id)) {
        // Pick least busy (for demo, just pick first available)
        const lstId = await getLeastBusy(lsts, 'id');
        const truckId = await getLeastBusy(trucks, 'id');
        orderData.assigned_lst_user_id = lstId;
        orderData.assigned_truck_id = truckId;
        result = await createFuelOrder(orderData);
      }
      setSubmitSuccess(true);
      // Optionally show assigned info
      if (result.assigned_lst_user_id || result.assigned_truck_id) {
        setError(`Assigned LST: ${result.assigned_lst_user_id || 'N/A'}, Truck: ${result.assigned_truck_id || 'N/A'}`);
      }
      setTimeout(() => navigate('/'), 1500); // Redirect after delay
    } catch (err) {
      setError(err.message || 'Failed to create fuel order.');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Loading state
  if (settingLoading || isLoadingData) {
    return (
      <div className="container mx-auto p-4">
        <h1 className="text-2xl font-bold mb-4">Create New Fuel Order</h1>
        <div>Loading form data...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Create New Fuel Order</h1>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Only show auto/manual assign toggle if global setting is enabled */}
        {autoAssignEnabled && (
          <div className="form-group flex items-center gap-2 mb-2">
            <input
              type="checkbox"
              id="autoAssign"
              name="autoAssign"
              checked={autoAssign}
              onChange={e => setAutoAssign(e.target.checked)}
              className="form-checkbox"
            />
            <label htmlFor="autoAssign" className="text-sm font-medium">
              Auto-assign LST and Fuel Truck
            </label>
          </div>
        )}
        {/* Tail Number Input */}
        <div className="form-group">
          <label htmlFor="tail_number" className="block text-sm font-medium mb-1">
            Tail Number*
          </label>
          <input
            type="text"
            id="tail_number"
            name="tail_number"
            value={formData.tail_number}
            onChange={handleChange}
            className="w-full p-2 border rounded"
            required
          />
        </div>

        {/* Fuel Type Input */}
        <div className="form-group">
          <label htmlFor="fuel_type" className="block text-sm font-medium mb-1">
            Fuel Type*
          </label>
          <select
            id="fuel_type"
            name="fuel_type"
            value={formData.fuel_type}
            onChange={handleChange}
            className="w-full p-2 border rounded"
            required
          >
            <option value="Jet A">Jet A</option>
            <option value="Jet A-1">Jet A-1</option>
            <option value="100LL">100LL</option>
          </select>
        </div>

        {/* Assigned LST Select */}
        {!autoAssign && (
          <div className="form-group">
            <label htmlFor="assigned_lst_user_id" className="block text-sm font-medium mb-1">
              Assign LST*
            </label>
            <select
              id="assigned_lst_user_id"
              name="assigned_lst_user_id"
              value={formData.assigned_lst_user_id}
              onChange={handleChange}
              className="w-full p-2 border rounded"
              required={!autoAssign}
            >
              <option value="">Select LST...</option>
              <option value="-1">Auto-assign (let system choose)</option>
              {lsts.map(lst => (
                <option key={lst.id} value={lst.id}>
                  {lst.name} (ID: {lst.id})
                </option>
              ))}
            </select>
          </div>
        )}

        {/* Assigned Truck Select */}
        {!autoAssign && (
          <div className="form-group">
            <label htmlFor="assigned_truck_id" className="block text-sm font-medium mb-1">
              Assign Truck*
            </label>
            <select
              id="assigned_truck_id"
              name="assigned_truck_id"
              value={formData.assigned_truck_id}
              onChange={handleChange}
              className="w-full p-2 border rounded"
              required={!autoAssign}
            >
              <option value="">Select Truck...</option>
              {trucks.map(truck => (
                <option key={truck.id} value={truck.id}>
                  {truck.name} (ID: {truck.id})
                </option>
              ))}
            </select>
          </div>
        )}

        {/* Requested Amount Input */}
        <div className="form-group">
          <label htmlFor="requested_amount" className="block text-sm font-medium mb-1">
            Requested Amount (Gal)
          </label>
          <input
            type="number"
            step="0.01"
            id="requested_amount"
            name="requested_amount"
            value={formData.requested_amount}
            onChange={handleChange}
            className="w-full p-2 border rounded"
          />
        </div>

        {/* Location Input */}
        <div className="form-group">
          <label htmlFor="location_on_ramp" className="block text-sm font-medium mb-1">
            Location on Ramp
          </label>
          <input
            type="text"
            id="location_on_ramp"
            name="location_on_ramp"
            value={formData.location_on_ramp}
            onChange={handleChange}
            className="w-full p-2 border rounded"
          />
        </div>

        {/* Additive Checkbox */}
        <div className="form-group">
          <label className="flex items-center space-x-2">
            <input
              type="checkbox"
              id="additive_requested"
              name="additive_requested"
              checked={formData.additive_requested}
              onChange={handleChange}
              className="form-checkbox"
            />
            <span className="text-sm font-medium">Additive Requested</span>
          </label>
        </div>

        {/* CSR Notes Textarea */}
        <div className="form-group">
          <label htmlFor="csr_notes" className="block text-sm font-medium mb-1">
            CSR Notes
          </label>
          <textarea
            id="csr_notes"
            name="csr_notes"
            value={formData.csr_notes}
            onChange={handleChange}
            className="w-full p-2 border rounded"
            rows="3"
          />
        </div>

        {/* Error Message */}
        {error && !isSubmitting && (
          <div className="text-red-600 text-sm">{error}</div>
        )}

        {/* Success Message */}
        {submitSuccess && (
          <div className="text-green-600 text-sm">
            Fuel order created successfully! Redirecting...
          </div>
        )}

        {/* Submit Button */}
        <button
          type="submit"
          disabled={isSubmitting || isLoadingData}
          className={`w-full p-2 text-white rounded ${
            isSubmitting || isLoadingData
              ? 'bg-gray-400 cursor-not-allowed'
              : 'bg-blue-600 hover:bg-blue-700'
          }`}
        >
          {isSubmitting ? 'Creating Order...' : 'Create Fuel Order'}
        </button>
      </form>
    </div>
  );
}

export default OrderCreatePage;
</file>

<file path="fbo-launchpad-frontend-csr/src/pages/OrderDetailPage.jsx">
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { getFuelOrderById, reviewFuelOrder } from '../services/FuelOrderService';
import { formatDisplayValue } from '../utils/formatters';

const OrderDetailPage = () => {
  const { orderId } = useParams();
  const [order, setOrder] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isReviewing, setIsReviewing] = useState(false);
  const [reviewError, setReviewError] = useState(null);

  useEffect(() => {
    const fetchOrder = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const data = await getFuelOrderById(orderId);
        setOrder(data);
      } catch (err) {
        setError(err.message || 'Failed to fetch order details');
      } finally {
        setIsLoading(false);
      }
    };

    fetchOrder();
  }, [orderId]);

  const handleMarkAsReviewed = async () => {
    if (!order || order.status !== 'COMPLETED') return;

    setIsReviewing(true);
    setReviewError(null);
    try {
      const updatedOrder = await reviewFuelOrder(orderId);
      setOrder(updatedOrder);
    } catch (err) {
      setReviewError(err.message || 'Failed to mark order as reviewed');
    } finally {
      setIsReviewing(false);
    }
  };

  if (isLoading) {
    return <div>Loading order details...</div>;
  }

  if (error) {
    return <div className="error-message">Error: {error}</div>;
  }

  if (!order) {
    return <div>No order found</div>;
  }

  return (
    <div className="order-detail-page">
      <h1>Fuel Order Details</h1>
      
      <dl className="order-details">
        <dt>Order ID</dt>
        <dd>{order.id}</dd>

        <dt>Status</dt>
        <dd>{order.status}</dd>

        <dt>Customer</dt>
        <dd>{order.customer}</dd>

        <dt>Aircraft</dt>
        <dd>{order.tail_number}</dd>

        <dt>Fuel Type</dt>
        <dd>{order.fuel_type}</dd>

        <dt>Requested Amount (Gallons)</dt>
        <dd>{order.requested_amount}</dd>

        <dt>Created At</dt>
        <dd>{formatDisplayValue(order.created_at, 'datetime')}</dd>

        {order.completed_at && (
          <>
            <dt>Completed At</dt>
            <dd>{formatDisplayValue(order.completed_at, 'datetime')}</dd>
          </>
        )}

        {order.reviewed_at && (
          <>
            <dt>Reviewed At</dt>
            <dd>{formatDisplayValue(order.reviewed_at, 'datetime')}</dd>
            <dt>Reviewed By</dt>
            <dd>{order.reviewed_by_csr_user_id}</dd>
          </>
        )}
      </dl>

      {order.status === 'COMPLETED' && (
        <div className="order-actions">
          <button
            onClick={handleMarkAsReviewed}
            disabled={isReviewing}
            className="review-button"
          >
            {isReviewing ? 'Reviewing...' : 'Mark as Reviewed'}
          </button>
          {reviewError && (
            <p className="error-message">Error: {reviewError}</p>
          )}
        </div>
      )}
    </div>
  );
};

export default OrderDetailPage;
</file>

<file path="fbo-launchpad-frontend-csr/src/services/apiService.js">
import axios from 'axios';

// Helper function to build the correct API path
// Only add '/api' for endpoints that require it (like users and trucks)
// Do NOT add '/api' for endpoints like fuel-orders
export function getApiUrl(endpoint) {
  // Remove leading slash for consistency
  const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
  // Endpoints that need '/api' prefix
  const apiPrefixed = ['users', 'fuel-trucks'];
  if (apiPrefixed.some(prefix => cleanEndpoint.startsWith(prefix))) {
    return `/api/${cleanEndpoint}`;
  }
  // All others (like 'fuel-orders') do NOT get '/api' prefix
  return `/${cleanEndpoint}`;
}

const apiService = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for API calls
apiService.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for API calls
apiService.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    const status = error.response?.status;
    const data = error.response?.data;

    // Detect invalid/expired JWT or signature verification failure
    const isAuthError =
      [401, 422].includes(status) &&
      (
        (typeof data === 'string' && data.toLowerCase().includes('signature verification failed')) ||
        (typeof data?.msg === 'string' && data.msg.toLowerCase().includes('signature verification failed')) ||
        (typeof data?.error === 'string' && data.error.toLowerCase().includes('signature verification failed'))
      );

    if (isAuthError || (status === 401 && !originalRequest._retry)) {
      localStorage.removeItem('accessToken');
      window.location.href = '/login';
      return Promise.reject(error);
    }

    return Promise.reject(error);
  }
);

export default apiService;
// Usage example elsewhere in your code:
// apiService.get(getApiUrl('/users')) // will call /api/users
// apiService.get(getApiUrl('/fuel-orders')) // will call /fuel-orders
</file>

<file path="fbo-launchpad-frontend-csr/src/services/authService.js">
import apiService from './apiService';

export const loginUser = async (email, password) => {
  // Always clear any old token before login
  localStorage.removeItem('accessToken');
  try {
    const response = await apiService.post('/auth/login', {
      email,
      password,
    });
    
    if (response.data.token) {
      localStorage.setItem('accessToken', response.data.token);
      return response.data;
    }
    
    throw new Error('Login failed: No access token received');
  } catch (error) {
    const message = error.response?.data?.message || error.message || 'Login failed';
    throw new Error(message);
  }
};

export const logoutUser = () => {
  localStorage.removeItem('accessToken');
};

export const getStoredToken = () => {
  return localStorage.getItem('accessToken');
};
</file>

<file path="fbo-launchpad-frontend-csr/src/services/FuelOrderService.js">
import apiService, { getApiUrl } from './apiService';

export const getFuelOrders = async (params = {}) => {
  try {
    const response = await apiService.get(getApiUrl('/fuel-orders/'), { params });
    return response.data;
  } catch (error) {
    console.error("Error fetching fuel orders:", error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to fetch fuel orders' };
  }
};

export const createFuelOrder = async (orderData) => {
  try {
    const response = await apiService.post('/fuel-orders/', orderData);
    return response.data; // Assuming { message, fuel_order } structure
  } catch (error) {
    console.error("Error creating fuel order:", error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to create fuel order' };
  }
};

export const getFuelOrderById = async (orderId) => {
  try {
    const response = await apiService.get(getApiUrl(`/fuel-orders/${orderId}/`));
    return response.data.fuel_order;
  } catch (error) {
    console.error(`Error fetching fuel order ${orderId}:`, error.response?.data || error.message);
    throw error.response?.data || { message: `Failed to fetch fuel order ${orderId}` };
  }
};

export const reviewFuelOrder = async (orderId) => {
  try {
    const response = await apiService.patch(`/fuel-orders/${orderId}/review`);
    return response.data.fuel_order;
  } catch (error) {
    console.error(`Error marking order ${orderId} as reviewed:`, error.response?.data || error.message);
    throw error.response?.data || { message: `Failed to mark order ${orderId} as reviewed` };
  }
};

export const exportFuelOrdersCsv = async (params = {}) => {
  try {
    const response = await apiService.get('/fuel-orders/export/', {
      params,
      responseType: 'blob', // Important: Expect file data
    });

    // Extract filename from content-disposition header
    const disposition = response.headers['content-disposition'];
    let filename = 'fuel_orders_export.csv'; // Default
    if (disposition && disposition.indexOf('attachment') !== -1) {
        const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
        const matches = filenameRegex.exec(disposition);
        if (matches != null && matches[1]) {
          filename = matches[1].replace(/['"]/g, '');
        }
    }

    // Check if the response indicates no data, even if status is 200
    // This depends on backend implementation (e.g., sending a specific header or empty blob)
    // For now, assume a non-empty blob means success with data.
    if (response.data.size === 0) {
        // Handle no data scenario - throwing a specific error type could be useful
        throw { code: 'NO_DATA_FOUND', message: 'No orders found matching criteria for export.' };
    }


    return {
        blob: response.data, // The actual file blob
        filename: filename
    };

  } catch (error) {
    // If it's the NO_DATA_FOUND error we threw, re-throw it
    if (error.code === 'NO_DATA_FOUND') {
        throw error;
    }

    console.error("Error exporting CSV:", error); // Log the full error

    // Try to parse error response if it's a JSON blob
    let errorData = { message: 'Failed to export CSV' };
    if (error.response && error.response.data instanceof Blob && error.response.headers['content-type']?.includes('application/json')) {
        try {
            const errorJsonText = await error.response.data.text();
            const errorJson = JSON.parse(errorJsonText);
            // Use the 'error' field if available, otherwise use 'message' or default
            errorData = { message: errorJson.error || errorJson.message || 'Failed to export CSV' };
        } catch (parseError) {
            console.error("Failed to parse error blob as JSON", parseError);
        }
    } else if (error.response?.data?.error) {
        // Use the 'error' field from standard JSON error response
         errorData = { message: error.response.data.error };
    } else if (error.response?.data?.message) {
         // Use 'message' if 'error' field is not present
         errorData = { message: error.response.data.message };
    } else if (error.message) {
        // Fallback to generic error message
        errorData = { message: error.message };
    }

    throw errorData; // Throw a structured error object
  }
};

// Additional fuel order service functions will be added here later
// e.g., createOrder, updateOrder, getOrderById, etc.
</file>

<file path="fbo-launchpad-frontend-csr/src/services/FuelTruckService.js">
import apiService, { getApiUrl } from './apiService';

export const getFuelTrucks = async (params = {}) => {
  try {
    const response = await apiService.get(getApiUrl('/fuel-trucks/'), { params });
    return response.data.fuel_trucks || [];
  } catch (error) {
    console.error("Error fetching fuel trucks:", error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to fetch fuel trucks' };
  }
};

export const createFuelTruck = async (data) => {
  try {
    const response = await apiService.post(getApiUrl('/fuel-trucks/'), data);
    return response.data;
  } catch (error) {
    console.error('Error creating fuel truck:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to create fuel truck' };
  }
};

export const getFuelTruckById = async (id) => {
  try {
    const response = await apiService.get(getApiUrl(`/fuel-trucks/${id}`));
    return response.data.fuel_truck;
  } catch (error) {
    console.error('Error fetching fuel truck:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to fetch fuel truck' };
  }
};

export const updateFuelTruck = async (id, data) => {
  try {
    const response = await apiService.patch(getApiUrl(`/fuel-trucks/${id}`), data);
    return response.data;
  } catch (error) {
    console.error('Error updating fuel truck:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to update fuel truck' };
  }
};

export const deleteFuelTruck = async (id) => {
  try {
    const response = await apiService.delete(getApiUrl(`/fuel-trucks/${id}`));
    return response.data;
  } catch (error) {
    console.error('Error deleting fuel truck:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to delete fuel truck' };
  }
};

const FuelTruckService = {
  getFuelTrucks,
  createFuelTruck,
  getFuelTruckById,
  updateFuelTruck,
  deleteFuelTruck
};

export default FuelTruckService;
</file>

<file path="fbo-launchpad-frontend-csr/src/services/UserService.js">
import apiService, { getApiUrl } from './apiService';

export const getUsers = async (params = {}) => {
  try {
    const response = await apiService.get(getApiUrl('/users/'), { params });
    return response.data.users || [];
  } catch (error) {
    console.error("Error fetching users:", error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to fetch users' };
  }
};

export const createUser = async (userData) => {
  // userData: {name, email, password, role_ids, is_active}
  try {
    const response = await apiService.post(getApiUrl('/users/'), userData);
    return response.data;
  } catch (error) {
    console.error('Error creating user:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to create user' };
  }
};

export const getUserById = async (userId) => {
  try {
    const response = await apiService.get(getApiUrl(`/users/${userId}`));
    return response.data.user;
  } catch (error) {
    console.error('Error fetching user:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to fetch user' };
  }
};

export const updateUser = async (userId, updateData) => {
  // updateData: {name, email, role_ids, is_active} (no password)
  try {
    const response = await apiService.patch(getApiUrl(`/users/${userId}`), updateData);
    return response.data;
  } catch (error) {
    console.error('Error updating user:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to update user' };
  }
};

export const deleteUser = async (userId) => {
  try {
    const response = await apiService.delete(getApiUrl(`/users/${userId}`));
    return response.data;
  } catch (error) {
    console.error('Error deleting user:', error.response?.data || error.message);
    throw error.response?.data || { message: 'Failed to delete user' };
  }
};

const UserService = {
  getUsers,
  createUser,
  getUserById,
  updateUser,
  deleteUser
};

export default UserService;
</file>

<file path="fbo-launchpad-frontend-csr/src/styles/global.css">
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

/* Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base styles */
@layer base {
  html {
    @apply antialiased;
  }
  
  body {
    @apply bg-gray-50 text-gray-900 min-h-screen font-sans;
  }

  h1, h2, h3, h4, h5, h6 {
    @apply font-semibold leading-tight;
  }

  a {
    @apply text-primary hover:text-primary-dark transition-colors duration-200;
  }

  button:disabled {
    @apply cursor-not-allowed opacity-70;
  }

  input,
  select,
  textarea {
    @apply font-inherit;
  }
}

/* Component styles */
@layer components {
  .status-dispatched { @apply bg-amber-100 text-amber-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-acknowledged { @apply bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-en-route { @apply bg-purple-100 text-purple-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-fueling { @apply bg-orange-100 text-orange-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-completed { @apply bg-green-100 text-green-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-reviewed { @apply bg-gray-100 text-gray-800 px-2 py-1 rounded-full text-sm font-medium; }
  .status-cancelled { @apply bg-red-100 text-red-800 px-2 py-1 rounded-full text-sm font-medium; }
}

@layer utilities {
  .font-inherit {
    font-family: inherit;
  }
}

/* Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  line-height: 1.25;
}

/* Links */
a {
  color: var(--primary);
  text-decoration: none;
  transition: color 0.2s ease;
}

a:hover {
  color: var(--primary-dark);
}

/* Buttons */
button {
  cursor: pointer;
  font-family: inherit;
}

button:disabled {
  cursor: not-allowed;
  opacity: 0.7;
}

/* Form Elements */
input,
select,
textarea {
  font-family: inherit;
  font-size: inherit;
}

/* Status Colors */
.status-dispatched { background-color: #fef3c7; color: #92400e; }
.status-acknowledged { background-color: #dbeafe; color: #1e40af; }
.status-en-route { background-color: #f3e8ff; color: #6b21a8; }
.status-fueling { background-color: #ffedd5; color: #9a3412; }
.status-completed { background-color: #dcfce7; color: #166534; }
.status-reviewed { background-color: #f3f4f6; color: #374151; }
.status-cancelled { background-color: #fee2e2; color: #991b1b; }

/* Utility Classes */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.font-bold { font-weight: 700; }
.font-semibold { font-weight: 600; }
.font-medium { font-weight: 500; }
.font-normal { font-weight: 400; }

.text-sm { font-size: 0.875rem; }
.text-base { font-size: 1rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }
.text-2xl { font-size: 1.5rem; }

.mt-1 { margin-top: 0.25rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-4 { margin-top: 1rem; }
.mt-6 { margin-top: 1.5rem; }
.mt-8 { margin-top: 2rem; }

.mb-1 { margin-bottom: 0.25rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-4 { margin-bottom: 1rem; }
.mb-6 { margin-bottom: 1.5rem; }
.mb-8 { margin-bottom: 2rem; }

.mx-auto { margin-left: auto; margin-right: auto; }

.p-1 { padding: 0.25rem; }
.p-2 { padding: 0.5rem; }
.p-4 { padding: 1rem; }
.p-6 { padding: 1.5rem; }
.p-8 { padding: 2rem; }

.rounded-sm { border-radius: 0.125rem; }
.rounded { border-radius: 0.25rem; }
.rounded-md { border-radius: 0.375rem; }
.rounded-lg { border-radius: 0.5rem; }
.rounded-full { border-radius: 9999px; }

/* Shadows */
.shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
.shadow { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
.shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
.shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }

/* Transitions */
.transition { transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform; }
.transition-colors { transition-property: background-color, border-color, color, fill, stroke; }
.transition-opacity { transition-property: opacity; }
.transition-shadow { transition-property: box-shadow; }
.duration-150 { transition-duration: 150ms; }
.duration-200 { transition-duration: 200ms; }
.duration-300 { transition-duration: 300ms; }
.ease-in-out { transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); }

/* Animations */
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

/* Responsive Design */
@media (min-width: 640px) {
  .container {
    max-width: 640px;
  }
}

@media (min-width: 768px) {
  .container {
    max-width: 768px;
  }
}

@media (min-width: 1024px) {
  .container {
    max-width: 1024px;
  }
}

@media (min-width: 1280px) {
  .container {
    max-width: 1280px;
  }
}

/* Add any additional custom styles here */
</file>

<file path="fbo-launchpad-frontend-csr/src/test/setup.js">
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend Vitest's expect method with testing-library matchers
expect.extend(matchers);

// Cleanup after each test case (e.g. clearing jsdom)
afterEach(() => {
  cleanup();
});
</file>

<file path="fbo-launchpad-frontend-csr/src/test/utils.jsx">
import { render } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from '../contexts/AuthContext';

// Custom render function that includes providers
export function renderWithProviders(ui, { route = '/' } = {}) {
  window.history.pushState({}, 'Test page', route);

  return {
    ...render(
      <BrowserRouter>
        <AuthProvider>
          {ui}
        </AuthProvider>
      </BrowserRouter>
    ),
  };
}

// Mock JWT token for testing
export const mockToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6IkNTUiIsImlhdCI6MTUxNjIzOTAyMn0.L7PwspUjKJ8hpHRU7ANHAWoILqYYykTaAh4E0E6-h9c';

// Mock user data
export const mockUser = {
  id: 1,
  username: 'testuser',
  email: 'test@example.com',
  role: 'CSR',
  name: 'Test User'
};

// Mock API response data
export const mockApiResponses = {
  login: {
    token: mockToken,
    user: mockUser
  },
  orders: {
    data: [
      {
        id: 1,
        status: 'PENDING',
        customer: 'Test Customer',
        aircraft: 'N12345',
        fuelType: 'Jet A',
        quantity: 1000,
        createdAt: '2024-02-20T12:00:00Z'
      }
    ],
    total: 1,
    page: 1,
    perPage: 10
  }
};
</file>

<file path="fbo-launchpad-frontend-csr/src/types/orders.ts">
export enum OrderStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  COMPLETED = 'COMPLETED'
}

export interface FuelOrder {
  id: number;
  tail_number: string;
  customer: string;
  fuel_type: string;
  requested_amount: number;
  status: OrderStatus;
  created_at: string;
}
</file>

<file path="fbo-launchpad-frontend-csr/src/utils/formatters.js">
/**
 * Formats a value based on the specified type
 * @param {*} value - The value to format
 * @param {string} type - The type of formatting to apply ('datetime', 'date', 'currency', etc.)
 * @returns {string} The formatted value
 */
export const formatDisplayValue = (value, type = 'text') => {
  if (value === null || value === undefined) {
    return '-';
  }

  switch (type) {
    case 'datetime':
      return new Date(value).toLocaleString('en-US', {
        dateStyle: 'medium',
        timeStyle: 'short'
      });
    
    case 'date':
      return new Date(value).toLocaleDateString('en-US', {
        dateStyle: 'medium'
      });
    
    case 'currency':
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
      }).format(value);
    
    case 'number':
      return new Intl.NumberFormat('en-US').format(value);
    
    default:
      return String(value);
  }
};
</file>

<file path="fbo-launchpad-frontend-csr/src/App.jsx">
import React from 'react';
import { DarkModeProvider } from './context/DarkModeContext';
import { Routes, Route, Navigate } from 'react-router-dom';
import MainLayout from './components/layout/MainLayout';
import ProtectedRoute from './components/common/ProtectedRoute';
import LoginPage from './pages/LoginPage';
import DashboardPage from './pages/DashboardPage';
import OrderCreatePage from './pages/OrderCreatePage';
import OrderDetailPage from './pages/OrderDetailPage';
import NotFoundPage from './pages/NotFoundPage';
import AdminLayout from './components/layout/AdminLayout';
import TruckManagementPage from './pages/admin/TruckManagementPage';
import UserManagementPage from './pages/admin/UserManagementPage';
import AircraftManagementPage from './pages/admin/AircraftManagementPage';
import CustomerManagementPage from './pages/admin/CustomerManagementPage';
import RoleManagementPage from './pages/admin/RoleManagementPage';
import PermissionListPage from './pages/admin/PermissionListPage';

function App() {
  return (
    <DarkModeProvider>
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors duration-300">
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={<LoginPage />} />

          {/* Protected Routes */}
          <Route element={<ProtectedRoute />}>
            <Route element={<MainLayout />}>
              <Route path="/" element={<DashboardPage />} />
              <Route path="/orders/new" element={<OrderCreatePage />} />
              <Route path="/orders/:orderId" element={<OrderDetailPage />} />
            </Route>

            {/* Admin Section - Protected by backend permissions */}
            <Route element={<AdminLayout />}>
              <Route path="/admin/trucks" element={<TruckManagementPage />} />
              <Route path="/admin/users" element={<UserManagementPage />} />
              <Route path="/admin/aircraft" element={<AircraftManagementPage />} />
              <Route path="/admin/customers" element={<CustomerManagementPage />} />
              <Route path="/admin/roles" element={<RoleManagementPage />} />
              <Route path="/admin/permissions" element={<PermissionListPage />} />
              <Route path="/admin" element={<Navigate to="/admin/trucks" replace />} />
            </Route>
          </Route>

          {/* 404 catch-all route */}
          <Route path="*" element={<NotFoundPage />} />
        </Routes>
      </div>
    </DarkModeProvider>
  );
}

export default App;
</file>

<file path="fbo-launchpad-frontend-csr/src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import { AuthProvider } from './contexts/AuthContext'
import App from './App'
import './styles/global.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </React.StrictMode>,
)
</file>

<file path="fbo-launchpad-frontend-csr/src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_BASE_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
</file>

<file path="fbo-launchpad-frontend-csr/.env">
VITE_API_BASE_URL=http://localhost:5001
</file>

<file path="fbo-launchpad-frontend-csr/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="fbo-launchpad-frontend-csr/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
</file>

<file path="fbo-launchpad-frontend-csr/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="fbo-launchpad-frontend-csr/package.json">
{
  "name": "fbo-launchpad-frontend-csr",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest watch"
  },
  "dependencies": {
    "axios": "^1.8.4",
    "file-saver": "^2.0.5",
    "jwt-decode": "^4.0.0",
    "prop-types": "^15.8.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^6.22.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitest/coverage-v8": "^1.3.1",
    "@vitest/ui": "^1.3.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "jsdom": "^24.0.0",
    "postcss": "^8.5.3",
    "postcss-import": "^16.1.0",
    "postcss-nesting": "^13.0.1",
    "tailwindcss": "^3.4.17",
    "vite": "^6.3.3",
    "vitest": "^1.3.1"
  }
}
</file>

<file path="fbo-launchpad-frontend-csr/postcss.config.cjs">
// postcss.config.cjs
module.exports = {
  plugins: {
    'postcss-nesting': {},      // <-- Verify this line says 'postcss-nesting'
    'tailwindcss': {},
    autoprefixer: {},
  }
}
</file>

<file path="fbo-launchpad-frontend-csr/postcss.config.js">
/** @type {import('postcss').Config} */
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
}
</file>

<file path="fbo-launchpad-frontend-csr/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="fbo-launchpad-frontend-csr/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: 'class',
  content: [
    "./index.html",
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        gray: {
          50: '#F9FAFB',
          100: '#F3F4F6',
          200: '#E5E7EB',
          300: '#D1D5DB',
          400: '#9CA3AF',
          500: '#6B7280',
          600: '#4B5563',
          700: '#374151',
          800: '#1F2937',
          900: '#111827',
        },
        primary: {
          DEFAULT: '#2563eb',
          dark: '#1d4ed8'
        },
        success: '#059669',
        warning: '#d97706',
        danger: '#dc2626',
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
      },
    },
  },
  plugins: [],
}
</file>

<file path="fbo-launchpad-frontend-csr/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true,
  },
})
</file>

<file path="fbo-launchpad-frontend-csr/vitest.config.js">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.js'],
    include: ['src/**/*.{test,spec}.{js,jsx}'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/setup.js',
      ],
    },
  },
});
</file>

</files>
